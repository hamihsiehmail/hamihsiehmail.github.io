{
  "hpython String Interpolation 30-seconds-of-code": {
    "prefix": "hpython String Interpolation 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The most used f-string feature by far is string interpolation. All you need to do is wrap the value or variable in curly braces (`{}`) and you're good to go.\r",
      "\r",
      "```py\r",
      "str_val = 'apples'\r",
      "num_val = 42\r",
      "\r",
      "print(f'{num_val} {str_val}') # 42 apples\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Variable names 30-seconds-of-code": {
    "prefix": "hpython Variable names 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Apart from getting a variable's value, you can also get its name alongside the value. This can be especially useful when debugging and can be easily accomplished by adding an equals sign (`=`) after the variable name inside the curly braces.\r",
      "\r",
      "Bear in mind that whitespace inside the curly braces is taken into account, so adding spaces around the equals sign can make for a more readable result.\r",
      "\r",
      "```py\r",
      "str_val = 'apples'\r",
      "num_val = 42\r",
      "\r",
      "print(f'{str_val=}, {num_val = }') # str_val='apples', num_val = 42\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Mathematical operations 30-seconds-of-code": {
    "prefix": "hpython Mathematical operations 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Not syntactically unlike variable names, you can also perform mathematical operations in f-strings. You can place the mathematical expression inside the curly braces and, if you add an equal sign, you'll get the expression and its result.\r",
      "\r",
      "```py\r",
      "num_val = 42\r",
      "\r",
      "print(f'{num_val % 2 = }') # num_val % 2 = 0\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Printable representation 30-seconds-of-code": {
    "prefix": "hpython Printable representation 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Apart from plain string interpolation, you might want to get the printable representation of a value. This is already easy to accomplish using the `repr()` function. f-strings provide a much shorter syntax by appending a `!r` inside the curly braces.\r",
      "\r",
      "```py\r",
      "str_val = 'apples'\r",
      "\r",
      "print(f'{str_val!r}') # 'apples'\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Number formatting 30-seconds-of-code": {
    "prefix": "hpython Number formatting 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Additionally, f-strings can also be used for formatting - hence the **f** in the name. To add formatting to a value you can add a colon (`:`) followed by a format specifier. This can also be combined with the equals sing from before, shall you want to print the name of the variable as well.\r",
      "\r",
      "Numbers are a great candidate for this. If, for example, you want to trim a numeric value to two digits after the decimal, you can use the `.2f` format specifier.\r",
      "\r",
      "```py\r",
      "price_val = 6.12658\r",
      "\r",
      "print(f'{price_val:.2f}') # 6.13\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Date formatting 30-seconds-of-code": {
    "prefix": "hpython Date formatting 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Finally, dates can also be formatted the same way as numbers, using format specifiers. As usual, `%Y` denotes the full year, `%m` is the month and `%d` is the day of the month.\r",
      "\r",
      "```py\r",
      "from datetime import datetime;\r",
      "\r",
      "date_val = datetime.utcnow()\r",
      "\r",
      "print(f'{date_val=:%Y-%m-%d}') # date_val=2021-07-09\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython f-string 30-seconds-of-code": {
    "prefix": "hpython f-string 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[Formatted string literals](https://docs.python.org/3/reference/lexical_analysis.html?highlight=lexical%20analysis#formatted-string-literals), commonly known as f-strings, are strings prefixed with `'f`' or `'F'`. These strings can contain replacement fields, enclosed in curly braces (`{}`).\r",
      "\r",
      "```py\r",
      "name = 'John'\r",
      "age = 32\r",
      "\r",
      "print(f'{name} is {age} years old') # 'John is 32 years old'\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython str.format() 30-seconds-of-code": {
    "prefix": "hpython str.format() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The [`str.format()`](https://docs.python.org/3/library/stdtypes.html?highlight=str%20format#str.format) method works very much alike f-strings, the main difference being that replacement fields are supplied as arguments instead of as part of the string.\r",
      "\r",
      "```py\r",
      "name = 'John'\r",
      "age = 32\r",
      "\r",
      "print('{0} is {1} years old'.format(name, age)) # 'John is 32 years old'\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Lists 30-seconds-of-code": {
    "prefix": "hpython Lists 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Syntax: `[1, 2, 3]`\r",
      "- Contained elements are mutable (can be changed after creation)\r",
      "- Lists have a variable length\r",
      "- A list takes up more memory than a tuple\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Tuples 30-seconds-of-code": {
    "prefix": "hpython Tuples 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Syntax: `(1, 2, 3)`\r",
      "- Contained elements are immutable (cannot be changed after creation)\r",
      "- Tuples have a fixed length\r",
      "- A tuple takes up less memory than a list\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython When to use each one 30-seconds-of-code": {
    "prefix": "hpython When to use each one 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`list.sort()` should be used whenever mutating the list is intended and retrieving the original order of the elements is not desired. On the other hand, `sorted()` should be used when the object to be sorted is an iterable (e.g. list, tuple, dictionary, string) and the desired outcome is a sorted list containing all elements.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython str.lower() 30-seconds-of-code": {
    "prefix": "hpython str.lower() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Python's standard method for converting a string to lowercase is `str.lower()` and is compatible with both Python 2 and Python 3. While this is the standard way for most cases, there are certain cases where this method might not be the most appropriate, especially if you are working with Unicode strings.\r",
      "\r",
      "```py\r",
      "'Hello'.lower()               # 'hello'\r",
      "'Straße'.lower()              # 'straße'\r",
      "'Straße'.upper().lower()      # 'strasse'\r",
      "# Example of incorrect result when used for unicode case-insensitive matching\r",
      "'Straße'.upper().lower() == 'Straße'.lower() # False ('strasse' != 'straße')\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython str.casefold() 30-seconds-of-code": {
    "prefix": "hpython str.casefold() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Python 3 introduced `str.casefold()`, which is very similar to `str.lower()`, but more aggressive as it is intended to remove all case distinctions in Unicode strings. It implements the casefolding algorithm as described in [section 3.13 of the Unicode Standard](https://www.unicode.org/versions/Unicode9.0.0/ch03.pdf).\r",
      "\r",
      "```py\r",
      "'Hello'.casefold()            # 'hello'\r",
      "'Straße'.casefold()           # 'strasse'\r",
      "'Straße'.upper().casefold()   # 'strasse'\r",
      "# Returns the correct result when used for unicode case-insensitive matching\r",
      "'Straße'.upper().casefold() == 'Straße'.casefold() # True\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Python slice notation 30-seconds-of-code": {
    "prefix": "hpython Python slice notation 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Understanding Python's slice notation (this blog post)\r",
      "- [Understanding Python's slice assignment](/blog/s/python-slice-assignment)\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Basic syntax 30-seconds-of-code": {
    "prefix": "hpython Basic syntax 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Python's slice notation is used to return a list or a portion of a list. The basic syntax is as follows:\r",
      "\r",
      "```py\r",
      "[start_at:stop_before:step]\r",
      "```\r",
      "\r",
      "Where `start_at` is the index of the first item to be returned (included), `stop_before` is the index of the element before which to stop (not included) and `step` is the stride between any two items.\r",
      "\r",
      "All three of the arguments are optional, meaning you can omit any of them. For example:\r",
      "\r",
      "```py\r",
      "nums = [1, 2, 3, 4, 5]\r",
      "\r",
      "nums[1:4]     # [2, 3, 4]   (start at 0, stop before 4)\r",
      "nums[2:]      # [3, 4, 5]   (start at 0, stop at end of list)\r",
      "nums[:3]      # [1, 2, 3]   (start at 0, stop before 3)\r",
      "nums[1:4:2]   # [2, 4]      (start at 1, stop before 4, every 2nd element)\r",
      "nums[2::2]    # [3, 5]      (start at 2, stop at end of list, every 2nd element)\r",
      "nums[:3:2]    # [1, 3]      (start at 0, stop before 3, every 2nd element)\r",
      "nums[::2]     # [1, 3, 5]   (start at 0, stop at end of list, every 2nd element)\r",
      "nums[::]      # [1, 2, 3, 4, 5] (start at 0, stop at end of list)\r",
      "```\r",
      "\r",
      "As you can probably tell from the examples above, the default values are `start_at = 0`, `stop_before = len(nums)`, `step = 1`.\r",
      "\r",
      "> An idiomatic way to shallow clone a list would be using `[:]` (e.g. `nums_clone = nums[:]`).\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Changing length 30-seconds-of-code": {
    "prefix": "hpython Changing length 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The part of the list returned by the slice on the left-hand side of the expression is the part of the list that's going to be changed by slice assignment. This means that you can use slice assignment to replace part of the list with a different list whose length is also different from the returned slice. For example:\r",
      "\r",
      "```py\r",
      "nums = [1, 2, 3, 4, 5]\r",
      "\r",
      "nums[1:4] = [6, 7]    # [1, 6, 7, 5]        (replace 3 elements with 2)\r",
      "nums[-1:] = [8, 9, 0] # [1, 6, 7, 8, 9, 0]  (replace 1 element with 3)\r",
      "nums[:1] = []         # [6, 7, 8, 9, 0]     (replace 1 element with 0)\r",
      "```\r",
      "\r",
      "If you take empty slices into account, you can also insert elements into a list without replacing anything in it. For example:\r",
      "\r",
      "```py\r",
      "nums = [1, 2, 3, 4, 5]\r",
      "\r",
      "nums[2:2] = [6, 7]    # [1, 2, 6, 7, 3, 4, 5]   (insert 2 elements)\r",
      "nums[7:] = [8, 9]     # [1, 2, 6, 7, 3, 4, 5, 8, 9] (append 2 elements)\r",
      "nums[:0] = [0]        # [0, 1, 2, 6, 7, 3, 4, 5, 8, 9] (prepend 1 element)\r",
      "nums[:] = [ 4, 2]     # [4, 2]         (replace whole list with a new one)\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Using steps 30-seconds-of-code": {
    "prefix": "hpython Using steps 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Last but not least, `step` is also applicable in slice assignment and you can use it to replace elements that match the iteration after each stride. The only difference is that if `step` is not `1`, the inserted list must have the exact same length as that of the returned list slice. For example:\r",
      "\r",
      "```py\r",
      "nums = [1, 2, 3, 4, 5]\r",
      "\r",
      "nums[2:5:2] = [6, 7]  # [1, 2, 6, 4, 7] (replace every 2nd element, 2 through 5)\r",
      "nums[2:5:2] = [6, 7, 8] # Throws a ValueError (can't replace 2 elements with 3)\r",
      "nums[1::-1] = [9, 0]  # [0, 9, 6, 4, 7] (reverse replace, 1 through start)\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Negative values 30-seconds-of-code": {
    "prefix": "hpython Negative values 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "All three of the arguments also accept negative values. For `start_at` and `stop_before`, a negative value means counting from the end of the list instead of counting from the start. For example `-1` would represent the last element, `-2` the second last element etc. For example:\r",
      "\r",
      "```py\r",
      "nums = [1, 2, 3, 4, 5]\r",
      "\r",
      "nums[1:-2]    # [2, 3]      (start at 1, stop before 2nd to last)\r",
      "nums[-3:-1]   # [3, 4]      (start at 3rd to last, stop before last)\r",
      "```\r",
      "\r",
      "A negative `step` means that the list is sliced in reverse (from end to start). This also means that `start_at` should be greater than `stop_before` and that `stop_before` in the context of a reverse stride is more like `stop_after` if you are looking at the list non-reversed. For example:\r",
      "\r",
      "```py\r",
      "nums = [1, 2, 3, 4, 5]\r",
      "\r",
      "nums[::-1]    # [5, 4, 3, 2, 1]   (reversed)\r",
      "nums[4:1:-1]  # [5, 4, 3]   (reversed, start at 4, stop after 1)\r",
      "nums[-1:1:-2] # [5, 3]      (reversed, start at last, stop after 1, every 2nd)\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Empty slices 30-seconds-of-code": {
    "prefix": "hpython Empty slices 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Bear in mind that slice notation is very forgiving, so you'll get an empty list if the arguments' values are out of the list's range. For example:\r",
      "\r",
      "```py\r",
      "nums = [1, 2, 3, 4, 5]\r",
      "\r",
      "nums[6:8]     # []\r",
      "nums[:-10]    # []\r",
      "```\r",
      "\r",
      "[Continue on Understanding Python's slice assignment](/blog/s/python-slice-assignment)\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Differences and similarities 30-seconds-of-code": {
    "prefix": "hpython Differences and similarities 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The primary difference between the two is that `list.sort()` will sort the list in-place, mutating its indexes and returning `None`, whereas `sorted()` will return a new sorted list leaving the original list unchanged. Another difference is that `sorted()` accepts any iterable while `list.sort()` is a method of the `list` class and can only be used with lists.\r",
      "\r",
      "```py\r",
      "nums = [2, 3, 1, 5, 6, 4, 0]\r",
      "\r",
      "print(sorted(nums))   # [0, 1, 2, 3, 4, 5, 6]\r",
      "print(nums)           # [2, 3, 1, 5, 6, 4, 0]\r",
      "\r",
      "print(nums.sort())    # None\r",
      "print(nums)           # [0, 1, 2, 3, 4, 5, 6]\r",
      "```\r",
      "\r",
      "Both `list.sort()` and `sorted()` have the same `key` and `reverse` optional arguments and can be called on each list element prior to making comparisons.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Using a temporary variable 30-seconds-of-code": {
    "prefix": "hpython Using a temporary variable 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The simplest way to swap the values of two variables is using a `temp` variable. The `temp` variables is used to store the value of the fist variable (`temp = a`). This allows you to swap the value of the two variables (`a = b`) and then assign the value of `temp` to the second variable.\r",
      "\r",
      "```py\r",
      "a = 11\r",
      "b = 7\r",
      "\r",
      "temp = a\r",
      "a = b\r",
      "b = temp\r",
      "\r",
      "print(a) # 7\r",
      "print(b) # 11\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Without a temporary variable (Tuple swap) 30-seconds-of-code": {
    "prefix": "hpython Without a temporary variable (Tuple swap) 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Another way to swap the values of two variables, without using a temporary variable, is to use **tuple packing** and **sequence unpacking**. Tuples can be constructed in a number of ways, one of which is by separating tuple items using commas. Moreover, Python evaluates the right-hand side of an assignment before its left-hand side. So, by separating the variables with commas on the right side of the statement the variables are packed into a tuple and unpacked by placing the same number of comma-separated target variables on the left side.\r",
      "\r",
      "This method of variable swapping and permutation can be used for more than two variables as long as the same number of variables are on both sides of the statement.\r",
      "\r",
      "```py\r",
      "a = 11\r",
      "b = 7\r",
      "\r",
      "a, b = b, a\r",
      "\r",
      "print(a) # 7\r",
      "print(b) # 11\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Using arithmetic operators (for numbers only) 30-seconds-of-code": {
    "prefix": "hpython Using arithmetic operators (for numbers only) 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "If the two variables are numbers, their values can be swapped using arithmetic operators such as addition and subtraction (`+`, `-`) or multiplication and division (`*`, `/`). This swapping method is based on calculating the sum of the two numbers and then swapping them using the sum and the difference from the sum.\r",
      "\r",
      "```py\r",
      "a = 11\r",
      "b = 7\r",
      "\r",
      "a = a + b # a = 18, b = 7\r",
      "b = a - b # a = 18, b = 11\r",
      "a = a - b # a = 7,  b = 11\r",
      "\r",
      "print(a) # 7\r",
      "print(b) # 11\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Remove leading and trailing whitespace characters 30-seconds-of-code": {
    "prefix": "hpython Remove leading and trailing whitespace characters 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Use the `str.strip()` method to remove whitespace characters from both the beginning and end of a string.\r",
      "\r",
      "```py\r",
      "'  Hello  '.strip()    # 'Hello'\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Remove leading whitespace characters 30-seconds-of-code": {
    "prefix": "hpython Remove leading whitespace characters 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Leading whitespace characters are the whitespace characters at the start of a string. To remove them, use the `str.lstrip()` method.\r",
      "\r",
      "```py\r",
      "'  Hello  '.lstrip()   # 'Hello  '\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hpython Remove trailing whitespace characters 30-seconds-of-code": {
    "prefix": "hpython Remove trailing whitespace characters 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Trailing whitespace characters are the whitespace characters at the end of a string. To remove them, use the `str.rstrip()` method.\r",
      "\r",
      "```py\r",
      "'  Hello  '.rstrip()   # '  Hello'\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  }
}