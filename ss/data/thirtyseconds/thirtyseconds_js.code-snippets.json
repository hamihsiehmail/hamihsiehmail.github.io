{
  "hjs ESLint 30-seconds-of-code": {
    "prefix": "hjs ESLint 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) turns the popular JavaScript linter into an extension of VS Code. It automatically reads your linting configuration, identifies problems and even fixes them for you, if you want.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs  GitLens 30-seconds-of-code": {
    "prefix": "hjs  GitLens 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) is a very powerful collaboration tool for VS Code. It provides many useful tools for git such as blame, code authorship, activity heatmaps, recent changes, file history and even commit search.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Debugger for Chrome 30-seconds-of-code": {
    "prefix": "hjs Debugger for Chrome 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[Debugger for Chrome](https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome) allows you to debug your JavaScript code in Chrome or Chromium. Breakpoints, call stack inspection and stepping inside a function are only some of its features.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Bracket Pair Colorizer 2 30-seconds-of-code": {
    "prefix": "hjs Bracket Pair Colorizer 2 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[Bracket Pair Colorizer 2](https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2) makes reading code faster as it makes matching brackets the same color. This extension for VS Code improves upon its predecessor by providing improved performance.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Bookmarks 30-seconds-of-code": {
    "prefix": "hjs Bookmarks 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[Bookmarks](https://marketplace.visualstudio.com/items?itemName=alefragnani.Bookmarks) is one of those extensions that will significantly reduce your time jumping between different files, as it allows you to save important positions and navigate back to them easily and quickly.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs TODO Highlight 30-seconds-of-code": {
    "prefix": "hjs TODO Highlight 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[TODO Highlight](https://marketplace.visualstudio.com/items?itemName=wayou.vscode-todo-highlight) simplifies tracking leftover tasks by allowing you to list all of your TODO annotations, as well as adding a handy background highlight to them to make them pop out immediately.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Live Server 30-seconds-of-code": {
    "prefix": "hjs Live Server 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) gives you an easy way to serve web pages from VS Code, making previewing and debugging a lot easier. One of the core features is the live reload support that many developers are used to.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs REST Client 30-seconds-of-code": {
    "prefix": "hjs REST Client 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client) allows you to send HTTP requests and view the responses directly in VS Code. This extension supports a wide range of formats and authorization and should work with most setups.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs One Dark Pro 30-seconds-of-code": {
    "prefix": "hjs One Dark Pro 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[One Dark Pro](https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme) is one of the most popular VS Code themes and with very good reason. It provides a clean theme with a nice palette that has great contrast and is very comfortable to use on a daily basis.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Fira Code 30-seconds-of-code": {
    "prefix": "hjs Fira Code 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[Fira Code](https://github.com/tonsky/FiraCode) is not a traditional VS Code extension and might take a couple more steps to set up, but it's a superb programming font with ligatures that will help you scan code faster once you get used to it.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.map() 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.map() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Looking into one of the more unorthodox options, `Array.prototype.map()` can be used to map each element of an array to itself to create a new array.\r",
      "\r",
      "```js\r",
      "let x = [1, 2, 3, 4];\r",
      "let y = x.map(i => i);\r",
      "```\r",
      "\r",
      "#"
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.filter() 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.filter() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Another option for removing elements from an array is `Array.prototype.filter()`. More versatile than `Array.prototype.splice()`, it **doesn't mutate the original array**, but instead returns a new one. However, there's a performance consideration to be made for larger arrays when the elements to be removed are only encountered once. `Array.prototype.filter()` will always iterate over all elements in the array, which might be impractical in some cases.\r",
      "\r",
      "```js\r",
      "const arr = ['a', 'b', 'c'];\r",
      "const filtered = arr.filter(el => el !== 'b'); // ['a', 'c']\r",
      "\r",
      "console.log(arr); // ['a', 'b', 'c']\r",
      "```\r",
      "\r",
      "Most of the time, `Array.prototype.filter()` is the best option for removing elements from an array.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.reduce() 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.reduce() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[`Array.prototype.reduce()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) creates an output value of any type depending on a reducer function and an initial value. The result can be of any type such as an integer, an object or an array, based on the reducer function provided.\r",
      "\r",
      "```js\r",
      "const arr = [1, 2, 3];\r",
      "\r",
      "const sum = (x, y) => x + y;\r",
      "arr.reduce(sum, 0); // 6\r",
      "\r",
      "const increment = (x, y) => [...x, x[x.length - 1] + y];\r",
      "arr.reduce(increment, [0]); // [0, 1, 3, 6]\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.find() 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.find() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[`Array.prototype.find()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find) returns the first element for which a matcher function returns `true`. The result is a single element from the original array.\r",
      "\r",
      "```js\r",
      "const arr = [1, 2, 3];\r",
      "const isOdd = x => x % 2 === 1;\r",
      "arr.find(isOdd); // 1\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Capturing groups 30-seconds-of-code": {
    "prefix": "hjs Capturing groups 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Capturing groups allow you to get specific parts of the matched string, simply by wrapping part of the regular expression in parentheses `(...)`:\r",
      "\r",
      "```js\r",
      "const str = 'JavaScript is a programming language';\r",
      "/(JavaScript) is a (.*)/.exec(str);\r",
      "/*\r",
      "  [\r",
      "    0: 'JavaScript is a programming language',\r",
      "    1: 'JavaScript',\r",
      "    2: 'programming language'\r",
      "  ]\r",
      "*/\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Non-capturing groups 30-seconds-of-code": {
    "prefix": "hjs Non-capturing groups 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Non-capturing groups are used for matching something without capturing it, like an either/or matching group that you do not really need. They are defined similarly to capturing groups, but prefixed with `?:`:\r",
      "\r",
      "```js\r",
      "const str = 'JavaScript is a programming language';\r",
      "/(?:JavaScript|Python) is a (.+)/.exec(str);\r",
      "/*\r",
      "  [\r",
      "    0: 'JavaScript is a programming language',\r",
      "    1: 'programming language'\r",
      "  ]\r",
      "*/\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Named capturing groups 30-seconds-of-code": {
    "prefix": "hjs Named capturing groups 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Named capturing groups allow you to name a capturing group, by prefixing it with `<name>`:\r",
      "\r",
      "```js\r",
      "const str = 'JavaScript is a programming language';\r",
      "/(?<subject>.+) is a (?<description>.+)/.exec(str);\r",
      "/*\r",
      "  [\r",
      "    0: 'JavaScript is a programming language',\r",
      "    1: 'JavaScript',\r",
      "    2: 'programming language',\r",
      "    groups: {\r",
      "      subject: 'JavaScript,\r",
      "      description: 'programming language'\r",
      "    }\r",
      "  ]\r",
      "*/\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Capturing group backreferences 30-seconds-of-code": {
    "prefix": "hjs Capturing group backreferences 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Backreferences help you write shorter regular expressions, by repeating an existing capturing group, using `\\1`, `\\2` etc. Similarly, you can also repeat named capturing groups using `\\k<name>`:\r",
      "\r",
      "```js\r",
      "const str = 'JavaScript is a programming language - an awesome programming language JavaScript is';\r",
      "/(.+) is a (?<description>.+) - an awesome \\k<description> \\1 is/.exec(str);\r",
      "/*\r",
      "  [\r",
      "    0: 'JavaScript is a programming language - an awesome programming language JavaScript is',\r",
      "    1: 'JavaScript',\r",
      "    2: 'programming language',\r",
      "    groups: {\r",
      "      subject: 'JavaScript,\r",
      "      description: 'programming language'\r",
      "    }\r",
      "  ]\r",
      "*/\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Lookaheads 30-seconds-of-code": {
    "prefix": "hjs Lookaheads 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Lookaheads allow you to check if something is followed by a certain pattern, without actually matching it. You can create positive lookaheads using `?=` and negative lookaheads using `?!`:\r",
      "\r",
      "```js\r",
      "const str = 'JavaScript is not the same as Java and you should remember that';\r",
      "/Java(?=Script)(.*)/.exec(str);\r",
      "/*\r",
      "  [\r",
      "    0: 'JavaScript is not the same as Java and you should remember that',\r",
      "    1: 'Script is not the same as Java and you should remember that'\r",
      "  ]\r",
      "*/\r",
      "\r",
      "/Java(?!Script)(.*)/.exec(str);\r",
      "/*\r",
      "  [\r",
      "    0: 'Java and you should remember that',\r",
      "    1: ' and you should remember that'\r",
      "  ]\r",
      "*/\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Unicode characters 30-seconds-of-code": {
    "prefix": "hjs Unicode characters 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Finally, you can match unicode characters, using `/p{...}` and the `/u` flag. Examples include, but are not limited to `{Emoji}`, `{Math_Symbols}` and `{Script=Greek}`:\r",
      "\r",
      "```js\r",
      "const str = 'Greek looks like this: γεια';\r",
      "/\\p{Script=Greek}+/u.exec(str);\r",
      "/*\r",
      "  [\r",
      "    0: 'γεια'\r",
      "  ]\r",
      "*/\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Dot notation 30-seconds-of-code": {
    "prefix": "hjs Dot notation 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The most common and straightforward way to add a key-value pair to an object is to use the dot notation. You have probably already used this in the past, and it's sufficient in most situations you will encounter.\r",
      "\r",
      "```js\r",
      "const obj = { a: 1 };\r",
      "obj.b = 2;\r",
      "obj.c = 3;\r",
      "// obj = { a: 1, b: 2, c: 3 }\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Square bracket notation 30-seconds-of-code": {
    "prefix": "hjs Square bracket notation 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Similar to dot notation, square bracket notation comes in handy when dealing with **dynamic keys**, but can also work with static keys. Apart from that, it's exactly the same as dot notation both in functionality and performance.\r",
      "\r",
      "```js\r",
      "const obj = { a: 1 };\r",
      "const bKey = 'b';\r",
      "obj[bKey] = 2;\r",
      "obj['c'] = 3;\r",
      "// obj = { a: 1, b: 2, c: 3 }\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Object.assign() 30-seconds-of-code": {
    "prefix": "hjs Object.assign() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Finally, `Object.assign()` can be used in the exact same way as it's used to create a clone of an object, but for an array instead.\r",
      "\r",
      "```js\r",
      "let x = [1, 2, 3, 4];\r",
      "let y = Object.assign([], x);\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Object.defineProperty() 30-seconds-of-code": {
    "prefix": "hjs Object.defineProperty() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Another, less-common, way to add a key-value pair to an object is to use `Object.defineProperty()`. This is the lest performant way to add a key-value pair to an object, but it allows the new property to be **precisely defined**. This function accepts either a data or accessor descriptor as its second argument, allowing the behavior of the new property to be customized as desired. Bear in mind that you can add multiple properties at once, using `Object.defineProperties()`.\r",
      "\r",
      "```js\r",
      "const obj = { a: 1 };\r",
      "Object.defineProperty(obj, 'b', {\r",
      "  value: 2,\r",
      "  enumerable: true,\r",
      "  configurable: true,\r",
      "  writable: true\r",
      "});\r",
      "Object.defineProperty(obj, 'c', {\r",
      "  value: 3,\r",
      "  enumerable: true,\r",
      "  configurable: true,\r",
      "  writable: true\r",
      "});\r",
      "// obj = { a: 1, b: 2, c: 3 }\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Object spread operator 30-seconds-of-code": {
    "prefix": "hjs Object spread operator 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Last but not least, there's the object spread operator (`...`). Contrary to previous methods, this one **doesn't mutate the original object**, but instead returns a new object with the added properties. As expected, the performance of this approach is significantly worse than previous ones, due to the need to create a new object.\r",
      "\r",
      "```js\r",
      "const obj = { a: 1 };\r",
      "const newObj = { ...obj, b: 2, c: 3 };\r",
      "// obj = { a: 1 }\r",
      "// newObj = { a: 1, b: 2, c: 3 }\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.push() 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.push() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The classical way to append elements to the end of an array is to use `Array.prototype.push()`. While versatile, you need to remember that it **mutates the original array**. On the flip side, it supports adding multiple elements at once. Finally, the return value of `Array.prototype.push()` is the new length of the array.\r",
      "\r",
      "```js\r",
      "const arr = ['a', 'b', 'c'];\r",
      "arr.push('d', 'e'); // Returns 5 (new length after appending 2 elements)\r",
      "// arr = ['a', 'b', 'c', 'd', 'e']\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.unshift() 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.unshift() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Similar to `Array.prototype.push()`, `Array.prototype.unshift()` appends elements to the start of an array. Furthermore, this method also **mutates the original array** and supports adding multiple elements at once.\r",
      "\r",
      "```js\r",
      "const arr = ['a', 'b', 'c'];\r",
      "arr.unshift('d', 'e'); // Returns 5 (new length after appending 2 elements)\r",
      "// arr = ['d', 'e', 'a', 'b', 'c']\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.splice() 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.splice() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "This is probably the most common approach for removing elements from an array. While `Array.prototype.splice()` is a very versatile tool in your kit, you need to remember that it **mutates the original array**. On top of that, it returns the deleted elements instead of a new array.\r",
      "\r",
      "```js\r",
      "const arr = ['a', 'b', 'c'];\r",
      "const deleted = arr.splice(1, 1); // ['b']\r",
      "\r",
      "console.log(arr); // ['a', 'c']\r",
      "```\r",
      "\r",
      "If you're cool with mutating the array, `Array.prototype.splice()` might just be the solution you need.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.length 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.length 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Appending an element to the end of an array means setting a value for an index equal to its length. This is due to arrays in JavaScript being zero-indexed. Luckily, `Array.prototype.length` can be combined with array index notation to accomplish this. Same as previous methods, this approach **mutates the original array**. Additionally, it's limited to adding one element at a time and only at the end of the array.\r",
      "\r",
      "```js\r",
      "const arr = ['a', 'b', 'c'];\r",
      "arr[arr.length] = 'd';\r",
      "// arr = ['a', 'b', 'c', 'd']\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.concat() 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.concat() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[`Array.prototype.concat()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) is a method on the `Array` prototype and can be used to create a new array, either by concatenating both arrays to a new array or one array to the other. Both methods result in a new array, without mutating the original:\r",
      "\r",
      "```js\r",
      "const a = [1, 2, 3];\r",
      "const b = [4, 5, 6];\r",
      "\r",
      "const merged = [].concat(a, b); // [1, 2, 3, 4, 5, 6]\r",
      "// -- OR --\r",
      "const alsoMerged = a.concat(b); // [1, 2, 3, 4, 5, 6]\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Spread operator 30-seconds-of-code": {
    "prefix": "hjs Spread operator 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The [spread operator (`...`)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) was introduced in ES6 and can be used to merge two or more arrays, by spreading each one inside a new array:\r",
      "\r",
      "```js\r",
      "const a = [1, 2, 3];\r",
      "const b = [4, 5, 6];\r",
      "\r",
      "const merged = [...a, ...b]; // [1, 2, 3, 4, 5, 6]\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Equality comparison 30-seconds-of-code": {
    "prefix": "hjs Equality comparison 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Even though two different objects can have the same properties with equal values, they are not considered equal when compared using either the loose or strict equality operators (`==` or `===`). This is because arrays and objects in JavaScript are compared by reference. This is unlike primitive values which are compared by value.\r",
      "\r",
      "```js\r",
      "const a = { name: 'John', age: 26 };\r",
      "const b = { name: 'John', age: 26 };\r",
      "\r",
      "a === b; // false\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs JSON.stringify 30-seconds-of-code": {
    "prefix": "hjs JSON.stringify 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`JSON.stringify()` often comes up as the solution to this problem. While it can be useful in some situations, comparing the serialized strings can have its own pitfalls. The most common of these has to do with similar, but not equal, values that result in the same serialized string.\r",
      "\r",
      "```js\r",
      "const equals = (a, b) => JSON.stringify(a) === JSON.stringify(b);\r",
      "\r",
      "const a = { name: 'John', age: 26 };\r",
      "const b = { name: 'John', age: 26 };\r",
      "\r",
      "equals(a, b); // true\r",
      "\r",
      "const c = { name: 'John' };\r",
      "const d = { name: 'John', age: undefined };\r",
      "\r",
      "equals(c, d); // true, should be false\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs A better way 30-seconds-of-code": {
    "prefix": "hjs A better way 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A better approach would be to compare the two arrays' `length`s and use `Array.prototype.every()` to compare the values of the two:\r",
      "\r",
      "```js\r",
      "const equals = (a, b) =>\r",
      "  a.length === b.length &&\r",
      "  a.every((v, i) => v === b[i]);\r",
      "\r",
      "const a = [1, 2, 3];\r",
      "const b = [1, 2, 3];\r",
      "const str = 'a';\r",
      "const strObj = new String('a');\r",
      "\r",
      "equals(a, b); // true\r",
      "equals([str], [strObj]); // false\r",
      "equals([null], [undefined]); // false\r",
      "```\r",
      "\r",
      "This approach safeguards against the serialization issue described above. However it does not take into account nested arrays or objects, which need to be checked recursively. For a robust solution that handles this and other issues, you should use the [equals snippet](/js/s/equals).\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Comparing out of order 30-seconds-of-code": {
    "prefix": "hjs Comparing out of order 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Finally, there are cases where the order of the elements in each array is not important and we only care about the same values existing in both arrays. For these cases, you can use `Set` and `Array.prototype.filter()` in combination with a loop to iterate over unique values and check if each one appears the same amount of times in each array:\r",
      "\r",
      "```js\r",
      "const equalsIgnoreOrder = (a, b) => {\r",
      "  if (a.length !== b.length) return false;\r",
      "  const uniqueValues = new Set([...a, ...b]);\r",
      "  for (const v of uniqueValues) {\r",
      "    const aCount = a.filter(e => e === v).length;\r",
      "    const bCount = b.filter(e => e === v).length;\r",
      "    if (aCount !== bCount) return false;\r",
      "  }\r",
      "  return true;\r",
      "}\r",
      "```\r",
      "\r",
      "For a more detailed explanation, you should check out the [haveSameContents snippet](/js/s/have-same-contents).\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Find a single value 30-seconds-of-code": {
    "prefix": "hjs Find a single value 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "If you are looking for a single result in an array, you can use `Array.prototype.find()` instead. This will return the first element that satisfies the condition, or `undefined` if no such element exists. It's much faster than `Array.prototype.filter()`, as it will stop iterating as soon as it finds the first matching element.\r",
      "\r",
      "```js\r",
      "const arr = [1, 2, 3, 4, 5];\r",
      "\r",
      "arr.find(x => x > 3); // 4\r",
      "```\r",
      "\r",
      "Additionally, if the condition is a simple equality check, you can also use `Array.prototype.indexOf()`. While not as pretty as the other two, it can be significantly faster, as there's no overhead from using a comparator function.\r",
      "\r",
      "```js\r",
      "const arr = [1, 2, 3, 4, 5];\r",
      "\r",
      "arr.indexOf(3); // 2\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Remove a single value 30-seconds-of-code": {
    "prefix": "hjs Remove a single value 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Similarly, if you want to remove a single value from an array, you can use `Array.prototype.findIndex()` to find the index of the element you want to remove. Then, use `Array.prototype.slice()` to remove it. While this is a little more verbose and seems to perform more operations, it can actually be faster than using `Array.prototype.filter()` in many cases.\r",
      "\r",
      "```js\r",
      "const arr = [1, 2, 3, 4, 5];\r",
      "\r",
      "const index = arr.findIndex(x => x === 3);\r",
      "const newArr = [...arr.slice(0, index), ...arr.slice(index + 1)];\r",
      "// [1, 2, 4, 5]\r",
      "```\r",
      "\r",
      "Similarly, if you don't mind mutating the original array, you can use `Array.prototype.splice()` to remove the element at the index you found. As this method doesn't have to create a new array, it can be significantly faster than the previous one.\r",
      "\r",
      "```js\r",
      "const arr = [1, 2, 3, 4, 5];\r",
      "\r",
      "const index = arr.findIndex(x => x === 3);\r",
      "arr.splice(index, 1); // [1, 2, 4, 5]\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Additional notes 30-seconds-of-code": {
    "prefix": "hjs Additional notes 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "In many cases, such changes will not make a drastic difference in your application's performance. It never hurts, however, to be aware of all the options and use the best one for your specific use case. Changes such as these will make more sense when working with large datasets, as well as critical parts of your application.\r",
      "\r",
      "Additionally, depending on the data and its constraints, it might make more sense to use a different data structure altogether. For example, if unique values are a precondition, using a `Set` is more efficient and much easier to work with in many cases.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Primitive values 30-seconds-of-code": {
    "prefix": "hjs Primitive values 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "You can use `Array.prototype.includes()` to check if an array contains a primitive value. This is the most convenient option when working with strings, numbers, booleans, symbols, `null` or `undefined`. You can even specify an index as a secondary parameter to start searching from.\r",
      "\r",
      "```js\r",
      "const array = [1, 2, 3, 4, 5];\r",
      "\r",
      "array.includes(3); // true\r",
      "array.includes(6); // false\r",
      "array.includes(3, 3); // false\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Objects 30-seconds-of-code": {
    "prefix": "hjs Objects 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Unlike primitive values, you can't use `Array.prototype.includes()` to check if an array includes an object. This comes down to how JavaScript compares values and the fact that [objects are reference types](/js/s/pass-by-reference-or-pass-by-value). I highly recommend reading the previous article about [object comparison](/js/s/object-comparison), as I won't be going into detail on how to compare objects here.\r",
      "\r",
      "Due to this difference between primitive values and objects, you can't use `Array.prototype.includes()` to check if an array includes an object. However, provided you implement a [deep equality function](/js/s/equals), you can use `Array.prototype.some()` to check if any object matches the shape of another object.\r",
      "\r",
      "```js\r",
      "const array = [{ a: 1 }, { a: 2 }, { a: 3 }];\r",
      "\r",
      "const equals = (a, b) => Object.keys(a).every(key => a[key] === b[key]);\r",
      "\r",
      "array.some(item => equals(item, { a: 2 })); // true\r",
      "array.some(item => equals(item, { a: 4 })); // false\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array() constructor 30-seconds-of-code": {
    "prefix": "hjs Array() constructor 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The first thing you'd reach for would probably be the `Array()` constructor. Counterintuitively, this is probably the most problematic option to use on its own. While it works for any number of arguments to create an array with the given values, it falls short pretty much everywhere else. Most of its problems stem from **holes or \"empty\" values** with which the resulting array is populated and how these are handled elsewhere.\r",
      "\r",
      "```js\r",
      "const arr = Array(3); // [ , , ] - 3 empty slots\r",
      "arr.map(() => 1); // [ , , ] - map() skips empty slots\r",
      "arr.map((_, i) => i); // [ , , ] - map() skips empty slots\r",
      "arr[0]; // undefined - actually, it is an empty slot\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.from() 30-seconds-of-code": {
    "prefix": "hjs Array.from() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`Array.from()` has a very powerful API that can be used for many different things, including creating a copy of an array.\r",
      "\r",
      "```js\r",
      "let x = [1, 2, 3, 4];\r",
      "let y = Array.from(x);\r",
      "```\r",
      "\r",
      "#"
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.fill() 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.fill() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "While `Array.from()` is quite flexible, using a mapping function to fill it with the same value isn't particularly efficient. `Array.prototype.fill()` comes to fill this gap by allowing you to **fill an existing array** with the same value. This can also come in handy in conjunction with the `Array()` constructor, as it allows you to fill the array with a value, instead of empty slots.\r",
      "\r",
      "```js\r",
      "const nullArr = new Array(3).fill(null); // [null, null, null]\r",
      "const staticArr = Array.from({ length: 3 }).fill(1); // [1, 1, 1]\r",
      "const indexArr = Array(3).fill(null).map((_, i) => i); // [0, 1, 2]\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs A note on performance 30-seconds-of-code": {
    "prefix": "hjs A note on performance 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Performance might be a concern if this sort of operation is very common in your application, but overall none of these options are particularly slow. The `Array()` constructor seems to be the fastest. That being said, if combined with `Array.prototype.fill()`, it can be the best option for initializing an array with a single value. Oddly enough, this performance advantage still holds even if you chain an `Array.prototype.map()` call afterwards to create dynamic values. Therefore, my personal recommendations are as follows:\r",
      "\r",
      "```js\r",
      "const initializeArrayWithValues = (n, val = 0) => Array(n).fill(val);\r",
      "const initializeMappedArray = (n, mapFn = (_, i) => i) =>\r",
      "  Array(n).fill(null).map(mapFn);\r",
      "```\r",
      "\r",
      "```js\r",
      "initializeArrayWithValues(4, 2); // [2, 2, 2, 2]\r",
      "initializeMappedArray(4, (_, i) => i * 2); // [0, 2, 4, 6]\r",
      "```\r",
      "\r",
      "You can learn more tips and tricks related to JavaScript array initialization in [this collection](//js/array-initialization/p/1).\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Arrow functions 30-seconds-of-code": {
    "prefix": "hjs Arrow functions 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "JavaScript ES6 introduced the concept of arrow functions, a new way to define and write functions. While they might seem like a syntactic sugar on top of regular functions, they have a key difference which lies in the way the `this` context is bound. I strongly suggest you read [Understanding the \"this\" keyword in JavaScript](/blog/s/javascript-this), as I will not go into detail about the topic in this article. To summarize:\r",
      "\r",
      "> Arrow functions do not have their own bindings for `this`, resulting in `this` retaining the value of the enclosing lexical context's `this`.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Event listener callbacks 30-seconds-of-code": {
    "prefix": "hjs Event listener callbacks 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A common task when writing browser-side JavaScript is creating event listeners. For example:\r",
      "\r",
      "```js\r",
      "const toggleElements = document.querySelectorAll('.toggle');\r",
      "toggleElements.forEach(el => {\r",
      "  el.addEventListener('click', function() {\r",
      "    this.classList.toggle('active');\r",
      "  });\r",
      "});\r",
      "```\r",
      "\r",
      "In the example above, we use `NodeList.prototype.forEach()` to iterate over matching nodes and `EventTarget.addEventListener()` with a regular function as the callback for the `'click'` event to swap between an active and inactive state for the clicked element. We are using a regular function, so the `this` context inside the callback will be bound to the event target.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Arrow functions as callbacks 30-seconds-of-code": {
    "prefix": "hjs Arrow functions as callbacks 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "As we have already explained, arrow functions do not have their own bindings for `this`. So what happens if we convert the previous code snippet's callback to an arrow function? Its `this` context refers to the global one, which in this case is the `Window` object.\r",
      "\r",
      "```js\r",
      "const toggleElements = document.querySelectorAll('.toggle');\r",
      "toggleElements.forEach(el => {\r",
      "  el.addEventListener('click', () => {\r",
      "    this.classList.toggle('active'); // `this` refers to `Window`\r",
      "    // Error: Cannot read property 'toggle' of undefined\r",
      "  });\r",
      "});\r",
      "```\r",
      "\r",
      "This code will fire the event listener and execute the callback anytime the matching element is clicked. It will, however, throw an error, due to the `Window` object not having a `classList` property. Oftentimes, the code could even fail silently. An example would be a condition that always evaluates to `false` for `Window`, but could evaluate to `true` for a given element. Issues like that result in many headaches and wasted hours until you can uncover and fix them.\r",
      "\r",
      "To deal with this, one could simply use the first argument of the callback function and `Event.target` or `Event.currentTarget` depending on their needs:\r",
      "\r",
      "```js\r",
      "const toggleElements = document.querySelectorAll('.toggle');\r",
      "toggleElements.forEach(el => {\r",
      "  el.addEventListener('click', (e) => {\r",
      "    e.currentTarget.classList.toggle('active'); // works correctly\r",
      "  });\r",
      "});\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Syntax 30-seconds-of-code": {
    "prefix": "hjs Syntax 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The first and most obvious difference between arrow functions and regular functions is their syntax. Not only do they look different, but arrow functions also provide an implicit return shorthand and allow parenthesis around a single argument to be omitted.\r",
      "\r",
      "```js\r",
      "const square = a => a * a;\r",
      "\r",
      "// Equivalent regular function\r",
      "function square(a) {\r",
      "  return a * a;\r",
      "}\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Execution context 30-seconds-of-code": {
    "prefix": "hjs Execution context 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Inside a regular function, execution context (i.e. the value of `this`) is dynamic. This means that the value of `this` depends on how the function was invoked (simple invocation, method invocation, indirect invocation or constructor invocation). On the other hand, an arrow function does not define its own execution context. This results in an arrow function's `this` being resolved lexically (i.e. the scope in which the arrow function was defined).\r",
      "\r",
      "```js\r",
      "function logThis() {\r",
      "  console.log(this);\r",
      "}\r",
      "document.addEventListener('click', logThis);\r",
      "// `this` refers to the document\r",
      "\r",
      "const logThisArrow = () => {\r",
      "  console.log(this);\r",
      "};\r",
      "document.addEventListener('click', logThisArrow);\r",
      "// `this` refers to the global object\r",
      "```\r",
      "\r",
      "`Function.prototype.call()`, `Function.prototype.bind()` and `Function.prototype.apply()` do not work correctly with arrow functions either. Their purpose is to allow methods to execute within different scopes, but the `this` value of an arrow function cannot be changed, as it's resolved lexically.\r",
      "\r",
      "```js\r",
      "function logThis() {\r",
      "  console.log(this);\r",
      "}\r",
      "logThis.call(42);       // Logs: 42\r",
      "\r",
      "const logThisArrow = () => {\r",
      "  console.log(this);\r",
      "};\r",
      "logThisArrow.call(42);  // Logs the global object\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Methods 30-seconds-of-code": {
    "prefix": "hjs Methods 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Due to arrow functions not defining their own execution context, they're not well-suited for usage as methods. However, thanks to the [Class fields proposal](https://github.com/tc39/proposal-class-fields), arrow functions can be used as methods inside classes, if your environment supports it.\r",
      "\r",
      "```js\r",
      "const obj = {\r",
      "  x: 42,\r",
      "  logThisX: function() {\r",
      "    console.log(this.x, this);\r",
      "  },\r",
      "  logThisXArrow: () => {\r",
      "    console.log(this.x, this);\r",
      "  }\r",
      "};\r",
      "\r",
      "obj.logThisX();       // Logs: 42, Object {...}\r",
      "obj.logThisXArrow();  // Logs: undefined, the global object\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Constructors 30-seconds-of-code": {
    "prefix": "hjs Constructors 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Regular functions can be used as constructors, using the `new` keyword. Yet another consequence of the lexical resolution of `this` inside arrow functions is that they cannot be used as constructors. Using `new` with an arrow function results in a `TypeError`.\r",
      "\r",
      "```js\r",
      "function Foo(bar) {\r",
      "  this.bar = bar;\r",
      "}\r",
      "const a = new Foo(42);  // Foo {bar: 42}\r",
      "\r",
      "const Bar = foo => {\r",
      "  this.foo = foo;\r",
      "};\r",
      "const b = new Bar(42);  // TypeError: Bar is not a constructor\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Arguments 30-seconds-of-code": {
    "prefix": "hjs Arguments 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Another difference is the binding of the `arguments` object. Unlike regular functions, arrow functions don't have their own `arguments` object. A modern alternative that circumvents this limitation is the usage of rest parameters.\r",
      "\r",
      "```js\r",
      "function sum() {\r",
      "  return arguments[0] + arguments[1];\r",
      "};\r",
      "sum(4, 6);        // 10\r",
      "\r",
      "const arguments = [1, 2, 3];\r",
      "const sumArrow = () => {\r",
      "  return arguments[0] + arguments[1];\r",
      "};\r",
      "sumArrow(4, 6);   // 3 (resolves to 1 + 2)\r",
      "\r",
      "const sumRest = (...arguments) => {\r",
      "  return arguments[0] + arguments[1];\r",
      "}\r",
      "sumRest(4, 6);    // 10\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Other differences 30-seconds-of-code": {
    "prefix": "hjs Other differences 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Apart from the two main differences mentioned already, there are some other, less noticeable, ones. These include the following:\r",
      "\r",
      "- Object size requires manual computation. Maps, on the other hand, have a built-in `size` property that can be used to track the number of key-value pairs.\r",
      "- You can check for a given key's presence in an object using the `in` operator or `Object.prototype.hasOwnProperty()`. `Map.prototype.has()` accomplishes the same thing for Maps.\r",
      "- Clearing an object requires manual operation and might be non-trivial in some cases. Maps solve this problem via the use of `Map.prototype.clear()`.\r",
      "- Objects inherit some keys from the prototype, whereas maps do not.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs For loops 30-seconds-of-code": {
    "prefix": "hjs For loops 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "const files = [ 'foo.txt ', '.bar', '   ', 'baz.foo' ];\r",
      "let filePaths = [];\r",
      "\r",
      "for (let file of files) {\r",
      "  const fileName = file.trim();\r",
      "  if(fileName) {\r",
      "    const filePath = `~/cool_app/${fileName}`;\r",
      "    filePaths.push(filePath);\r",
      "  }\r",
      "}\r",
      "\r",
      "// filePaths = [ '~/cool_app/foo.txt', '~/cool_app/.bar', '~/cool_app/baz.foo']\r",
      "```\r",
      "\r",
      "- Any `for` loop can be used - [read more about the different JavaScript loops](/blog/s/javascript-for-in-for-of-foreach/).\r",
      "- Less common nowadays, due to functional programming being more popular.\r",
      "- Control over the iteration, such as skipping over elements or early `return`s.\r",
      "- Resulting array needs to be declared beforehand, outside the loop.\r",
      "- Uses `Array.prototype.push()` or the spread (`...`) operator to add elements.\r",
      "- `O(N)` complexity, each element will be iterated over only once.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Promises 30-seconds-of-code": {
    "prefix": "hjs Promises 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`Promise.all()` provides another option for asynchronous loops over arrays. The main difference with the previous one is that `Promise.all()` executes all asynchronous operations in parallel. This means that promises will execute out of order, which might be an issue in some cases. Most often than not, this is my preferred solution as it's quite uncommon to want promises to execute sequentially.\r",
      "\r",
      "```js\r",
      "const asyncUppercase = item =>\r",
      "  new Promise(resolve =>\r",
      "    setTimeout(\r",
      "      () => resolve(item.toUpperCase()),\r",
      "      Math.floor(Math.random() * 1000)\r",
      "    )\r",
      "  );\r",
      "\r",
      "const uppercaseItems = () => {\r",
      "  const items = ['a', 'b', 'c'];\r",
      "  return Promise.all(\r",
      "    items.map(async item => {\r",
      "      const uppercaseItem = await asyncUppercase(item);\r",
      "      console.log(uppercaseItem);\r",
      "    })\r",
      "  ).then(() => {\r",
      "    console.log('Items processed');\r",
      "  });\r",
      "};\r",
      "// LOGS: 'A', 'C', 'B', 'Items processed'\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array methods 30-seconds-of-code": {
    "prefix": "hjs Array methods 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Unfortunately, array methods such as `Array.prototype.forEach()` do not work well with `async`/`await`. The only viable solution is to use `Promise.all()` as shown in the previous example. Using an `async` callback with `Array.prototype.forEach()` will result in the rest of the code executing and the asynchronous operations not being awaited for.\r",
      "\r",
      "```js\r",
      "const asyncUppercase = item =>\r",
      "  new Promise(resolve =>\r",
      "    setTimeout(\r",
      "      () => resolve(item.toUpperCase()),\r",
      "      Math.floor(Math.random() * 1000)\r",
      "    )\r",
      "  );\r",
      "\r",
      "const uppercaseItems = async () => {\r",
      "  const items = ['a', 'b', 'c'];\r",
      "  await items.forEach(async item => {\r",
      "    const uppercaseItem = await asyncUppercase(item);\r",
      "    console.log(uppercaseItem);\r",
      "  });\r",
      "\r",
      "  console.log('Items processed');\r",
      "};\r",
      "\r",
      "uppercaseItems();\r",
      "// LOGS: ''Items processed', 'B', 'A', 'C'\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Promise basics 30-seconds-of-code": {
    "prefix": "hjs Promise basics 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- **Promises** start in a **pending state**, neither fulfilled or rejected.\r",
      "- When the operation is completed, a promise will become **fulfilled with a value**.\r",
      "- If the operation fails, a promise will get **rejected with an error**.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Creating promises 30-seconds-of-code": {
    "prefix": "hjs Creating promises 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The function passed to the `Promise` constructor will execute synchronously.\r",
      "- Use `resolve()` or `reject()` to create promises from values.\r",
      "- `Promise.resolve(val)` will fulfill the promise with `val`.\r",
      "- `Promise.reject(err)` will reject the promise with `err`.\r",
      "- If you put a fulfilled promise into a fulfilled promise, they will collapse into one.\r",
      "\r",
      "```js\r",
      "// Resolving with a value, rejecting with an error\r",
      "new Promise((resolve, reject) => {\r",
      "  performOperation((err, val) => {\r",
      "    if (err) reject(err);\r",
      "    else resolve(val);\r",
      "  });\r",
      "});\r",
      "\r",
      "// Resolving without value, no need for reject\r",
      "const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Handling promises 30-seconds-of-code": {
    "prefix": "hjs Handling promises 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- `Promise.prototype.then()` accepts two optional arguments (`onFulfilled`, `onRejected`).\r",
      "- `Promise.prototype.then()` will call `onFulfilled` once the promise is fulfilled.\r",
      "- `Promise.prototype.then()` will call `onRejected` if the promise is rejected.\r",
      "- `Promise.prototype.then()` passes errors through if `onRejected` in undefined.\r",
      "\r",
      "- `Promise.prototype.catch()` accepts one argument (`onRejected`).\r",
      "- `Promise.prototype.catch()` behaves like `Promise.prototype.then()` when `onFulfilled` is omitted.\r",
      "- `Promise.prototype.catch()` passes fulfilled values through.\r",
      "\r",
      "- `Promise.prototype.finally()` accepts one argument (`onFinally`).\r",
      "- `Promise.prototype.finally()` calls `onFinally` with no arguments once any outcome is available.\r",
      "- `Promise.prototype.finally()` passes through input promise.\r",
      "\r",
      "```js\r",
      "promisedOperation()\r",
      "  .then(\r",
      "    val => value + 1,   // Called once the promise is fulfilled\r",
      "    err => {            // Called if the promise is rejected\r",
      "      if (err === someKnownErr) return defaultVal;\r",
      "      else throw err;\r",
      "    }\r",
      "  )\r",
      "  .catch(\r",
      "    err => console.log(err); // Called if the promise is rejected\r",
      "  )\r",
      "  .finally(\r",
      "    () => console.log('Done'); // Called once any outcome is available\r",
      "  );\r",
      "```\r",
      "\r",
      "- All three of the above methods will not be executed at least until the next tick, even for promises that already have an outcome.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Combining promises 30-seconds-of-code": {
    "prefix": "hjs Combining promises 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- `Promise.all()` turns an array of promises into a promise of an array.\r",
      "- If any promise is rejected, the error will pass through.\r",
      "- `Promise.race()` passes through the first settled promise.\r",
      "\r",
      "```js\r",
      "Promise\r",
      "  .all([ p1, p2, p3 ])\r",
      "  .then(([ v1, v2, v3 ]) => {\r",
      "    // Values always correspond to the order of promises,\r",
      "    // not the order they resolved in (i.e. v1 corresponds to p1)\r",
      "  });\r",
      "\r",
      "Promise\r",
      "  .race([ p1, p2, p3 ])\r",
      "  .then(val => {\r",
      "    // val will take the value of the first resolved promise\r",
      "  });\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs async/await 30-seconds-of-code": {
    "prefix": "hjs async/await 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Calling an `async` function always results in a promise.\r",
      "- `(async () => value)()` will resolve to `value`.\r",
      "- `(async () => throw err)()` will reject with an error.\r",
      "- `await` waits for a promise to be fulfilled and returns its value.\r",
      "- `await` can only be used in `async` functions.\r",
      "- `await` also accepts non-promise values.\r",
      "- `await` always waits at least until the next tick before resolving, even when waiting already fulfilled promises or non-promise values.\r",
      "\r",
      "```js\r",
      "async () => {\r",
      "  try {\r",
      "    let val = await promisedValue();\r",
      "    // Do stuff here\r",
      "  } catch (err) {\r",
      "    // Handle error\r",
      "  }\r",
      "}\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Definition 30-seconds-of-code": {
    "prefix": "hjs Definition 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A tree is a data structure consisting of a set of linked nodes that represent a hierarchical tree structure. Each node is linked to others via parent-children relationship. The first node in the tree is the root, whereas nodes without any children are the leaves.\r",
      "\r",
      "![JavaScript Tree visualization](./illustrations/ds-tree.png)\r",
      "\r",
      "Each node in a tree data structure must have the following properties:\r",
      "\r",
      "- `key`: The key of the node\r",
      "- `value`: The value of the node\r",
      "- `parent`: The parent of the node (`null` if there is none)\r",
      "- `children`: An array of pointers to the node's children\r",
      "\r",
      "The main operations of a tree data structure are:\r",
      "\r",
      "- `insert`: Inserts a node as a child of the given parent node\r",
      "- `remove`: Removes a node and its children from the tree\r",
      "- `find`: Retrieves a given node\r",
      "- `preOrderTraversal`: Traverses the tree by recursively traversing each node followed by its children\r",
      "- `postOrderTraversal`: Traverses the tree by recursively traversing each node's children followed by the node\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Common Data Structure operations 30-seconds-of-code": {
    "prefix": "hjs Common Data Structure operations 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Different data structures have different time complexities for the same operations. For example, a linked list has `O(1)` time complexity for `insert` and `delete` operations, while an array has `O(n)` time complexity for the same operations. Below you can find average and worst time complexities for data structures used commonly in web development.\r",
      "\r",
      "#"
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Average time complexity 30-seconds-of-code": {
    "prefix": "hjs Average time complexity 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "| Data Structure | Access | Search | Insertion | Deletion |\r",
      "| --- | --- | --- | --- | --- |\r",
      "| [**Array**](/js/s/native-data-structures) | Θ(1) | Θ(n) | Θ(n) | Θ(n) |\r",
      "| [**Queue**](/js/s/data-structures-queue) | Θ(n) | Θ(n) | Θ(1) | Θ(1) |\r",
      "| [**Stack**](/js/s/data-structures-stack) | Θ(n) | Θ(n) | Θ(1) | Θ(1) |\r",
      "| [**Linked List**](/js/s/data-structures-linked-list) | Θ(n) | Θ(n) | Θ(1) | Θ(1) |\r",
      "| [**Doubly Linked List**](/js/s/data-structures-doubly-linked-list) | Θ(n) | Θ(n) | Θ(1) | Θ(1) |\r",
      "| **Skip List** | Θ(log n) | Θ(log n) | Θ(log n) | Θ(log n) |\r",
      "| **Hash Table** | N/A | Θ(1) | Θ(1) | Θ(1) |\r",
      "| [**Binary Search Tree**](/js/s/data-structures-binary-search-tree) | Θ(log n) | Θ(log n) | Θ(log n) | Θ(log n) |\r",
      "\r",
      "#"
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Worst time complexity 30-seconds-of-code": {
    "prefix": "hjs Worst time complexity 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "| Data Structure | Access | Search | Insertion | Deletion |\r",
      "| --- | --- | --- | --- | --- |\r",
      "| [**Array**](/js/s/native-data-structures) | O(1) | O(n) | O(n) | O(n) |\r",
      "| [**Queue**](/js/s/data-structures-queue) | O(n) | O(n) | O(1) | O(1) |\r",
      "| [**Stack**](/js/s/data-structures-stack) | O(n) | O(n) | O(1) | O(1) |\r",
      "| [**Linked List**](/js/s/data-structures-linked-list) | O(n) | O(n) | O(1) | O(1) |\r",
      "| [**Doubly Linked List**](/js/s/data-structures-doubly-linked-list) | O(n) | O(n) | O(1) | O(1) |\r",
      "| **Skip List** | O(n) | O(n) | O(n) | O(n) |\r",
      "| **Hash Table** | N/A | O(n) | O(n) | O(n) |\r",
      "| [**Binary Search Tree**](/js/s/data-structures-binary-search-tree) | O(n) | O(n) | O(n) | O(n) |\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array sorting algorithms 30-seconds-of-code": {
    "prefix": "hjs Array sorting algorithms 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Similar to data structures, different array sorting algorithms have different time complexities. Below you can find the best, average and worst time complexities for the most common array sorting algorithms.\r",
      "\r",
      "| Algorithm | Best | Average | Worst |\r",
      "| --- | --- | --- | --- |\r",
      "| [**Quick sort**](/js/s/quick-sort) | Ω(n log n) | Θ(n log n) | O(n^2) |\r",
      "| [**Merge sort**](/js/s/merge-sort) | Ω(n log n) | Θ(n log n) | O(n log n) |\r",
      "| [**Heap sort**](/js/s/heapsort) | Ω(n log n) | Θ(n log n) | O(n log n) |\r",
      "| [**Bubble sort**](/js/s/bubble-sort) | Ω(n) | Θ(n^2) | O(n^2) |\r",
      "| [**Insertion sort**](/js/s/insertion-sort) | Ω(n) | Θ(n^2) | O(n^2) |\r",
      "| [**Selection sort**](/js/s/selection-sort) | Ω(n^2) | Θ(n^2) | O(n^2) |\r",
      "| [**Bucket sort**](/js/s/bucket-sort) | Ω(n+k) | Θ(n+k) | O(n^2) |\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Using Boolean for truth-checking 30-seconds-of-code": {
    "prefix": "hjs Using Boolean for truth-checking 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The `Boolean()` function is particularly useful when truth-checking data and probably significantly more readable than the double negation (`!!`) operation:\r",
      "\r",
      "```js\r",
      "let x = 'some-value';\r",
      "\r",
      "// This doesn't look too nice\r",
      "if (!!x) {\r",
      "  // ...\r",
      "}\r",
      "\r",
      "// This is a lot more readable\r",
      "if (Boolean(x)) {\r",
      "  // ...\r",
      "}\r",
      "```\r",
      "\r",
      "As you can see in the example above, it serves the exact same purpose and is pretty straightforward to use. Similarly, as `Boolean()` is itself a function returning a boolean value, you can use it for truth-checking collections, filtering arrays etc.:\r",
      "\r",
      "```js\r",
      "const values = [0, 0, 2, 0, 3];\r",
      "// Use as the callback for Array.prototype.some()\r",
      "const hasValidValue = values.some(Boolean);\r",
      "// Use as the callback for Array.prototype.filter()\r",
      "const nonEmptyValues = values.filter(Boolean);\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Handle Boolean objects with care 30-seconds-of-code": {
    "prefix": "hjs Handle Boolean objects with care 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "While the `Boolean()` function is pretty useful, you might run into some issues with the `Boolean` object and the `Boolean` constructor. The `Boolean` object is an object wrapper for a boolean value, but the tricky part is that, as an object, it's always truthy even if the contained value is `false`!\r",
      "\r",
      "```js\r",
      "let x = new Boolean(false);\r",
      "\r",
      "if (x) {\r",
      "  // This code is executed\r",
      "}\r",
      "```\r",
      "\r",
      "For example, the above code will consider `x` truthy, even if it clearly contains `false` as its value. This might some confusing, but you can easily avoid it if you generally avoid using `Boolean` objects and the `Boolean` constructor, unless you are entirely certain that you need to use it for some reason. I cannot find any scenarios where I would need to use this, to be honest, so it might not be all that common to begin with.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Boolean trap - What's in a name? 30-seconds-of-code": {
    "prefix": "hjs Boolean trap - What's in a name? 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "While the name **Boolean trap** might be unfamiliar to some, I'm pretty certain the concept it represents isn't. The simplest form of a boolean trap is a function that takes a boolean argument.\r",
      "\r",
      "The **trap** in the name might throw you off if you stick to this definition, but it serves its purpose. Let's look at two simple examples to get a better grasp of things:\r",
      "\r",
      "```js\r",
      "// What does `false` stand for?\r",
      "results.reload(false);\r",
      "\r",
      "// What does `true` stand for?\r",
      "const user = new User(true);\r",
      "```\r",
      "\r",
      "The first example suffers in terms of readability due to an obvious contradiction. A function named `reload` expects a boolean argument. `false` in this context must surely mean that no reloading should happen. Except that might not be the case.  This argument might be anything from performing the operation immediately (i.e. `immediate`) to some side effect such as animation to even the no-op we suspected. I've stumbled upon similar cases of ambiguous arguments in many libraries in the past.\r",
      "\r",
      "The second example is also hard to decipher without looking at some documentation. Here, the constructor expects a boolean argument that might mean literally anything. Would you have guessed that it's a flag indicating if the user should have administrative privileges? Probably not. The point is there is no way to tell what this argument means without looking at the documentation.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Red flag or red herring? 30-seconds-of-code": {
    "prefix": "hjs Red flag or red herring? 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "At this point, you might be asking yourself why this is actually bad. Reading through the documentation is expected. After all, that's what it's there for. Except this starts to become a waste of time on return visits. If you're working with a library and look up a boolean argument over and over because it's not obvious, it becomes a bit of a hassle.\r",
      "\r",
      "Moreover, code is read many times by many people. The author might be familiar with the library and API and have no need for documentation altogether. But the next person who comes along will have to visit the same documentation and figure it out for themselves. That harms readability and wastes tons of time in the long run, due to a single boolean argument.\r",
      "\r",
      "A bonus point here is the potential of further reducing readability by increasing cognitive load. There are valid use-cases for boolean arguments,  but there are situations where the name of the function, being in itself a negative, with a negative (i.e. falsy) value makes the reader stop and pause to parse what's happening. For example:\r",
      "\r",
      "```js\r",
      "// Real quick: Is this valid or invalid?\r",
      "input.setInvalid(false);\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Not all booleans will trap you 30-seconds-of-code": {
    "prefix": "hjs Not all booleans will trap you 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "As with most things, there is no universal best practice here. Even though I often find boolean arguments hard to read, I understand there are cases where you might want to use them.\r",
      "\r",
      "```js\r",
      "// It should be obvious that `true` makes the element disabled\r",
      "element.setProperty('disabled', true);\r",
      "// Could be equivalent to `element.disabled = true;`\r",
      "```\r",
      "\r",
      "In this example, it's pretty straightforward what `true` does. Notice that the double negative from before might still make this slightly hard to read, but it makes sense to use a boolean in this context. Why? Well, it's essentially a setter function and passing the actual value of the property isn't such a bad idea.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Mitigating the problem 30-seconds-of-code": {
    "prefix": "hjs Mitigating the problem 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "We've already established what a boolean trap is and why it's bad. But how do we fix it? Even if we can spot the anti-pattern, it might be hard to change it before it affects a lot of code and developers. Some languages support named arguments and that usually solves the problem quite easily. JavaScript on the other hand doesn't, but there's always the option to pass an options object.\r",
      "\r",
      "Let's take a look at the two examples from before and how that would work:\r",
      "\r",
      "```js\r",
      "// Ok, so reload but not immediately\r",
      "results.reload({ immediate: false });\r",
      "\r",
      "// Create a new user without administrator privileges\r",
      "const user = new User({ isAdministrator: false });\r",
      "```\r",
      "\r",
      "Without huge changes to the API, we could have avoided the boolean trap altogether. All we needed was a plain JavaScript object. This also has the added benefit of making the function more extensible in the future. Objects are quite flexible, so if we want to add a second boolean (e.g. `animate` for `reload` or `active` for `User`), we need only add a key to the object.\r",
      "\r",
      "On a side note, while comments seem an appropriate solution, they will inevitably become stale and out of touch with the API. It's best to leave this kind of information to the official documentation or source code, instead.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Conclusion 30-seconds-of-code": {
    "prefix": "hjs Conclusion 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`HTMLElement.innerText` and `Node.textContent` are two very similar properties that can be used to access and manipulate the text content of an element. However, they differ in some important ways, and you should be aware of these differences to choose the one that best suits your needs. Always examine your use case and consider the performance implications of your choice.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Synchronous callbacks 30-seconds-of-code": {
    "prefix": "hjs Synchronous callbacks 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A synchronous callback is a callback function that is executed immediately. The function passed as the first argument to `Array.prototype.map()` is a great example of a synchronous callback:\r",
      "\r",
      "```js\r",
      "const nums = [1, 2, 3];\r",
      "const printDoublePlusOne = n => console.log(2 * n + 1);\r",
      "\r",
      "nums.map(printDoublePlusOne); // LOGS: 3, 5, 7\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Asynchronous callbacks 30-seconds-of-code": {
    "prefix": "hjs Asynchronous callbacks 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "An asynchronous callback is a callback function that is used to execute code after an asynchronous operation has completed. The function executed inside `Promise.prototype.then()` is a great example of an asynchronous callback:\r",
      "\r",
      "```js\r",
      "const nums = fetch('https://api.nums.org'); // Suppose the response is [1, 2, 3]\r",
      "const printDoublePlusOne = n => console.log(2 * n + 1);\r",
      "\r",
      "nums.then(printDoublePlusOne); // LOGS: 3, 5, 7\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Object-oriented programming 30-seconds-of-code": {
    "prefix": "hjs Object-oriented programming 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Both classical and prototypal inheritance are **object-oriented programming paradigms**. Objects in object-oriented programming are abstractions that encapsulate the properties of an entity. This is known as abstraction.\r",
      "\r",
      "When dealing with multiple levels of abstraction, each level is more general or more specific. The more general abstraction of a more specific abstraction is called a generalization.\r",
      "\r",
      "As mentioned previously, objects are abstraction of entities. We use either classes (classical inheritance) or prototypes (prototypal inheritance) to create generalizations of these objects. Generalizations are created by inheritance.\r",
      "\r",
      "Consider an example:\r",
      "\r",
      "- We have two objects representing two pets: Max the dog and Claire the cat. Let's call them `max` and `claire` respectively.\r",
      "- All dogs have common characteristics. Therefore we can create an abstraction, `Dog`, which encapsulates their common characteristics. We can use inheritance to pass characteristics from `Dog` to `max`.\r",
      "- The same applies for cats, allowing us to create an abstraction, `Cat`. Similarly, `claire` will inherit characteristics from `Cat`.\r",
      "- Cats and dogs share some common characteristics. We can create a generalization, `Animal`, to encapsulate those characteristics. `Dog` and `Cat` inherit these common characteristics from `Animal`.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Classical inheritance 30-seconds-of-code": {
    "prefix": "hjs Classical inheritance 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "In classical object-oriented programming, there are two types of abstractions: objects and classes. An object is an abstractions of an entity, while a class is either an abstraction of an object or another class.\r",
      "\r",
      "If we were to model the previous example using classical inheritance, it would look something like this:\r",
      "\r",
      "```js\r",
      "class Animal { }\r",
      "\r",
      "class Dog extends Animal { }\r",
      "class Cat extends Animal { }\r",
      "\r",
      "const max = new Dog();\r",
      "max.name = 'Max';\r",
      "\r",
      "const claire = new Cat();\r",
      "claire.name = 'Claire';\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Prototypal inheritance 30-seconds-of-code": {
    "prefix": "hjs Prototypal inheritance 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "In prototypal object-oriented programming, there's only one type of abstraction: objects. Objects are either abstractions of entities or other objects, in which case they're called prototypes. Hence a prototype is a generalization.\r",
      "\r",
      "Objects can be created out of nothing or from another object, which in turn becomes the prototype of the newly created object.\r",
      "\r",
      "If we were to model the previous example using prototypal inheritance, it would look something like this:\r",
      "\r",
      "```js\r",
      "const animal = {};\r",
      "\r",
      "const dog = Object.create(animal);\r",
      "const cat = Object.create(animal);\r",
      "\r",
      "const max = Object.create(dog);\r",
      "max.name = 'Max';\r",
      "\r",
      "const claire = Object.create(cat);\r",
      "claire.name = 'Claire';\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array reduce 30-seconds-of-code": {
    "prefix": "hjs Array reduce 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "const files = [ 'foo.txt ', '.bar', '   ', 'baz.foo' ];\r",
      "const filePaths = files.reduce((acc, file) => {\r",
      "  const fileName = file.trim();\r",
      "  if(fileName) {\r",
      "    const filePath = `~/cool_app/${fileName}`;\r",
      "    acc.push(filePath);\r",
      "  }\r",
      "  return acc;\r",
      "}, []);\r",
      "\r",
      "// filePaths = [ '~/cool_app/foo.txt', '~/cool_app/.bar', '~/cool_app/baz.foo']\r",
      "```\r",
      "\r",
      "- Uses `Array.prototype.reduce()` with an empty array as the initial value.\r",
      "- More common nowadays, due to functional programming being more popular.\r",
      "- Less control over the iteration, cannot skip elements or `return` early.\r",
      "- Can be chained with other methods, if necessary.\r",
      "- Uses `Array.prototype.push()` or the spread (`...`) operator to add elements.\r",
      "- `O(N)` complexity, each element will be iterated over only once.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Method chaining 30-seconds-of-code": {
    "prefix": "hjs Method chaining 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "const files = [ 'foo.txt ', '.bar', '   ', 'baz.foo' ];\r",
      "const filePaths = files\r",
      "  .map(file => file.trim())\r",
      "  .filter(Boolean)\r",
      "  .map(fileName => `~/cool_app/${fileName}`);\r",
      "\r",
      "// filePaths = [ '~/cool_app/foo.txt', '~/cool_app/.bar', '~/cool_app/baz.foo']\r",
      "```\r",
      "\r",
      "- Uses `Array.prototype.map()` and `Array.prototype.filter()`.\r",
      "- More common nowadays, due to functional programming being more popular.\r",
      "- Less control over the iteration, cannot skip elements or `return` early.\r",
      "- Declarative, easier to read and refactor, chain can grow as necessary.\r",
      "- Does not use `Array.prototype.push()` or the spread (`...`) operator.\r",
      "- `O(cN)` complexity, `c` iterations per element, (`c`: length of the chain).\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Recursive functions 30-seconds-of-code": {
    "prefix": "hjs Recursive functions 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Recursion is a programming technique where the final solution is computed by breaking down the problem into smaller instances of the same problem and computing the solution for each one. The most common implementation is a function that calls itself, reducing the problem every time until it reaches an instance of the problem whose solution is either trivial to compute or already known. Let's look at a very well-known example, calculating the `n`th term of the [Fibonacci sequence](https://en.wikipedia.org/wiki/Fibonacci_number), implemented using recursion in JavaScript:\r",
      "\r",
      "```js\r",
      "const fibonacciNumber = n =>\r",
      "  n < 2 ? fibonacciNumber(n - 1) + fibonacciNumber(n - 2) : n;\r",
      "```\r",
      "\r",
      "To understand recursion better, let's add a `console.log()` call before each `return` and figure out what exactly is happening:\r",
      "\r",
      "```js\r",
      "const fibonacciNumber = n => {\r",
      "  console.log(`[CALLED] fibonacciNumber(${n})`);\r",
      "  const r = n >= 2 ? fibonacciNumber(n - 1) + fibonacciNumber(n - 2) : n;\r",
      "  console.log(`[RETURN] ${r} for n=${n}`);\r",
      "  return r;\r",
      "}\r",
      "\r",
      "fibonacciNumber(4);\r",
      "// [CALLED] fibonacciNumber(4)\r",
      "// [CALLED] fibonacciNumber(3)\r",
      "// [CALLED] fibonacciNumber(2)\r",
      "// [CALLED] fibonacciNumber(1)\r",
      "// [RETURN] 1 for n=1\r",
      "// [CALLED] fibonacciNumber(0)\r",
      "// [RETURN] 0 for n=0\r",
      "// [RETURN] 1 for n=2\r",
      "// [CALLED] fibonacciNumber(1)\r",
      "// [RETURN] 1 for n=1\r",
      "// [RETURN] 2 for n=3\r",
      "// [CALLED] fibonacciNumber(2)\r",
      "// [CALLED] fibonacciNumber(1)\r",
      "// [RETURN] 1 for n=1\r",
      "// [CALLED] fibonacciNumber(0)\r",
      "// [RETURN] 0 for n=0\r",
      "// [RETURN] 1 for n=2\r",
      "// [RETURN] 3 for n=4\r",
      "```\r",
      "\r",
      "As you can see, for each value of `n`, `fibonacciNumber` will be called twice, once with `n - 1` and once with `n - 2` and this will continue until it's called with either `1` or `0`. While this is straightforward to write and understand, it is inefficient as it will have to calculate the same value more than once.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Calculation memoization 30-seconds-of-code": {
    "prefix": "hjs Calculation memoization 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The solution to this problem, and the first trick that you can use to speed up recursive functions, is to use memoization. We already published [a great blog post on memoization](/js/s/memoization/) a little while back, so be sure to check it out to learn more about the subject. Here's our `fibonacciNumber` function, using memoization:\r",
      "\r",
      "```js\r",
      "const fibonacciCache = new Map();\r",
      "\r",
      "const fibonacciNumber = n => {\r",
      "  console.log(`[CALL] fibonacciNumber(${n})`);\r",
      "  const cacheKey = `${n}`;\r",
      "  let r;\r",
      "  if(fibonacciCache.has(cacheKey)) {\r",
      "    r = fibonacciCache.get(cacheKey);\r",
      "    console.log(`[MEMO] Cache hit for ${n}: ${r}`);\r",
      "  }\r",
      "  else {\r",
      "    r = n >= 2 ? fibonacciNumber(n - 1) + fibonacciNumber(n - 2) : n;\r",
      "    fibonacciCache.set(cacheKey, r);\r",
      "    console.log(`[CALC] Computed and stored value for ${n}: ${r}`);\r",
      "  }\r",
      "  return r;\r",
      "}\r",
      "\r",
      "fibonacciNumber(4);\r",
      "// [CALL] fibonacciNumber(4)\r",
      "// [CALL] fibonacciNumber(3)\r",
      "// [CALL] fibonacciNumber(2)\r",
      "// [CALL] fibonacciNumber(1)\r",
      "// [CALC] Computed and stored value for 1: 1\r",
      "// [CALL] fibonacciNumber(0)\r",
      "// [CALC] Computed and stored value for 0: 0\r",
      "// [CALC] Computed and stored value for 2: 1\r",
      "// [CALL] fibonacciNumber(1)\r",
      "// [MEMO] Cache hit for 1: 1\r",
      "// [CALC] Computed and stored value for 3: 2\r",
      "// [CALL] fibonacciNumber(2)\r",
      "// [MEMO] Cache hit for 2: 1\r",
      "// [CALC] Computed and stored value for 4: 3\r",
      "```\r",
      "\r",
      "As you can see in the example above, the value for each `n` is only computed once. While the Fibonacci sequence doesn't require any costly calculations, this could make a huge difference for a more computationally expensive problem. It will also be a lot more noticeable for higher values of `n` where the number of calculations will increase significantly.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Using iteration 30-seconds-of-code": {
    "prefix": "hjs Using iteration 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The second and final trick stems from the very definition of recursive programming turned on its head. If we can solve a smaller instance of the problem and use it for the solution of a larger instance of the problem, it should be possible to work iteratively from the smaller problem to the larger one, instead of recursively. Here's this idea in practice for our `fibonacciNumber` function:\r",
      "\r",
      "```js\r",
      "const fibonacciNumber = n => {\r",
      "  let r = 0, l = 1, s = 0;\r",
      "  for(let i = 0; i < n; i++) {\r",
      "    r = l;\r",
      "    l = s;\r",
      "    s = r + l;\r",
      "    console.log(`[CALC] i = ${i}: r = ${r}, l = ${l}, s = ${s}`);\r",
      "  }\r",
      "  return s;\r",
      "}\r",
      "\r",
      "fibonacciNumber(4);\r",
      "// [CALC] i = 0: r = 1, l = 0, s = 1\r",
      "// [CALC] i = 1: r = 0, l = 1, s = 1\r",
      "// [CALC] i = 2: r = 1, l = 1, s = 2\r",
      "// [CALC] i = 3: r = 1, l = 2, s = 3\r",
      "```\r",
      "\r",
      "The iterative solution above makes the same calculations as the memoized one, however it performs better due to two key reasons. First of all, there is no cache, which would take up space in memory, making the latter implementation require fewer resources. Similarly, as there are no recursive calls or checks for cache hits, the code performs better and requires fewer resources to execute.\r",
      "\r",
      "However, you have to bear in mind what the actual use cases of your recursive code are and be very careful how you optimize them. Memoization can be a more powerful tool if a recursive function is called multiple times with different arguments, as its cache persists between calls, while iteration can be faster for recursive computations that are used less frequently. Always pay attention to your code and optimize for the cases you know or anticipate to be more common.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Exact string match 30-seconds-of-code": {
    "prefix": "hjs Exact string match 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use the `^` and `$` anchors to match the start and end of the string, respectively.\r",
      "- Add the string you want to match in-between the two anchors.\r",
      "\r",
      "```js\r",
      "const regexp = /^abc$/;\r",
      "// Where 'abc' is the exact string you want to match\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Match empty string 30-seconds-of-code": {
    "prefix": "hjs Match empty string 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use the `^` and `$` anchors to match the start and end of the string, respectively.\r",
      "- Do not add any characters in-between to match an empty string.\r",
      "\r",
      "```js\r",
      "const regexp = /^$/;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Match whitespace sequences 30-seconds-of-code": {
    "prefix": "hjs Match whitespace sequences 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use the `\\s` meta-sequence to match any whitespace character, including spaces, tabs, newlines, etc.\r",
      "- Use the `+` quantifier to match one or more occurrences of the previous character.\r",
      "- Add the global flag (`g`) to match all occurrences of the pattern in the string.\r",
      "\r",
      "```js\r",
      "const regexp = /\\s+/g;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Match line breaks 30-seconds-of-code": {
    "prefix": "hjs Match line breaks 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Depending on the environment, line breaks can be represented in different ways.\r",
      "- Use the `\\r` character to match carriage returns, the `\\n` character to match newlines, and the `\\r\\n` sequence to match carriage returns followed by newlines.\r",
      "- Add the global (`g`) and multiline (`m`) flags to match all occurrences of the pattern in the string.\r",
      "\r",
      "```js\r",
      "const regexp = /\\r|\\n|\\r\\n/gm;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Match non-word characters 30-seconds-of-code": {
    "prefix": "hjs Match non-word characters 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use negation (`^`) to match any character that is not a word character (`\\w`) or a whitespace character (`\\s`).\r",
      "- Add the global flag (`g`) to match all occurrences of the pattern in the string.\r",
      "- Add the ignore case flag (`i`) to match both uppercase and lowercase characters.\r",
      "\r",
      "```js\r",
      "const regexp = /[^\\w\\s]/gi;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Match alphanumeric, dashes and hyphens 30-seconds-of-code": {
    "prefix": "hjs Match alphanumeric, dashes and hyphens 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use the `^` and `$` anchors to match the start and end of the string, respectively.\r",
      "- Use the `a-zA-Z0-9-` pattern to match any alphanumeric character, dashes and hyphens.\r",
      "- Use the `+` quantifier to match one or more occurrences of the previous character.\r",
      "- Particularly useful when matching URL slugs.\r",
      "\r",
      "```js\r",
      "const regexp = /^[a-zA-Z0-9-_]+$/;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Match letters and whitespaces 30-seconds-of-code": {
    "prefix": "hjs Match letters and whitespaces 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use the `^` and `$` anchors to match the start and end of the string, respectively.\r",
      "- Use the `a-zA-Z\\s` pattern to match any letter and whitespace character.\r",
      "- Use the `+` quantifier to match one or more occurrences of the previous pattern.\r",
      "\r",
      "```js\r",
      "const regexp = /^[A-Za-z\\s]+$/;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Pattern not included 30-seconds-of-code": {
    "prefix": "hjs Pattern not included 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use the `^` and `$` anchors to match the start and end of the string, respectively.\r",
      "- Use a negative lookahead (`?!`) to match any character that is not followed by the pattern you want to exclude.\r",
      "- Add the global flag (`g`) to match all occurrences of the pattern in the string.\r",
      "- To ensure more than one pattern is not included, use the `|` character to separate them.\r",
      "\r",
      "```js\r",
      "const regexp = /^((?!(abc|bcd)).)*$/;\r",
      "// Where 'abc' and 'bcd' are pattern you want to exclude\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Text inside brackets 30-seconds-of-code": {
    "prefix": "hjs Text inside brackets 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use the `\\(` and `\\)` characters to match the opening and closing brackets, respectively.\r",
      "- Use a capturing group between the two and exclude the closing parenthesis character.\r",
      "- Use the `+` quantifier to match one or more characters, as needed.\r",
      "- Add the global flag (`g`) to match all occurrences of the pattern in the string.\r",
      "- Replace `\\(` and `\\)` with `\\[` and `\\]` to match square brackets and with `\\{` and `\\}` to match curly brackets.\r",
      "\r",
      "```js\r",
      "const regexp = /\\(([^)]+)\\)/g;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Validate GUID/UUID 30-seconds-of-code": {
    "prefix": "hjs Validate GUID/UUID 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use the `^` and `$` anchors to match the start and end of the string, respectively.\r",
      "- Validate each segment of the GUID/UUID separately using numeric character ranges and quantifiers.\r",
      "\r",
      "```js\r",
      "const regexp = /^(0?[1-9]|[12][0-9]|3[01])[\\/\\-](0?[1-9]|1[012])[\\/\\-]\\d{4}$/;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Validate date format (DD/MM/YYYY) 30-seconds-of-code": {
    "prefix": "hjs Validate date format (DD/MM/YYYY) 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use the `^` and `$` anchors to match the start and end of the string, respectively.\r",
      "- Validate each segment of the date separately using numeric character ranges and quantifiers.\r",
      "- Alter the order of the segments and separators to match different formats.\r",
      "\r",
      "```js\r",
      "const regexp = /^(0?[1-9]|[12][0-9]|3[01])[\\/\\-](0?[1-9]|1[012])[\\/\\-]\\d{4}$/;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Chunk string into n-size chunks 30-seconds-of-code": {
    "prefix": "hjs Chunk string into n-size chunks 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Use the `.{1,n}` quantifier to match any character between `1` and `n` times.\r",
      "- Add the global flag (`g`) to match all occurrences of the pattern in the string.\r",
      "\r",
      "```js\r",
      "const regexp = /.{1,2}/g;\r",
      "// Where '2' is the number of characters per chunk\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Computed property names 30-seconds-of-code": {
    "prefix": "hjs Computed property names 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "ES6 computed property names are particularly useful, as they can help you identify logged variables by adding a pair of curly braces around them.\r",
      "\r",
      "```js\r",
      "const x = 1, y = 2, z = 3;\r",
      "\r",
      "console.log({x, y, z}); // {x: 1, y: 2, z: 3}\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs console.trace() 30-seconds-of-code": {
    "prefix": "hjs console.trace() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[`console.trace()`](https://developer.mozilla.org/en-US/docs/Web/API/Console/trace) works the exact same as `console.log()`, but it also outputs the entire stack trace so you know exactly what's going on.\r",
      "\r",
      "```js\r",
      "const outer = () => {\r",
      "  const inner = () => console.trace('Hello');\r",
      "  inner();\r",
      "};\r",
      "\r",
      "outer();\r",
      "/*\r",
      "  Hello\r",
      "  inner @ VM207:3\r",
      "  outer @ VM207:5\r",
      "  (anonymous) @ VM228:1\r",
      "*/\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs console.group() 30-seconds-of-code": {
    "prefix": "hjs console.group() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[`console.group()`](https://developer.mozilla.org/en-US/docs/Web/API/Console/group) allows you to group logs into collapsable structures and is particularly useful when you have multiple logs.\r",
      "\r",
      "```js\r",
      "console.group('Outer');           // Create a group labelled 'Outer'\r",
      "console.log('Hello');             // Log inside 'Outer'\r",
      "console.groupCollapsed('Inner');  // Create a group labelled 'Inner', collapsed\r",
      "console.log('Hellooooo');         // Log inside 'Inner'\r",
      "console.groupEnd();               // End of current group, 'Inner'\r",
      "console.groupEnd();               // End of current group, 'Outer'\r",
      "console.log('Hi');                // Log outside of any groups\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Logging levels 30-seconds-of-code": {
    "prefix": "hjs Logging levels 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "There are a few more logging levels apart from `console.log()`, such as [`console.debug()`](https://developer.mozilla.org/en-US/docs/Web/API/Console/debug), [`console.info()`](https://developer.mozilla.org/en-US/docs/Web/API/Console/info), [`console.warn()`](https://developer.mozilla.org/en-US/docs/Web/API/Console/warn) and [`console.error()`](https://developer.mozilla.org/en-US/docs/Web/API/Console/error).\r",
      "\r",
      "```js\r",
      "console.debug('Debug message');\r",
      "console.info('Useful information');\r",
      "console.warn('This is a warning');\r",
      "console.error('Something went wrong!');\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs console.assert() 30-seconds-of-code": {
    "prefix": "hjs console.assert() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[`console.assert()`](https://developer.mozilla.org/en-US/docs/Web/API/console/assert) provides a handy way to only log something as an error when an assertion fails (i.e. when the first argument is `false`), otherwise skip the log entirely.\r",
      "\r",
      "```js\r",
      "const value = 10;\r",
      "\r",
      "console.assert(value === 10, 'Value is not 10!'); // Nothing is logged\r",
      "console.assert(value === 20, 'Value is not 20!'); // Logs \"Value is not 20!\"\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs console.count() 30-seconds-of-code": {
    "prefix": "hjs console.count() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "You can use [`console.count()`](https://developer.mozilla.org/en-US/docs/Web/API/Console/count) to count how many times a piece of code has executed.\r",
      "\r",
      "```js\r",
      "Array.from({ length: 4 }).forEach(\r",
      "  () => console.count('items')  // Call the counter labelled 'items'\r",
      ");\r",
      "/*\r",
      "  items: 1\r",
      "  items: 2\r",
      "  items: 3\r",
      "  items: 4\r",
      "*/\r",
      "console.countReset('items');  // Reset the counter labelled 'items'\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs console.time() 30-seconds-of-code": {
    "prefix": "hjs console.time() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[`console.time()`](https://developer.mozilla.org/en-US/docs/Web/API/Console/time) gives you a quick way to check the performance of your code, but should not be used for real benchmarking due to its low accuracy.\r",
      "\r",
      "```js\r",
      "console.time('slow comp');    // Start the 'slow comp' timer\r",
      "console.timeLog('slow comp'); // Log the value of the 'slow comp' timer\r",
      "console.timeEnd('slow comp'); // Stop and log the 'slow comp' timer\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs CSS 30-seconds-of-code": {
    "prefix": "hjs CSS 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Last but not least, you can use the `%c` string substitution expression in `console.log()` to apply CSS to parts of a log.\r",
      "\r",
      "```js\r",
      "console.log(\r",
      "  'CSS can make %cyour console logs%c %cawesome%c!',  // String to format\r",
      "  // Each string is the CSS to apply for each consecutive %c\r",
      "  'color: #fff; background: #1e90ff; padding: 4px',   // Apply styles\r",
      "  '',                                                 // Clear any styles\r",
      "  'color: #f00; font-weight: bold',                   // Apply styles\r",
      "  ''                                                  // Clear any styles\r",
      ");\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Cookies 30-seconds-of-code": {
    "prefix": "hjs Cookies 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Cookies store small amounts of data that has to be sent back to the server with subsequent requests and their expiration can be set from either server or client. They are primarily used for server-side reading.\r",
      "\r",
      "- Capacity: 4KB\r",
      "- Accessible from: Any window\r",
      "- Expiration: Manually set\r",
      "- Storage location: Browser and server\r",
      "- Sent with requests: Yes\r",
      "- Blockable by users: Yes\r",
      "- Editable by users: Yes\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Local storage 30-seconds-of-code": {
    "prefix": "hjs Local storage 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Local storage stores a larger amount of data on the client's computer in a key-value pair format and has no expiration date. Data is never transferred to the server and is accessible via JavaScript and HTML5.\r",
      "\r",
      "- Capacity: 10MB\r",
      "- Accessible from: Any window\r",
      "- Expiration: Never\r",
      "- Storage location: Browser only\r",
      "- Sent with requests: No\r",
      "- Blockable by users: Yes\r",
      "- Editable by users: Yes\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Session storage 30-seconds-of-code": {
    "prefix": "hjs Session storage 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Session storage stores a larger amount of data on the client's computer only for the current session, expiring the data on tab close. Data is never transferred to the server and is accessible client-side from the same tab.\r",
      "\r",
      "- Capacity: 5MB\r",
      "- Accessible from: Same tab\r",
      "- Expiration: On tab close\r",
      "- Storage location: Browser only\r",
      "- Sent with requests: No\r",
      "- Blockable by users: Yes\r",
      "- Editable by users: Yes\r",
      "\r",
      "|    | Cookies | Local storage | Session storage |\r",
      "| -- | -- | -- | -- |\r",
      "| Capacity | 4KB | 10MB | 5MB |\r",
      "| Accessible from | Any window | Any window | Same tab |\r",
      "| Expiration | Manually set | Never | On tab close |\r",
      "| Storage location | Browser and server | Browser only | Browser only |\r",
      "| Sent with requests | Yes | No | No |\r",
      "| Blockable by users | Yes | Yes | Yes |\r",
      "| Editable by users | Yes | Yes | Yes |\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs The spread operator 30-seconds-of-code": {
    "prefix": "hjs The spread operator 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "ES6 introduced the spread operator (`...`), which provides probably the easiest and most common way to create a shallow clone of an array.\r",
      "\r",
      "```js\r",
      "let x = [1, 2, 3, 4];\r",
      "let y = [...x];\r",
      "```\r",
      "\r",
      "#"
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array.prototype.slice() 30-seconds-of-code": {
    "prefix": "hjs Array.prototype.slice() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Similarly to the spread operator, `Array.prototype.slice()` can be used to create a shallow copy of an array.\r",
      "\r",
      "```js\r",
      "let x = [1, 2, 3, 4];\r",
      "let y = x.slice();\r",
      "```\r",
      "\r",
      "#"
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Asynchronous Clipboard API 30-seconds-of-code": {
    "prefix": "hjs Asynchronous Clipboard API 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A very common need when building websites is the ability to copy text to clipboard with a single button click. If you only need to support modern browsers, it's highly recommended to use the asynchronous [Clipboard API](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API). It's supported in all modern browsers and provides an easy and secure way to update the clipboard's contents.\r",
      "\r",
      "All you have to do is ensure `Navigator`, `Navigator.clipboard` and `Navigator.clipboard.writeText` are truthy and then call `Clipboard.writeText()` to copy the value to clipboard. In case anything goes wrong, you can use `Promise.reject()` to return a promise that rejects immediately and keep the return type consistent.\r",
      "\r",
      "```js\r",
      "const copyToClipboard = str => {\r",
      "  if (navigator && navigator.clipboard && navigator.clipboard.writeText)\r",
      "    return navigator.clipboard.writeText(str);\r",
      "  return Promise.reject('The Clipboard API is not available.');\r",
      "};\r",
      "```\r",
      "\r",
      "This is pretty much how the [copyToClipboardAsync snippet](/js/s/copy-to-clipboard-async) is implemented and should work across all modern browsers.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Document.execCommand('copy') 30-seconds-of-code": {
    "prefix": "hjs Document.execCommand('copy') 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "While support for the Clipboard API is pretty high across the board, you might need a fallback if you have to support older browsers. If that's the case, you can use `Document.execCommand('copy')` to do so. Here's a quick step-by-step guide:\r",
      "\r",
      "1. Create a` <textarea>` element to be appended to the document. Set its value to the string you want to copy to the clipboard.\r",
      "2. Append the `<textarea>` element to the current HTML document and use CSS to hide it to prevent flashing.\r",
      "3. Use `HTMLInputElement.select()` to select the contents of the `<textarea>` element.\r",
      "4. Use `Document.execCommand('copy')` to copy the contents of the `<textarea>` to the clipboard.\r",
      "5. Remove the `<textarea>` element from the document.\r",
      "\r",
      "```js\r",
      "const copyToClipboard = str => {\r",
      "  const el = document.createElement('textarea');\r",
      "  el.value = str;\r",
      "  el.setAttribute('readonly', '');\r",
      "  el.style.position = 'absolute';\r",
      "  el.style.left = '-9999px';\r",
      "  document.body.appendChild(el);\r",
      "  el.select();\r",
      "  document.execCommand('copy');\r",
      "  document.body.removeChild(el);\r",
      "};\r",
      "```\r",
      "\r",
      "Bear in mind that this method will not work everywhere, but only as a result of a user action (e.g. inside a `click` event listener), due to the way `Document.execCommand()` works.\r",
      "\r",
      "There are a couple of other considerations, such as restoring the user's previous selection on the document, which can be easily handled with modern JavaScript. You can find the final code with these improvements implemented in the [copyToClipboard snippet](/js/s/copy-to-clipboard/).\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Implementation 30-seconds-of-code": {
    "prefix": "hjs Implementation 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "class TreeNode {\r",
      "  constructor(key, value = key, parent = null) {\r",
      "    this.key = key;\r",
      "    this.value = value;\r",
      "    this.parent = parent;\r",
      "    this.children = [];\r",
      "  }\r",
      "\r",
      "  get isLeaf() {\r",
      "    return this.children.length === 0;\r",
      "  }\r",
      "\r",
      "  get hasChildren() {\r",
      "    return !this.isLeaf;\r",
      "  }\r",
      "}\r",
      "\r",
      "class Tree {\r",
      "  constructor(key, value = key) {\r",
      "    this.root = new TreeNode(key, value);\r",
      "  }\r",
      "\r",
      "  *preOrderTraversal(node = this.root) {\r",
      "    yield node;\r",
      "    if (node.children.length) {\r",
      "      for (let child of node.children) {\r",
      "        yield* this.preOrderTraversal(child);\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "\r",
      "  *postOrderTraversal(node = this.root) {\r",
      "    if (node.children.length) {\r",
      "      for (let child of node.children) {\r",
      "        yield* this.postOrderTraversal(child);\r",
      "      }\r",
      "    }\r",
      "    yield node;\r",
      "  }\r",
      "\r",
      "  insert(parentNodeKey, key, value = key) {\r",
      "    for (let node of this.preOrderTraversal()) {\r",
      "      if (node.key === parentNodeKey) {\r",
      "        node.children.push(new TreeNode(key, value, node));\r",
      "        return true;\r",
      "      }\r",
      "    }\r",
      "    return false;\r",
      "  }\r",
      "\r",
      "  remove(key) {\r",
      "    for (let node of this.preOrderTraversal()) {\r",
      "      const filtered = node.children.filter(c => c.key !== key);\r",
      "      if (filtered.length !== node.children.length) {\r",
      "        node.children = filtered;\r",
      "        return true;\r",
      "      }\r",
      "    }\r",
      "    return false;\r",
      "  }\r",
      "\r",
      "  find(key) {\r",
      "    for (let node of this.preOrderTraversal()) {\r",
      "      if (node.key === key) return node;\r",
      "    }\r",
      "    return undefined;\r",
      "  }\r",
      "}\r",
      "```\r",
      "\r",
      "- Create a `class` for the `TreeNode` with a `constructor` that initializes the appropriate `key`, `value`, `parent` and `children` properties.\r",
      "- Define an `isLeaf` getter, that uses `Array.prototype.length` to check if `children` is empty.\r",
      "- Define a `hasChildren` getter, that is the reverse of the `isLeaf` getter.\r",
      "- Create a `class` for the `Tree` with a `constructor` that initializes the `root` of the tree.\r",
      "- Define a `preOrderTraversal()` generator method that traverses the tree in pre-order, using the `yield*` syntax to recursively delegate traversal to itself.\r",
      "- Define a `postOrderTraversal()` generator method that traverses the tree in post-order, using the `yield*` syntax to recursively delegate traversal to itself.\r",
      "- Define an `insert()` method, that uses the `preOrderTraversal()` method and `Array.prototype.push()` to add a new `TreeNode` to the tree.\r",
      "- Define a `remove()` method, that uses the `preOrderTraversal()` method and `Array.prototype.filter()` to remove a `TreeNode` from the tree.\r",
      "- Define a `find()` method, that uses the `preOrderTraversal()` method to retrieve the given node in the tree.\r",
      "\r",
      "```js\r",
      "const tree = new Tree(1, 'AB');\r",
      "\r",
      "tree.insert(1, 11, 'AC');\r",
      "tree.insert(1, 12, 'BC');\r",
      "tree.insert(12, 121, 'BG');\r",
      "\r",
      "[...tree.preOrderTraversal()].map(x => x.value);\r",
      "// ['AB', 'AC', 'BC', 'BCG']\r",
      "\r",
      "tree.root.value;              // 'AB'\r",
      "tree.root.hasChildren;        // true\r",
      "\r",
      "tree.find(12).isLeaf;         // false\r",
      "tree.find(121).isLeaf;        // true\r",
      "tree.find(121).parent.value;  // 'BC'\r",
      "\r",
      "tree.remove(12);\r",
      "\r",
      "[...tree.postOrderTraversal()].map(x => x.value);\r",
      "// ['AC', 'AB']\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Date.prototype.getTime() 30-seconds-of-code": {
    "prefix": "hjs Date.prototype.getTime() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "One way to compare two `Date` values is using the `Date.prototype.getTime()` method. This method returns a number indicating the number of milliseconds elapsed since the Unix Epoch:\r",
      "\r",
      "```js\r",
      "const a = new Date(2022, 01, 10);\r",
      "const b = new Date(2022, 01, 10);\r",
      "\r",
      "a.getTime() === b.getTime(); // true\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Other methods 30-seconds-of-code": {
    "prefix": "hjs Other methods 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "As mentioned before, `Date.prototype.getTime()` is one way to compare two `Date` values. It's not the only one way to compare them. Other options are the following:\r",
      "\r",
      "- `Date.prototype.toISOString()`\r",
      "- `Date.prototype.toUTCString()`\r",
      "- `Date.prototype.toLocaleDateString()` provided you use the same locale\r",
      "\r",
      "All of these methods produce consistent results, but we still recommend `Date.prototype.getTime()` due to its simplicity.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array destructuring 30-seconds-of-code": {
    "prefix": "hjs Array destructuring 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Destructuring an array is very straightforward. All you have to do is declare a variable for each value in the sequence. You can define fewer variables than there are indexes in the array (i.e. if you only want to unpack the first few values), skip some indexes or even use the rest pattern to unpack any remaining values into a new array.\r",
      "\r",
      "```js\r",
      "const nums = [ 3, 6, 9, 12, 15 ];\r",
      "const [\r",
      "  k,              // k = 3\r",
      "  l,              // l = 6\r",
      "  ,               // Skip a value (9)\r",
      "  ...n            // n = [12, 15]\r",
      "] = nums;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Object destructuring 30-seconds-of-code": {
    "prefix": "hjs Object destructuring 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Object destructuring is pretty similar to array destructuring, the main difference being that you can reference each key in the object by name, creating a variable with the same name. Additionally, you can also unpack a key to a new variable name, unpack only the keys you need and use the rest pattern to unpack remaining keys into a new object.\r",
      "\r",
      "```js\r",
      "const obj = { a: 1, b: 2, c: 3, d: 4 };\r",
      "const {\r",
      "  a,              // a = 1\r",
      "  c: d,           // d = 3\r",
      "  ...rest         // rest = { b: 2, d: 4 }\r",
      "} = obj;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Nested destructuring 30-seconds-of-code": {
    "prefix": "hjs Nested destructuring 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Nested objects and arrays can be unpacked by following the same rules. The difference here is that you can unpack nested keys or values directly to variables without having to store the parent object in a variable itself.\r",
      "\r",
      "```js\r",
      "const nested = { a: { b: 1, c: 2 }, d: [1, 2]};\r",
      "const {\r",
      "  a: {\r",
      "    b: f,         // f = 1\r",
      "    ...g          // g = { c: 2 }\r",
      "  },\r",
      "  ...h            // h = { d: [1, 2]}\r",
      "} = nested;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Advanced destructuring 30-seconds-of-code": {
    "prefix": "hjs Advanced destructuring 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "As arrays act much like objects, it's possible to use the destructuring assignment syntax to get specific values from an array by using the index as a key in an object destructuring assignment. Additionally, using this method, you can get other properties of the array (e.g. its `length`). Finally, you can also define default values for variables in a destructuring assignment, in case the unpacked value is `undefined`.\r",
      "\r",
      "```js\r",
      "const arr = [ 5, 'b', 4, 'd', 'e', 'f', 2 ];\r",
      "const {\r",
      "  6: x,           // x = 2\r",
      "  0: y,           // y = 5\r",
      "  2: z,           // z = 4\r",
      "  length: count,  // count = 7\r",
      "  name = 'array', // name = 'array' (not present in arr)\r",
      "  ...restData     // restData = { '1': 'b', '3': 'd', '4': 'e', '5': 'f' }\r",
      "} = arr;\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Dynamic getters 30-seconds-of-code": {
    "prefix": "hjs Dynamic getters 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A **dynamic getter** is a getter that is not explicitly defined for a property, but is instead created on the fly when the property is accessed. This is particularly useful when the shape of the data is not known in advance, or when the value of a property needs to be manipulated before it is returned.\r",
      "\r",
      "In this example, we will be creating a proxy that will manipulate string values in the target object. The proxy will trim any string values that are accessed, and return the value as-is for any other type of value. Finally, non-existent properties will return `undefined`, as expected.\r",
      "\r",
      "```js\r",
      "const obj = { foo: 'bar  ', baz: '  qux ', quux: 1 };\r",
      "\r",
      "const proxiedObj = new Proxy(obj, {\r",
      "  get(target, prop) {\r",
      "    if (prop in target && typeof target[prop] === 'string')\r",
      "      return target[prop].trim();\r",
      "    return target[prop];\r",
      "  }\r",
      "});\r",
      "\r",
      "proxiedObj.foo; // 'bar'\r",
      "proxiedObj.baz; // 'qux'\r",
      "proxiedObj.quux; // 1\r",
      "proxiedObj.quuz; // undefined\r",
      "```\r",
      "\r",
      "While this is a simple example, it highlights the power of the `Proxy` object. In this case, we are able to manipulate the behavior of the object without having to define a getter for each property. This will also apply to any new properties that are added to the object, as the proxy will be able to intercept the access and return the appropriate value.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Dynamic setters 30-seconds-of-code": {
    "prefix": "hjs Dynamic setters 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A **dynamic setter** is a setter that is not explicitly defined for a property, but is instead created on the fly when the property is set. This can be very useful if the object's keys follow a certain pattern or certain conditions apply to all values that are set.\r",
      "\r",
      "In this example, we will be creating a proxy that will only allow setting of properties that correspond to a date in the format `yyyy-mm-dd`. Additionally, if a property is already set, its value should be impossible to change. This could be useful if, for example, you were creating something akin to a read-only log.\r",
      "\r",
      "```js\r",
      "const obj = {};\r",
      "\r",
      "const proxiedObj = new Proxy(obj, {\r",
      "  set(target, prop, value) {\r",
      "    if (prop in target) return false;\r",
      "    if (typeof prop === 'string' && prop.match(/^\\d{4}-\\d{2}-\\d{2}$/)) {\r",
      "      target[prop] = value;\r",
      "      return true;\r",
      "    }\r",
      "    return false;\r",
      "  }\r",
      "});\r",
      "\r",
      "proxiedObj['2023-01-01'] = 1;\r",
      "proxiedObj['2023-01-01'] = 2; // This will fail, the property is already set\r",
      "proxiedObj['2023-ab-cd'] = 1; // This will fail, the property name is not a date\r",
      "proxiedObj; // { '2023-01-01': 1 }\r",
      "```\r",
      "\r",
      "As shown in this example, the `Proxy` object can be used to validate keys as well as values when setting properties. In this case, we were able to prevent the value of a property from being changed, as well as prevent the setting of properties that do not follow the expected pattern.\r",
      "\r",
      "As a side note, remember that the regular expression used here is not a full date validation, but only checks for a simple pattern to demonstrate the concept. If you need to validate dates in a production environment, this is not the way to go.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Assign it to an empty array 30-seconds-of-code": {
    "prefix": "hjs Assign it to an empty array 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "You can assign your variable to an empty array (`[]`) in order to clear it. While this option is rather fast, you should be mindful of references to the original array, as they will remain unchanged. Moreover, it doesn't work for arrays declared as `const`.\r",
      "\r",
      "```js\r",
      "let a = [1, 2, 3, 4];\r",
      "a = [];\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Set its length to 0 30-seconds-of-code": {
    "prefix": "hjs Set its length to 0 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A better option is to set the `length` of the array to `0`. This option is also pretty fast and has the additional benefit of working for `const` variables.\r",
      "\r",
      "```js\r",
      "let a = [1, 2, 3, 4];\r",
      "a.length = 0;\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Use Array.prototype.splice() 30-seconds-of-code": {
    "prefix": "hjs Use Array.prototype.splice() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`Array.prototype.splice()` can also be a useful alternative when trying to empty an array. While it has no other downsides compared to the previous method, it doesn't seem to perform as well, so that might be something to consider.\r",
      "\r",
      "```js\r",
      "let a = [1, 2, 3, 4];\r",
      "a.splice(0, a.length);\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Use Array.prototype.pop() 30-seconds-of-code": {
    "prefix": "hjs Use Array.prototype.pop() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Last but not least, using `Array.prototype.pop()` is another, more old-fashioned option. It's generally more verbose and less performant, so I'd rather use one of the previous methods instead.\r",
      "\r",
      "```js\r",
      "let a = [1, 2, 3, 4];\r",
      "while (a.length) a.pop();\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs encodeURIComponent() 30-seconds-of-code": {
    "prefix": "hjs encodeURIComponent() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The [`encodeURIComponent()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) function encodes everything in the given string, except `A-Z a-z 0-9 - _ . ! ~ * ' ( )`. You should use this function if the string you are encoding is only part of a URL.\r",
      "\r",
      "```js\r",
      "const partOfURL = 'my-page#with,speci@l&/\"characters\"?';\r",
      "const fullURL = 'https://my-website.com/my-page?query=\"a%b\"&user=1';\r",
      "\r",
      "encodeURIComponent(partOfURL); // Good, escapes special characters\r",
      "// 'my-page%23with%2Cspeci%40l%26%2F%22characters%22%3F'\r",
      "\r",
      "encodeURIComponent(fullURL);  // Bad, encoded URL is not valid\r",
      "// 'https%3A%2F%2Fmy-website.com%2Fmy-page%3Fquery%3D%22a%25b%22%26user%3D1'\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs encodeURI() 30-seconds-of-code": {
    "prefix": "hjs encodeURI() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The [`encodeURI()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI) function encodes everything in the given string, except `A-Z a-z 0-9 ; , / ? : @ & = + $ - _ . ! ~ * ' ( ) #`. You should use this function if the string you are encoding is a full URL.\r",
      "\r",
      "```js\r",
      "const partOfURL = 'my-page#with,speci@l&/\"characters\"?';\r",
      "const fullURL = 'https://my-website.com/my-page?query=\"a%b\"&user=1';\r",
      "\r",
      "encodeURI(partOfURL); // Bad, does not escape all special characters\r",
      "// 'my-page#with,speci@l&/%22characters%22?'\r",
      "\r",
      "encodeURI(fullURL);  // Good, encoded URL is valid\r",
      "// 'https://my-website.com/my-page?query=%22this%25thing%22&user=1'\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Object.keys() 30-seconds-of-code": {
    "prefix": "hjs Object.keys() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`Object.keys()` has the exact same behavior as a `for...in` loop, so it can be used as a drop-in replacement:\r",
      "\r",
      "```js\r",
      "const data = [3, 4];\r",
      "// Same as for (let k in data) console.log(k)\r",
      "Object.keys(data).forEach(k => console.log(k));\r",
      "// 0 1\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Object.values() 30-seconds-of-code": {
    "prefix": "hjs Object.values() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`Object.values()` is very similar to `Object.keys()`, but returns the values instead of the keys, which might be what you are really using the keys for:\r",
      "\r",
      "```js\r",
      "const data = [3, 4];\r",
      "// Iterate over the values\r",
      "Object.values(data).forEach(v => console.log(v));\r",
      "// 3 4\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Object.entries() 30-seconds-of-code": {
    "prefix": "hjs Object.entries() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Finally, if you need both key and value, `Object.entries()` has you covered:\r",
      "\r",
      "```js\r",
      "const data = [3, 4];\r",
      "// Iterate over the data, returning key-value pairs\r",
      "Object.entries(data).forEach(e => console.log(e[0], e[1]));\r",
      "// [0, 3] [1, 4]\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Event bubbling 30-seconds-of-code": {
    "prefix": "hjs Event bubbling 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Bubbling means that the event propagates from the target element (i.e. the `button` the user clicked) up through its ancestor tree, starting from the nearest one. By default, all events bubble.\r",
      "\r",
      "To better understand event bubbling, consider the following HTML example, which we will be referring to for most of this article:\r",
      "\r",
      "```html\r",
      "<html>\r",
      "  <body>\r",
      "    <div id=\"btn-container\">\r",
      "      <button class=\"btn\">Click me</button>\r",
      "    </div>\r",
      "  </body>\r",
      "</html>\r",
      "```\r",
      "\r",
      "```js\r",
      "const ancestors = [\r",
      "  window, document, document.documentElement,\r",
      "  document.body, document.getElementById('btn-container')\r",
      "];\r",
      "\r",
      "// Target phase\r",
      "document.querySelector('.btn').addEventListener('click', e => {\r",
      "  console.log(`Hello from ${e.target}`);\r",
      "});\r",
      "// Bubble phase\r",
      "ancestors.forEach(a => {\r",
      "  a.addEventListener('click', e => {\r",
      "    console.log(`Hello from ${e.currentTarget}`);\r",
      "  });\r",
      "});\r",
      "```\r",
      "\r",
      "If we add an event listener to each element in the tree, as shown above, we would see a listener fired by the `button` first, then each one of the others firing from the nearest ancestor all the way up to `Window`.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Event capturing 30-seconds-of-code": {
    "prefix": "hjs Event capturing 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Capturing is the exact opposite of bubbling, meaning that the outer event handlers are fired before the most specific handler (i.e. the one on the `button`). Note that all capturing event handlers are run first, then all the bubbling event handlers.\r",
      "\r",
      "You can use event capturing by applying a third argument to [`EventTarget.addEventListener`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener), setting it to `true`. For example:\r",
      "\r",
      "```js\r",
      "// Capture phase\r",
      "ancestors.forEach(a => {\r",
      "  a.addEventListener('click', e => {\r",
      "    console.log(`Hello from ${e.currentTarget}`);\r",
      "  }, true);\r",
      "});\r",
      "```\r",
      "\r",
      "Given this code, we would see a listener fired for each ancestor of the `button` first and then the listener of the `button` would fire.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Event propagation 30-seconds-of-code": {
    "prefix": "hjs Event propagation 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Having explained event bubbling and capturing, we can now explain the three phases of event propagation:\r",
      "\r",
      "- During the **capture phase**, the event starts from `Window` and moves down to `Document`, the root element and through ancestors of the target element.\r",
      "- During the **target phase**, the event gets triggered on the event target (e.g. the `button` the user clicked).\r",
      "- During the **bubble phase**, the event bubbles up through ancestors of the target element until the root element, `Document` and, finally, `Window`.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Event delegation 30-seconds-of-code": {
    "prefix": "hjs Event delegation 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Event delegation refers to the idea of delegating event listening to parent elements instead of adding event listeners directly to the event targets. Using this technique, the parent can catch and handle the bubbling events as necessary.\r",
      "\r",
      "```js\r",
      "window.addEventListener('click', e => {\r",
      "  if (e.target.className === 'btn') console.log('Hello there!');\r",
      "});\r",
      "```\r",
      "\r",
      "In the above example, we delegate event handling from the `button` to `Window` and use `Event.target` to get the original event's target.\r",
      "\r",
      "Using the event delegation pattern is advantageous for two reasons:\r",
      "\r",
      "- By using event delegation, we can listen for events on a large amount of elements without having to attach event listeners individually, which can provide performance benefits.\r",
      "- By using event delegation, dynamic elements (i.e. added or removed from the DOM over the course of time) can have their events captured and handled without requiring listeners to be registered or removed.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs The Call Stack 30-seconds-of-code": {
    "prefix": "hjs The Call Stack 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The **Call Stack** is a data structure that keeps track of the execution of JavaScript code. As the name suggests, it's a stack, thus a LIFO (Last In, First Out) data structure in memory. Each function that's executed is represented as a frame in the Call Stack and placed on top of the previous function.\r",
      "\r",
      "Let's look at a simple example, step by step:\r",
      "\r",
      "```js\r",
      "function foo() {\r",
      "  console.log('foo');\r",
      "  bar();\r",
      "}\r",
      "\r",
      "function bar() {\r",
      "  console.log('bar');\r",
      "}\r",
      "```\r",
      "\r",
      "1. The Call Stack is initially empty.\r",
      "2. The function `foo()` is pushed onto the Call Stack.\r",
      "3. The function `foo()` is executed and popped off the Call Stack.\r",
      "4. The function `console.log('foo')` is pushed onto the Call Stack.\r",
      "5. The function `console.log('foo')` is executed and popped off the Call Stack.\r",
      "6. The function `bar()` is pushed onto the Call Stack.\r",
      "7. The function `bar()` is executed and popped off the Call Stack.\r",
      "8. The function `console.log('bar')` is pushed onto the Call Stack.\r",
      "9. The function `console.log('bar')` is executed and popped off the Call Stack.\r",
      "10. The Call Stack is now empty.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Tasks and the Task Queue 30-seconds-of-code": {
    "prefix": "hjs Tasks and the Task Queue 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "**Tasks** are scheduled, synchronous blocks of code. While executing, they have exclusive access to the Call Stack and can also enqueue other tasks. Between Tasks, the browser can perform rendering updates. Tasks are stored in the **Task Queue**, waiting to be executed by their associated functions. The Task Queue, in turn, is a FIFO (First In, First Out) data structure. Examples of Tasks include the callback function of an event listener associated with an event and the callback of `setTimeout()`.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Microtasks an the Microtask Queue 30-seconds-of-code": {
    "prefix": "hjs Microtasks an the Microtask Queue 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "**Microtasks** are similar to Tasks in that they're scheduled, synchronous blocks of code with exclusive access to the Call Stack while executing. Additionally, they are stored in their own FIFO (First In, First Out) data structure, the **Microtask Queue**. Microtasks differ from Tasks, however, in that the Microtask Queue must be emptied out after a Task completes and before re-rendering. Examples of Microtasks include `Promise` callbacks and `MutationObserver` callbacks.\r",
      "\r",
      "Microtasks and the Microtask Queue are also referred to as Jobs and the Job Queue.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs The Event Loop 30-seconds-of-code": {
    "prefix": "hjs The Event Loop 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Finally, the **Event Loop** is a loop that keeps running and checks if the Call Stack is empty. It processes Tasks and Microtasks, by placing them in the Call Stack one at a time and also controls the rendering process. It's made up of four key steps:\r",
      "\r",
      "1. **Script evaluation:** Synchronously executes the script until the Call Stack is empty.\r",
      "2. **Task processing:** Select the first Task in the Task Queue and run it until the Call Stack is empty.\r",
      "3. **Microtask processing:** Select the first Microtask in the Microtask Queue and run it until the Call Stack is empty, repeating until the Microtask Queue is empty.\r",
      "4. **Rendering:** Re-render the UI and loop back to step 2.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs A practical example 30-seconds-of-code": {
    "prefix": "hjs A practical example 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "To better understand the Event Loop, let's look at a practical example, incorporating all of the above concepts:\r",
      "\r",
      "```js\r",
      "console.log('Script start');\r",
      "\r",
      "setTimeout(() => console.log('setTimeout()'), 0);\r",
      "\r",
      "Promise.resolve()\r",
      "  .then(() => console.log('Promise.then() #1'))\r",
      "  .then(() => console.log('Promise.then() #2'));\r",
      "\r",
      "console.log('Script end');\r",
      "\r",
      "// LOGS:\r",
      "//   Script start\r",
      "//   Script end\r",
      "//   Promise.then() #1\r",
      "//   Promise.then() #2\r",
      "//   setTimeout()\r",
      "```\r",
      "\r",
      "Does the output look like what you expected? Let's break down what's happening, step by step:\r",
      "\r",
      "1. The Call Stack is initially empty. The Event Loop begins evaluating the script.\r",
      "2. `console.log()` is pushed to the Call Stack and executed, logging `'Script start'`.\r",
      "3. `setTimeout()` is pushed to the Call Stack and executed. This creates a new Task for its callback function in the Task Queue.\r",
      "4. `Promise.prototype.resolve()` is pushed to the Call Stack and executed, calling in turn `Promise.prototype.then()`.\r",
      "5. `Promise.prototype.then()` is pushed to the Call Stack and executed. This creates a new Microtask for its callback function in the Microtask Queue.\r",
      "6. `console.log()` is pushed to the Call Stack and executed, logging `'Script end'`.\r",
      "7. The Event Loops has finished its current Task, evaluating the script. It then begins running the first Microtask in the Microtask Queue, which is the callback of `Promise.prototype.then()` that was queued in step 5.\r",
      "8. `console.log()` is pushed to the Call Stack and executed, logging `'Promise.then() #1'`.\r",
      "9. `Promise.prototype.then()` is pushed to the Call Stack and executed. This creates a new entry for its callback function in the Microtask Queue.\r",
      "10. The Event Loop checks the Microtask Queue. As it’s not empty, it executes the first Microtask, which is the callback of `Promise.prototype.then()` that was queued in step 10.\r",
      "11. `console.log()` is pushed to the Call Stack and executed, logging `'Promise.then() #2'`.\r",
      "12. Re-rendering would occur here, if there was any.\r",
      "13. The Microtask Queue is empty, so the Event Loop moves to the Task Queue and executes the first Task, which is the callback of `setTimeout()` that was queued in step 3.\r",
      "14. `console.log()` is pushed to the Call Stack and executed, logging `'setTimeout()'`.\r",
      "15. Re-rendering would occur here, if there was any.\r",
      "16. The Call Stack is now empty.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Summary 30-seconds-of-code": {
    "prefix": "hjs Summary 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The **Event Loop** is responsible for executing the JavaScript code. It first evaluates and executes the script, then processes **Tasks** and **Microtasks**.\r",
      "- **Tasks** and **Microtasks** are scheduled, synchronous blocks of code. They are executed one at a time, and are placed in the **Task Queue** and **Microtask Queue**, respectively.\r",
      "- For all of these, the **Call Stack** is used to keep track of function calls.\r",
      "- Whenever **Microtasks** are executed, the **Microtask Queue** must be emptied out before the next **Task** can be executed.\r",
      "- **Rendering** occurs between **Tasks**, but not between **Microtasks**.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Notes 30-seconds-of-code": {
    "prefix": "hjs Notes 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The script evaluation step of the Event Loop is in itself treated similarly to a Task.\r",
      "- The second argument of `setTimeout()` indicates a minimum time until execution, not a guaranteed time. This is due to the fact that Tasks execute in order and that Microtasks may be executed in-between.\r",
      "- The behavior of the event loop in Node.js is similar, but has some differences. Most notably, there is no rendering step.\r",
      "- Older browser versions did not completely respect the order of operations, so Tasks and Microtasks may execute in different orders.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Hidden state 30-seconds-of-code": {
    "prefix": "hjs Hidden state 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The main argument against closures is that of hidden state. Hidden state refers to obscuring the state of an object or, in this case, a function. The argument is that **internal mutable state** can create unpredictable behavior and unexpected results. Due to this, it's often said that hidden state is the root of all evil when it comes to programming.\r",
      "\r",
      "While the argument in itself has some merit, I don't much like the generalization. There are perfectly valid cases where hidden state is expected, even practically a necessity. However, it's true that hidden state can create bugs and unmaintainable code.\r",
      "\r",
      "An example of hidden state due to closures would be the one presented in my original introduction to the topic:\r",
      "\r",
      "```js\r",
      "const initCounter = (start = 0) => {\r",
      "  let value = start;\r",
      "  return {\r",
      "    get: () => value,\r",
      "    increment: () => ++value,\r",
      "    decrement: () => --value,\r",
      "    reset: () => value = start\r",
      "  };\r",
      "}\r",
      "\r",
      "const counter = initCounter(5);\r",
      "counter.get(); // 5\r",
      "counter.increment(); // 6\r",
      "counter.increment(); // 7\r",
      "counter.decrement(); // 6\r",
      "counter.reset(); // 5\r",
      "```\r",
      "\r",
      "In this scenario, the `initCounter` function returns an object that contains hidden mutable state in the form of the `value` variable. Obviously, this is a very simple example, but `counter.get()` or `counter.increment()` in isolation would be considered non-deterministic expressions. There is no way to know the result of a method call like that without analyzing the surrounding code.\r",
      "\r",
      "While this is not uncommon, it can get more complicated when shared state comes into play or many pieces of code are interacting with one another. The common remedy to this issue is to use **functional programming** and refactor the hidden mutable state into an argument or a shared global variable.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Access to context 30-seconds-of-code": {
    "prefix": "hjs Access to context 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Not all closures are created equal. In fact, there are perfectly valid use-cases of closures that can make life a lot easier. For example, **accessing shared constants** should be considered pretty safe. After all, if you want truly pure functions you shouldn't even access globals and web APIs. This would be pretty impractical, as you would have to pass each global and API as an argument to the function.\r",
      "\r",
      "Although reasonably safe, it's important to ensure that constants are initialized before being used and explicitly throw an error, if not. Additionally, adequate documentation of such closures will minimize friction and make sure other developers understand what's going on. Finally, providing an escape hatch, usually in the form of **default arguments** that can be overridden, should be considered if possible.\r",
      "\r",
      "Here's an example of a simple random number generator, following these rules:\r",
      "\r",
      "```js\r",
      "const randomNumber = (limit = 100, random = Math.random) => random() * limit;\r",
      "\r",
      "randomNumber(10); // 4.0\r",
      "randomNumber(10, () => 0.2); // 2.0\r",
      "```\r",
      "\r",
      "Another benefit of these practices is that writing tests is a lot easier, as there's no confusion as to what needs to be mocked at any given time. In this example, we can easily replace `Math.random()` with any function that we want and know the resulting value.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs jQuery 30-seconds-of-code": {
    "prefix": "hjs jQuery 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Back in the day when jQuery was all the rage, we would usually use [`$.one()`](https://api.jquery.com/one/) to create an event handler that would execute at most once for a given event per element. A simple example would be as follows:\r",
      "\r",
      "```html\r",
      "<button id=\"my-btn\">Click me!</button>\r",
      "```\r",
      "\r",
      "```js\r",
      "$('#my-btn').one('click', () => {\r",
      "  console.log('Hello!');  // 'Hello!' will only be logged on the first click\r",
      "});\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Using a flag 30-seconds-of-code": {
    "prefix": "hjs Using a flag 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "However, jQuery seems to have fallen out of favor lately and thus many developers have resorted to writing their version of `$.one()`. An implementation could look like this:\r",
      "\r",
      "```js\r",
      "const listenOnce = (el, evt, fn) => {\r",
      "  let fired = false;\r",
      "  el.addEventListener(evt, (e) => {\r",
      "    if (!fired) fn(e);\r",
      "    fired = true;\r",
      "  });\r",
      "};\r",
      "\r",
      "listenOnce(\r",
      "  document.getElementById('my-btn'),\r",
      "  'click',\r",
      "  () => console.log('Hello!')\r",
      ");  // 'Hello!' will only be logged on the first click\r",
      "```\r",
      "\r",
      "In this implementation, we use a flag, `fired`, to check if the event has been triggered before and only execute the passed callback, `fn`, the first time the event is triggered. There are some details that we might have omitted such as removing the listener, but overall this is a reasonably solid implementation.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Event listener options 30-seconds-of-code": {
    "prefix": "hjs Event listener options 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "If you are targeting modern browsers (i.e. not IE), [`EventTarget.addEventListener()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) has introduced the `options` object parameter, which allows us to pass a few different flags, one of which is `once`. Setting `once` to `true` results in the exact same behavior as the snippet above with minimal effort.\r",
      "\r",
      "Here's one way to write the previous snippet using `once`, which also happens to be how we implemented the latest version of the [listenOnce snippet](/js/s/listen-once):\r",
      "\r",
      "```js\r",
      "const listenOnce = (el, evt, fn) => el.addEventListener(evt, fn, { once: true });\r",
      "\r",
      "listenOnce(\r",
      "  document.getElementById('my-btn'),\r",
      "  'click',\r",
      "  () => console.log('Hello!')\r",
      ");  // 'Hello!' will only be logged on the first click\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Function.prototype.call() 30-seconds-of-code": {
    "prefix": "hjs Function.prototype.call() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`Function.prototype.call()` is used to call a function with a given `this` context and any arguments provided individually. For example:\r",
      "\r",
      "```js\r",
      "function printThisAndData(...data) {\r",
      "  console.log(this.data, ...data);\r",
      "}\r",
      "\r",
      "const obj = { data: 0 };\r",
      "const data = [1, 2, 3];\r",
      "\r",
      "printThisAndData.call(obj, data);       // logs: 0 [1, 2, 3]\r",
      "printThisAndData.call(obj, ...data);    // logs: 0 1 2 3\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Function.prototype.apply() 30-seconds-of-code": {
    "prefix": "hjs Function.prototype.apply() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`Function.prototype.apply()` is almost identical to `Function.prototype.call()` in the sense that it calls a function with a given `this` context, however it requires arguments to be provided as an array. For example:\r",
      "\r",
      "```js\r",
      "function printThisAndData(...data) {\r",
      "  console.log(this.data, ...data);\r",
      "}\r",
      "\r",
      "const obj = { data: 0 };\r",
      "const data = [1, 2, 3];\r",
      "\r",
      "printThisAndData.apply(obj, data);      // logs: 0 1 2 3\r",
      "printThisAndData.apply(obj, ...data);   // Throws a TypeError\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Function.prototype.bind() 30-seconds-of-code": {
    "prefix": "hjs Function.prototype.bind() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`Function.prototype.bind()` is slightly different from the previous two methods. Instead of calling a function with the given `this` context and returning the result, it returns a function with its `this` context bound and any arguments provided individually prepended to the arguments at the time of calling the returned function. For example:\r",
      "\r",
      "```js\r",
      "function printThisAndData(...data) {\r",
      "  console.log(this.data, ...data);\r",
      "}\r",
      "\r",
      "const obj = { data: 0 };\r",
      "const data = [1, 2, 3];\r",
      "\r",
      "const printObjAndData = printThisAndData.bind(obj);\r",
      "\r",
      "printObjAndData(data);                  // logs: 0 [1, 2, 3]\r",
      "printObjAndData(...data);               // logs: 0 1 2 3\r",
      "\r",
      "const printObjTwoAndData = printThisAndData.bind(obj, 2);\r",
      "\r",
      "printObjTwoAndData(data);               // logs: 0 2 [1, 2, 3]\r",
      "printObjTwoAndData(...data);            // logs: 0 2 1 2 3\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Generator functions 30-seconds-of-code": {
    "prefix": "hjs Generator functions 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[JavaScript ES6 generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*) allow you to define functions that can be exited and later re-entered, while retaining their context (variable bindings). They are defined using `function*` (`function` keyword followed by an asterisk) and use `yield` expressions to return their result. For example:\r",
      "\r",
      "```js\r",
      "function* generateRange(end, start = 0, step = 1) {\r",
      "  let x = start - step;\r",
      "  while(x < end - step) yield x += step;\r",
      "}\r",
      "\r",
      "const gen5 = generateRange(5);\r",
      "let x = gen5.next();\r",
      "\r",
      "while (!x.done) {\r",
      "  console.log(x.value);\r",
      "  x = gen5.next();\r",
      "} // Logs: 0, 1, 2, 3, 4\r",
      "```\r",
      "\r",
      "In the above example, we define a generator function, `generateRange`, which will return each value between `start` and `end`, incrementing by `step` each time. We use the [generator object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator) to call `Generator.prototype.next()` until it returns `{value: undefined, done: true}` to iterate over the values the generator produces.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Symbol.iterator 30-seconds-of-code": {
    "prefix": "hjs Symbol.iterator 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "[`Symbol.iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator) specifies the default iterator for an object. Oftentimes, `Symbol.iterator` is implemented using a generator function. For example:\r",
      "\r",
      "```js\r",
      "const iterableXx = {\r",
      "  [Symbol.iterator]: function* () {\r",
      "    yield 1;\r",
      "    yield 2;\r",
      "  }\r",
      "};\r",
      "\r",
      "console.log([...iterableX]); // [1, 2]\r",
      "```\r",
      "\r",
      "As you can see in this example, the object is made iterable by assigning a generator function to its `Symbol.iterator` property. This can come especially handy, if you want to iterate over some arbitrary data or create an object that is iterable and uses a generator function under the hood.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Putting it all together 30-seconds-of-code": {
    "prefix": "hjs Putting it all together 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Knowing how both concepts work, we can combine them to create a range generator, similar to Python or Ruby's ranges:\r",
      "\r",
      "```js\r",
      "const range = (end, start = 0, step = 1) => {\r",
      "  function* generateRange() {\r",
      "    let x = start - step;\r",
      "    while(x < end - step) yield x += step;\r",
      "  }\r",
      "  return {\r",
      "    [Symbol.iterator]: generateRange\r",
      "  };\r",
      "}\r",
      "\r",
      "console.log([...range(7)]); // [0, 1, 2, 3, 4, 5, 6]\r",
      "for (let i of range(8, 2, 2)) console.log(i); // Logs: 2, 4, 6\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs String 30-seconds-of-code": {
    "prefix": "hjs String 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "When the spread operator is applied to a string, the result is an array of strings each one representing a character of the original string:\r",
      "\r",
      "```js\r",
      "const name = 'Zelda';\r",
      "const letters = [...name]; // 'Z', 'e', 'l', 'd', 'a'\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Set 30-seconds-of-code": {
    "prefix": "hjs Set 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) is a collection of unique values. When the spread operator is applied to it, the result is an array of the stored values:\r",
      "\r",
      "```js\r",
      "const data = [1, 2, 3, 1, 2, 4]\r",
      "const values = new Set(data);\r",
      "const uniqueValues = [...values]; // [1, 2, 3, 4]\r",
      "```\r",
      "\r",
      "Note that the above example is the basis for the [uniqueElements snippet](/js/s/unique-elements).\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs NodeList 30-seconds-of-code": {
    "prefix": "hjs NodeList 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A [NodeList](https://developer.mozilla.org/en-US/docs/Web/API/NodeList) is a collection of nodes, returned by methods such as `Document.childNodes()` or `Document.querySelectorAll()`. While it implements some methods that help manipulate it as an array (e.g. `NodeList.prototype.forEach()`), it's oftentimes desirable to convert it to an array. When the spread operator is applied to it, the result is an array of the contained nodes:\r",
      "\r",
      "```js\r",
      "const nodes = document.childNodes;\r",
      "const nodeArray = [...nodes]; // [ <!DOCTYPE html>, html ]\r",
      "```\r",
      "\r",
      "Note that the above example is the basis for the [nodeListToArray snippet](/js/s/node-list-to-array).\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Array of keys 30-seconds-of-code": {
    "prefix": "hjs Array of keys 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "An array of keys allows you to pick specific keys to be included in the stringified version of the object. This is particularly useful when you know the exact shape of the serialized object you want.\r",
      "\r",
      "```js\r",
      "const user = {\r",
      "  id: 1234,\r",
      "  username: 'johnsmith',\r",
      "  name: 'John Smith',\r",
      "  age: 39\r",
      "};\r",
      "\r",
      "JSON.stringify(user, ['username', 'name']);\r",
      "// '{ \"username\": \"johnsmith\", \"name\": \"John Smith\" }'\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Replacer function 30-seconds-of-code": {
    "prefix": "hjs Replacer function 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A replacer function is more versatile than an array of keys and takes both the key and value as its arguments. Apart from using it to include or exclude keys, it can also be useful in altering the value of each key in the stringified representation of the object. In order for a key to be included in the output, the replacer function must return a serializable value (string, number, boolean, null or object).\r",
      "\r",
      "```js\r",
      "class Point {\r",
      "  constructor (x, y) {\r",
      "    this.x = x;\r",
      "    this. y = y;\r",
      "  }\r",
      "}\r",
      "\r",
      "const target = {\r",
      "  id: 1234,\r",
      "  location: new Point(10, 20),\r",
      "  name: 'Delivery point',\r",
      "};\r",
      "\r",
      "JSON.stringify(target, (key, value) => {\r",
      "  // Exclude id\r",
      "  if (key === 'id') return undefined;\r",
      "  // Convert location to an array of coordinates\r",
      "  if (value instanceof Point) return [value.x, value.y];\r",
      "  // Return other properties (i.e. name) without modification\r",
      "  return value;\r",
      "});\r",
      "// '{ \"location\": [10, 20], \"name\": \"Delivery point\" }'\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Key types 30-seconds-of-code": {
    "prefix": "hjs Key types 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Object keys are limited to using only strings and symbols. Maps, on the other hand, can use values of any type as their keys, including functions and objects. This can come in handy in many different scenarios, such as memoization and data association.\r",
      "\r",
      "```js\r",
      "const people = [\r",
      "  { id: 1, name: 'John', surname: 'Doe', age: 30 },\r",
      "  { id: 2, name: 'Jane', surname: 'Doe', age: 28 },\r",
      "];\r",
      "\r",
      "const peopleIndex = people.reduce((index, person) => {\r",
      "  index[person.id] = `${person.name} ${person.surname}`;\r",
      "  return index;\r",
      "}, {});\r",
      "// peopleIndex = {\r",
      "//   '1': 'John Doe',\r",
      "//   '2': 'Jane Doe',\r",
      "// }\r",
      "\r",
      "const peopleIndexMap = new Map(\r",
      "  people.map(person => [person, `${person.name} ${person.surname}`])\r",
      ");\r",
      "\r",
      "// peopleIndexMap = Map {\r",
      "//   { id: 1, name: 'John', surname: 'Doe', age: 30 } => 'John Doe',\r",
      "//   { id: 2, name: 'Jane', surname: 'Doe', age: 28 } => 'Jane Doe',\r",
      "// }\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Iteration 30-seconds-of-code": {
    "prefix": "hjs Iteration 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Object iteration is usually accomplished using `Object.keys()`, `Object.values()` or `Object.entries()`. All of these methods are available on Maps as part of their prototype, but they are significantly more efficient. The reason for this is that these Map methods return iterators, which are lazy and only iterate over the keys or values when they are needed. Additionally, Maps expose an iterator, which can be used with `for...of` loops.\r",
      "\r",
      "```js\r",
      "const obj = { a: 1, b: 2, c: 3 };\r",
      "const objEntries = Object.entries(obj);\r",
      "// ['a', 1], ['b', 2], ['c', 3]\r",
      "for (const [key, value] of objEntries)\r",
      "  console.log(`${key}: ${value}`);\r",
      "\r",
      "const map = new Map([['a', 1], ['b', 2], ['c', 3]]);\r",
      "const mapEntries = [...map.entries()]; // Same as [...map]\r",
      "// [['a', 1], ['b', 2], ['c', 3]]\r",
      "for (const [key, value] of map)\r",
      "  console.log(`${key} => ${value}`);\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Comparing the two 30-seconds-of-code": {
    "prefix": "hjs Comparing the two 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The spread operator version is definitely shorter and as readable as the `Array.prototype.concat()` one. Apart from that, the spread operator seems to be slightly faster based on [some benchmarks I have performed](https://jsben.ch/9txyg) (as of **Aug, 2020 on Google Chrome 84** - this might or might not be the case in the future, as new optimizations land in different browsers).\r",
      "\r",
      "However, `Array.prototype.concat()` can deal with non-array values better than the spread operator can, which might be something to consider when merging values that you are not certain are arrays:\r",
      "\r",
      "```js\r",
      "const a = [1, 2, 3];\r",
      "const b = true;\r",
      "const c = 'hi';\r",
      "\r",
      "const spreadAb = [...a, ...b]; // Error: b is not iterable\r",
      "const spreadAc = [...a, ...c]; // [1, 2, 3, 'h', 'i'], wrong result\r",
      "// You should use [...a, b] and [...a, c] instead\r",
      "\r",
      "const concatAb = [].concat(a, b); // [1, 2, 3, true]\r",
      "const concatAb = [].concat(a, c); // [1, 2, 3, 'hi']\r",
      "```\r",
      "\r",
      "As you can see in the above example, the spread operator either throws an error or doesn't output the correct result when passed a non-iterable object. `Array.prototype.concat()` on the other hand has no trouble being passed mixed input.\r",
      "\r",
      "So what's the verdict? Use the spread operator (`...`) whenever you know your inputs are arrays, as it performs better and is easy to read and understand. Favor `Array.prototype.concat()` when you are uncertain of one or more of the inputs and do not want to add additional checks, as it handles those cases more gracefully.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Using the History API 30-seconds-of-code": {
    "prefix": "hjs Using the History API 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The HTML5 [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) is definitely the way to go for modern websites. It accomplishes the task at hand, while also providing additional functionality. You can use either `history.pushState()` or `history.replaceState()` to modify the URL in the browser, depending on your needs:\r",
      "\r",
      "```js\r",
      "// Current URL: https://my-website.com/page_a\r",
      "const nextURL = 'https://my-website.com/page_b';\r",
      "const nextTitle = 'My new page title';\r",
      "const nextState = { additionalInformation: 'Updated the URL with JS' };\r",
      "\r",
      "// This will create a new entry in the browser's history, without reloading\r",
      "window.history.pushState(nextState, nextTitle, nextURL);\r",
      "\r",
      "// This will replace the current entry in the browser's history, without reloading\r",
      "window.history.replaceState(nextState, nextTitle, nextURL);\r",
      "```\r",
      "\r",
      "The arguments for both methods are the same, allowing you to pass a customized serializable `state` object as the first argument, a customized `title` (although most browsers will ignore this parameter) and the `URL` you want to add/replace in the browser's history. Bear in mind that the History API only allows same-origin URLs, so you cannot navigate to an entirely different website.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Using the Location API 30-seconds-of-code": {
    "prefix": "hjs Using the Location API 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The older [Location API](https://developer.mozilla.org/en-US/docs/Web/API/Location) is not the best tool for the job. It reloads the page, but still allows you to modify the current URL and might be useful when working with legacy browsers. You can modify the URL, using either `Window.location.href`, `location.assign()` or `location.replace()`:\r",
      "\r",
      "```js\r",
      "// Current URL: https://my-website.com/page_a\r",
      "const nextURL = 'https://my-website.com/page_b';\r",
      "\r",
      "// This will create a new entry in the browser's history, reloading afterwards\r",
      "window.location.href = nextURL;\r",
      "\r",
      "// This will replace the current entry in the browser's history, reloading afterwards\r",
      "window.location.assign(nextURL);\r",
      "\r",
      "// This will replace the current entry in the browser's history, reloading afterwards\r",
      "window.location.replace(nextURL);\r",
      "```\r",
      "\r",
      "As you can see, all three options will cause a page reload, which can be undesirable. Unlike the History API, you can only set the URL, without any additional arguments. Finally, the Location API doesn't restrict you to same-origin URLs, which can cause security issues if you are not careful.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Named exports 30-seconds-of-code": {
    "prefix": "hjs Named exports 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "/* environment.js */\r",
      "export const key = 'this-is-a-secret';\r",
      "\r",
      "/* index.js */\r",
      "import { key } from 'environment';\r",
      "```\r",
      "\r",
      "- Named exports use a name.\r",
      "- A module can have any number of named exports.\r",
      "- Import and export name should be the same.\r",
      "- Importing requires `{}`.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Default exports 30-seconds-of-code": {
    "prefix": "hjs Default exports 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "/* environment.js */\r",
      "const environment = {\r",
      "  key: 'this-is-a-secret',\r",
      "  port: 8000\r",
      "};\r",
      "\r",
      "export default environment;\r",
      "/* index.js */\r",
      "import environment from 'environment';\r",
      "\r",
      "const { key, port } = environment;\r",
      "```\r",
      "\r",
      "- Default exports expose a default value, use the `default` keyword.\r",
      "- A module can only have one default export.\r",
      "- Import name can be anything.\r",
      "- Importing does not require `{}`.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Default + named 30-seconds-of-code": {
    "prefix": "hjs Default + named 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "/* environment.js */\r",
      "export const envType = 'DEV';\r",
      "\r",
      "const environment = {\r",
      "  key: 'this-is-a-secret',\r",
      "  port: 8000\r",
      "};\r",
      "\r",
      "export default environment;\r",
      "\r",
      "/* index.js */\r",
      "import { envType }, environment from 'environment';\r",
      "\r",
      "const { key, port } = environment;\r",
      "```\r",
      "\r",
      "- Default and named exports can be mixed.\r",
      "- Rules about number of exports and naming conventions apply as before.\r",
      "- Import rules apply as before, can be mixed if necessary.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Export list 30-seconds-of-code": {
    "prefix": "hjs Export list 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "/* environment.js */\r",
      "const key = 'this-is-a-secret';\r",
      "const port = 8000;\r",
      "\r",
      "export {\r",
      "  key,\r",
      "  port\r",
      "};\r",
      "\r",
      "/* index.js */\r",
      "import { key, port } from 'environment';\r",
      "```\r",
      "\r",
      "- An export list is a compact way to write multiple named exports.\r",
      "- Rules about number of exports, naming conventions and import rules are the same as those of named exports.\r",
      "- Export lists are not objects.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Rename export 30-seconds-of-code": {
    "prefix": "hjs Rename export 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "/* environment.js */\r",
      "const key = 'this-is-a-secret';\r",
      "\r",
      "export { key as authKey };\r",
      "\r",
      "/* index.js */\r",
      "import { authKey } from 'environment';\r",
      "```\r",
      "\r",
      "- Named exports can make use of the `as` keyword to rename an export.\r",
      "- Import name should be the same as the renamed export.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Rename import 30-seconds-of-code": {
    "prefix": "hjs Rename import 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "/* environment.js */\r",
      "export const key = 'this-is-a-secret';\r",
      "\r",
      "/* index.js */\r",
      "import { key as authKey } from 'environment';\r",
      "```\r",
      "\r",
      "- Named imports can make use of the `as` keyword to rename an import.\r",
      "- Import name (before the `as` keyword) should be the same as the export.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Import all 30-seconds-of-code": {
    "prefix": "hjs Import all 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "```js\r",
      "/* environment.js */\r",
      "export const envType = 'DEV';\r",
      "\r",
      "const environment = {\r",
      "  key: 'this-is-a-secret',\r",
      "  port: 8000\r",
      "};\r",
      "\r",
      "export default environment;\r",
      "\r",
      "/* index.js */\r",
      "import * as env from 'environment';\r",
      "\r",
      "const { default: { key, port}, envType } = environment;\r",
      "```\r",
      "\r",
      "- Use `*` to import everything a module exports.\r",
      "- Named exports will be available by their names on the imported object.\r",
      "- Default export will be available as the `default` key on the imported object.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Variables 30-seconds-of-code": {
    "prefix": "hjs Variables 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Names are case-sensitive, lowercase and uppercase are different.\r",
      "- Start variable names with a letter, use `camelCase` for names.\r",
      "- Variable names should be self-descriptive, describing the stored value.\r",
      "- Boolean variables are usually prefixed with `is` or `has`.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Functions 30-seconds-of-code": {
    "prefix": "hjs Functions 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Names are case-sensitive, lowercase and uppercase are different.\r",
      "- Start function names with a letter, use `camelCase` for names.\r",
      "- Use descriptive names, usually verbs in the imperative form.\r",
      "- Common prefixes are `get`, `make`, `apply` etc.\r",
      "- Class methods follow the same rules.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Constant 30-seconds-of-code": {
    "prefix": "hjs Constant 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Names are case-sensitive, lowercase and uppercase are different.\r",
      "- Define constants at the top of your file, function or class.\r",
      "- Sometimes `UPPER_SNAKE_CASE` is used, while other times plain `camelCase`.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Classes 30-seconds-of-code": {
    "prefix": "hjs Classes 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Names are case-sensitive, lowercase and uppercase are different.\r",
      "- Start class names with a capital letter, use `PascalCase` for names.\r",
      "- Use descriptive names, explaining the functionality of the class.\r",
      "- Components, which are used in frontend frameworks follow the same rules.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Private 30-seconds-of-code": {
    "prefix": "hjs Private 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Prefix any variable or function with `_` to show intention for it to be private.\r",
      "- As a convention, this will not prevent other parts of the code from accessing it.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Arrays 30-seconds-of-code": {
    "prefix": "hjs Arrays 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "An array is a linear data structure that represents a collection of elements. In JavaScript, arrays don't have a fixed size, while their contents can be of any valid type, even arrays themselves. Arrays are probably the most commonly used data structure and come with a plethora of methods that allow easy manipulation and transformation of their contents.\r",
      "\r",
      "```js\r",
      "const nums = [1, 2, 3];\r",
      "const strs = Array.from('est');\r",
      "\r",
      "nums.push(6);\r",
      "nums.push(4, 9);\r",
      "strs.unshift('t');\r",
      "\r",
      "nums.length;                     // 6\r",
      "nums[nums.length - 1];           // 9\r",
      "strs[0];                         // 't'\r",
      "strs[2];                         // 's'\r",
      "\r",
      "nums.slice(1, 3);                // [2, 3]\r",
      "nums.map(n => n * 2);            // [2, 4, 6, 12, 8, 18]\r",
      "nums.filter(n => n % 2 === 0);   // [2, 6, 4]\r",
      "nums.reduce((a, n) => a + n, 0); // 25\r",
      "\r",
      "strs.reverse();                  // ['t', 's', 'e', 't']\r",
      "strs.join('');                   // 'test'\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Sets 30-seconds-of-code": {
    "prefix": "hjs Sets 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A set is a linear data structure that represents an ordered collection of unique values. Sets in JavaScript can store any valid type of value, however each value can only occur once based on value equality checking.\r",
      "\r",
      "```js\r",
      "const nums = new Set([1, 2, 3]);\r",
      "\r",
      "nums.add(4);\r",
      "nums.add(1);\r",
      "nums.add(5);\r",
      "nums.add(4);\r",
      "\r",
      "nums.size;                       // 5\r",
      "nums.has(4);                     // true\r",
      "\r",
      "nums.delete(4);\r",
      "nums.has(4);                     // false\r",
      "\r",
      "[...nums];                       // [1, 2, 3, 5]\r",
      "\r",
      "nums.clear();\r",
      "nums.size;                       // 0\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Maps 30-seconds-of-code": {
    "prefix": "hjs Maps 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A map is an associative data structure that represents a keyed collection of elements. Each key in a JavaScript Map has to be unique and either a primitive value or an object, whereas the values of the map can be of any valid type.\r",
      "\r",
      "```js\r",
      "const items = new Map([\r",
      "  [1, { name: 'John' }],\r",
      "  [2, { name: 'Mary' }]\r",
      "]);\r",
      "\r",
      "items.set(4, { name: 'Alan' });\r",
      "items.set(2, { name: 'Jeff' });\r",
      "\r",
      "items.size;                      // 3\r",
      "items.has(4);                    // true\r",
      "items.get(2);                    // { name: 'Jeff' }\r",
      "\r",
      "items.delete(2);\r",
      "items.size;                      // 2\r",
      "\r",
      "[...items.keys()];               // [1, 4]\r",
      "[...items.values()];             // [{ name: 'John' }, { name: 'Alan' }]\r",
      "\r",
      "items.clear();\r",
      "items.size;                      // 0\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs A simple static file server 30-seconds-of-code": {
    "prefix": "hjs A simple static file server 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "One of the simplest beginner backend projects you can create is a static file server. In its simplest form, a static file server will listen for requests and try to match the requested URL to a file on the local filesystem. Here's a minimal example of that in action:\r",
      "\r",
      "```js\r",
      "const fs = require('fs');\r",
      "const http = require('http');\r",
      "\r",
      "http.createServer((req, res) => {\r",
      "  fs.readFile(__dirname + req.url, (err, data) => {\r",
      "    if (err) {\r",
      "      res.writeHead(404, { 'Content-Type': 'text/html' });\r",
      "      res.end('404: File not found');\r",
      "    } else {\r",
      "      res.writeHead(200, { 'Content-Type': 'text/html' });\r",
      "      res.end(data);\r",
      "    }\r",
      "  });\r",
      "}).listen(8000);\r",
      "```\r",
      "\r",
      "In this code example, we're using the `fs` module to read the file at `__dirname + req.url`. If the file doesn't exist, we'll return a `404` error. Otherwise, we'll return the file. The `http` module is used to create the server that listens on port `8000`.\r",
      "\r",
      "In theory, one could stop here and have a very basic static file server. However, there are a few considerations that could be taken into account. Let's explore them one by one, and see how we can address them.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Modularity 30-seconds-of-code": {
    "prefix": "hjs Modularity 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "First and foremost, we don't necessarily want to serve files from the same directory as our Node.js server. To address this problem, we would have to change the directory `fs.readFile()` looks for the file in. To accomplish this, we can specify a directory to serve files from and use the `path` module to resolve files from that directory. This way, we can also better handle different operating systems and environments.\r",
      "\r",
      "Here's a short snippet on how to resolve a file path using the `path` module:\r",
      "\r",
      "```js\r",
      "const fs = require('fs');\r",
      "const path = require('path');\r",
      "\r",
      "const directoryName = './public';\r",
      "const requestUrl = 'index.html';\r",
      "\r",
      "const filePath = path.join(directoryName, requestUrl);\r",
      "\r",
      "fs.readFile(filePath, (err, data) => {\r",
      "  // ...\r",
      "});\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Security 30-seconds-of-code": {
    "prefix": "hjs Security 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Our next concern is security. Obviously, we don't want users prying around our machine unauthorized. Currently, it's not impossible to get access to files outside of the specified root directory (e.g. `GET /../../../`). To address this, we can use the `path` module again to check if the requested file is inside the root directory.\r",
      "\r",
      "```js\r",
      "const path = require('path');\r",
      "\r",
      "const directoryName = './public';\r",
      "const root = path.normalize(path.resolve(directoryName));\r",
      "\r",
      "const requestUrl = 'index.html';\r",
      "\r",
      "const filePath = path.join(root, fileName);\r",
      "const isPathUnderRoot = path\r",
      "  .normalize(path.resolve(filePath))\r",
      "  .startsWith(root);\r",
      "```\r",
      "\r",
      "Similarly, we can ensure that users don't get access to sensitive files by checking the file type. For this to work, we can specify an array or object of supported file types and check the file's extension using the `path` module once again.\r",
      "\r",
      "```js\r",
      "const path = require('path');\r",
      "\r",
      "const types = ['html', 'css', 'js', 'json'];\r",
      "\r",
      "const requestUrl = 'index.html';\r",
      "const extension = path.extname(requestUrl).slice(1);\r",
      "\r",
      "const isTypeSupported = types.includes(extension);\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Omitting the HTML extension 30-seconds-of-code": {
    "prefix": "hjs Omitting the HTML extension 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A staple of most websites is the ability to omit the file extension from the URL when requesting an HTML page. It's a small quality of life improvement that users expect and it would be really nice to add to our static file server.\r",
      "\r",
      "This is where things get a little tricky. To provide this functionality, we need to check for missing extensions and look up the appropriate HTML file. Bear in mind, though, that there are two possible matches for a URL such as `/my-page`. This path can either be matched by `/my-page.html` or `my-page/index.html`. To deal with this, we'll prioritize one over the other. In our case, we'll prioritize `/my-page.html` over `my-page/index.html`, but it's pretty easy to swap them the other way round.\r",
      "\r",
      "To implement this, we can use the `fs` module to check if one of them exists and handle things appropriately. A special case would also need to be added for the root url (`/`) to match it to the `index.html` file.\r",
      "\r",
      "```js\r",
      "const fs = require('fs');\r",
      "const path = require('path');\r",
      "\r",
      "const directoryName = './public';\r",
      "const root = path.normalize(path.resolve(directoryName));\r",
      "\r",
      "const extension = path.extname(req.url).slice(1);\r",
      "let fileName = requestUrl;\r",
      "\r",
      "if (requestUrl === '/') fileName = 'index.html';\r",
      "else if (!extension) {\r",
      "  try {\r",
      "    fs.accessSync(path.join(root, requestUrl + '.html'), fs.constants.F_OK);\r",
      "    fileName = requestUrl + '.html';\r",
      "  } catch (e) {\r",
      "    fileName = path.join(requestUrl, 'index.html');\r",
      "  }\r",
      "}\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Final touches 30-seconds-of-code": {
    "prefix": "hjs Final touches 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "After implementing all of the above, we can put everything together to create a static file server with all the functionality we need. I'll throw in a couple of finishing touches, such as logging requests to the console and handling a few more file types, and here's the final product:\r",
      "\r",
      "```js\r",
      "const fs = require('fs');\r",
      "const http = require('http');\r",
      "const path = require('path');\r",
      "\r",
      "const port = 8000;\r",
      "const directoryName = './public';\r",
      "\r",
      "const types = {\r",
      "  html: 'text/html',\r",
      "  css: 'text/css',\r",
      "  js: 'application/javascript',\r",
      "  png: 'image/png',\r",
      "  jpg: 'image/jpeg',\r",
      "  jpeg: 'image/jpeg',\r",
      "  gif: 'image/gif',\r",
      "  json: 'application/json',\r",
      "  xml: 'application/xml',\r",
      "};\r",
      "\r",
      "const root = path.normalize(path.resolve(directoryName));\r",
      "\r",
      "const server = http.createServer((req, res) => {\r",
      "  console.log(`${req.method} ${req.url}`);\r",
      "\r",
      "  const extension = path.extname(req.url).slice(1);\r",
      "  const type = extension ? types[extension] : types.html;\r",
      "  const supportedExtension = Boolean(type);\r",
      "\r",
      "  if (!supportedExtension) {\r",
      "    res.writeHead(404, { 'Content-Type': 'text/html' });\r",
      "    res.end('404: File not found');\r",
      "    return;\r",
      "  }\r",
      "\r",
      "  let fileName = req.url;\r",
      "  if (req.url === '/') fileName = 'index.html';\r",
      "  else if (!extension) {\r",
      "    try {\r",
      "      fs.accessSync(path.join(root, req.url + '.html'), fs.constants.F_OK);\r",
      "      fileName = req.url + '.html';\r",
      "    } catch (e) {\r",
      "      fileName = path.join(req.url, 'index.html');\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const filePath = path.join(root, fileName);\r",
      "  const isPathUnderRoot = path\r",
      "    .normalize(path.resolve(filePath))\r",
      "    .startsWith(root);\r",
      "\r",
      "  if (!isPathUnderRoot) {\r",
      "    res.writeHead(404, { 'Content-Type': 'text/html' });\r",
      "    res.end('404: File not found');\r",
      "    return;\r",
      "  }\r",
      "\r",
      "  fs.readFile(filePath, (err, data) => {\r",
      "    if (err) {\r",
      "      res.writeHead(404, { 'Content-Type': 'text/html' });\r",
      "      res.end('404: File not found');\r",
      "    } else {\r",
      "      res.writeHead(200, { 'Content-Type': type });\r",
      "      res.end(data);\r",
      "    }\r",
      "  });\r",
      "});\r",
      "\r",
      "server.listen(port, () => {\r",
      "  console.log(`Server is listening on port ${port}`);\r",
      "});\r",
      "```\r",
      "\r",
      "Not too bad, right? In just 70 lines of code, we managed to create a pretty decent static file server without using anything but core Node.js APIs.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Optional chaining 30-seconds-of-code": {
    "prefix": "hjs Optional chaining 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The [optional chaining operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining) (`?.`) allows us to access deeply nested object properties without having to validate each reference in the nesting chain. In case of a reference being nullish (`null` or `undefined`) the optional chaining operator will short-circuit, returning `undefined`. The optional chaining operator can also be used with function calls, returning `undefined` if the given function does not exist.\r",
      "\r",
      "The resulting code is shorter and simpler, as you can see below:\r",
      "\r",
      "```js\r",
      "const data = getDataFromMyAPI();\r",
      "\r",
      "// Without optional chaining\r",
      "const userName = data && data.user && data.user.name;\r",
      "const userType = data && data.user && data.user.type;\r",
      "data && data.showNotifications && data.showNotifications();\r",
      "\r",
      "// With optional chaining\r",
      "const userName = data?.user?.name;\r",
      "const userType = data?.user?.type;\r",
      "data.showNotifications?.();\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Nullish coalescing 30-seconds-of-code": {
    "prefix": "hjs Nullish coalescing 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "In the same spirit, the [nullish coalescing operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator) (`??`) is a logical operator that allows us to check for nullish (`null` or `undefined`) values, returning the right-hand side operand when the value is non-nullish, otherwise returning the left-hand side operand.\r",
      "\r",
      "Apart from cleaner code, this operator might spare us some headaches related to falsy values:\r",
      "\r",
      "```js\r",
      "const config = getServerConfig();\r",
      "\r",
      "// Without nullish coalescing\r",
      "const port = config.server.port || 8888;\r",
      "// Oops! This will be true even if we pass it false\r",
      "const wrongkeepAlive = config.server.keepAlive || true;\r",
      "// We'll have to explicitly check for nullish values\r",
      "const keepAlive =\r",
      "  (config.server.keepAlive !== null & config.server.keepAlive !== undefined)\r",
      "  ? config.server.keepAlive : true;\r",
      "\r",
      "// With nullish coalescing\r",
      "const port = config.server.port ?? 8888;\r",
      "// This works correctly\r",
      "const keepAlive = config.server.keepAlive ?? true;\r",
      "```\r",
      "\r",
      "**Note:** Keep in mind that both features are quite new, so their support might not be great just yet (around 80% at the time of writing [[1]](https://caniuse.com/#feat=mdn-javascript_operators_optional_chaining)[[2]](https://caniuse.com/#feat=mdn-javascript_operators_nullish_coalescing)).\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Deep equality comparison 30-seconds-of-code": {
    "prefix": "hjs Deep equality comparison 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "As it turns out, comparing two objects is not trivial. This is the reason why shallow or deep equality comparison helper functions are so common. These usually use recursion to deeply compare two objects, accounting for most scenarios such as empty values, special types and nesting.\r",
      "\r",
      "```js\r",
      "const equals = (a, b) => {\r",
      "  if (a === b) return true;\r",
      "  if (a instanceof Date && b instanceof Date)\r",
      "    return a.getTime() === b.getTime();\r",
      "  if (!a || !b || (typeof a !== 'object' && typeof b !== 'object'))\r",
      "    return a === b;\r",
      "  if (a.prototype !== b.prototype) return false;\r",
      "  const keys = Object.keys(a);\r",
      "  if (keys.length !== Object.keys(b).length) return false;\r",
      "  return keys.every(k => equals(a[k], b[k]));\r",
      "};\r",
      "\r",
      "const a = { name: 'John', age: 26 };\r",
      "const b = { name: 'John', age: 26 };\r",
      "\r",
      "equals(a, b); // true\r",
      "\r",
      "const c = { name: 'John' };\r",
      "const d = { name: 'John', age: undefined };\r",
      "\r",
      "equals(c, d); // false\r",
      "```\r",
      "\r",
      "The above helper function handles all of these issues and is explained in more depth in the [equals snippet](/js/s/equals).\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Anchors 30-seconds-of-code": {
    "prefix": "hjs Anchors 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- `^`: start of the string or the start of a line in a multiline pattern\r",
      "- `$`: end of the string or the end of a line in a multiline pattern\r",
      "- `\\b`: word boundary\r",
      "- `\\B`: not word boundary (opposite of `\\b`)\r",
      "\r",
      "Note: Anchors are non-quantifiable (i.e. cannot be followed by a quantifier).\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Character sequences 30-seconds-of-code": {
    "prefix": "hjs Character sequences 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- `.`: any character except line breaks\r",
      "- `\\w`: any word character\r",
      "- `\\W`: any non-word character (opposite of `\\w`)\r",
      "- `\\s`: any whitespace character\r",
      "- `\\S`: any non-whitespace character (opposite of `\\s`)\r",
      "- `\\d`: any digit character\r",
      "- `\\D`: any non-digit character (opposite of `\\d`)\r",
      "- `[abc]`: a single character in the given set (here `a`, `b` or `c`)\r",
      "- `[^abc]`: a single character not in the given set (opposite of `[abc]`)\r",
      "- `[a-z]`: a single character in the given range (here between `a` and `z` inclusive)\r",
      "- `[^a-z]`: a single character not in the given range (opposite of `[a-z]`)\r",
      "- `[a-zA-Z]`: a single character in either of the given ranges\r",
      "\r",
      "Note: Use `\\` to escape special characters (e.g. `\\`, `/`, `[`, `]`, `(`, `)`, `{`, `}` etc.).\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Quantifiers 30-seconds-of-code": {
    "prefix": "hjs Quantifiers 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- `a?`: zero or one of `a` (equal to `a{0,1}`)\r",
      "- `a*`: zero or more of `a` (equal to `a{0,}`)\r",
      "- `a+`: one or more of `a` (equal to `a{1,}`)\r",
      "- `a{3}`: exactly 3 of `a`\r",
      "- `a{3,}`: 3 or more of `a`\r",
      "- `a{3,5}`: between 3 and 5 of `a` (inclusive)\r",
      "\r",
      "Note: `a` is any valid quantifiable expression.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Groups 30-seconds-of-code": {
    "prefix": "hjs Groups 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- `(ab)`: match and capture everything enclosed (here exactly `ab`)\r",
      "- `(a|b)`: match and capture either one character (here `a` or `b`)\r",
      "- `(?:ab)`: match everything enclosed, without capturing\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Flags 30-seconds-of-code": {
    "prefix": "hjs Flags 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- `g`: Global\r",
      "- `m`: Multiline\r",
      "- `i`: Case insensitive\r",
      "- `u`: Unicode\r",
      "\r",
      "Note that this cheatsheet is meant only as a starting point and is by no means a complete guide to all the features and nuances of regular expressions. You can also read [6 JavaScript Regular Expression features you can use today](/blog/s/6-javascript-regexp-tricks) for a deeper dive into some more advanced features.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs The short answer 30-seconds-of-code": {
    "prefix": "hjs The short answer 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Most often than not, `window.location.reload()` is all you need to reload the current page. This method behaves exactly like the **browser's reload button**, using the same cache rules and everything.\r",
      "\r",
      "```js\r",
      "// Reload the page\r",
      "window.location.reload();\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs The slightly longer answer 30-seconds-of-code": {
    "prefix": "hjs The slightly longer answer 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "While `window.location.reload()` is the most common way to reload a page, there are some nuances that you might need to be aware of.\r",
      "\r",
      "As stated already, compatibility shouldn't be an issue, so we're not going to delve into that. However, there's a notable oddity concerning the method's arguments. As it turns out, **Firefox** used to support an optional `forceGet` boolean argument, which you might come across in older code. This means that passing a value of `true` to the method would bypass the **browser's cache**.\r",
      "\r",
      "```js\r",
      "// Bypass cache in Firefox\r",
      "window.location.reload(true);\r",
      "```\r",
      "\r",
      "Apart from that, `window.location.reload()` will reload the page **keeping POST data** in forms, which might not be desired. In those situations, you might want to assign `window.location.href` to itself to cause a reload. This will cause the page to reload, but will also clear the POST data.\r",
      "\r",
      "```js\r",
      "// Clear POST data\r",
      "window.location.href = window.location.href;\r",
      "```\r",
      "\r",
      "This technique also comes with some caveats. For example, if the current **URL contains a hash**, the page won't reload. In this case, you might want to use `String.prototype.split()` to remove the hash from the URL and then assign it to itself.\r",
      "\r",
      "```js\r",
      "// Reload the page, removing the hash from the URL\r",
      "window.location.href = window.location.href.split('#')[0];\r",
      "```\r",
      "\r",
      "As you can see, each technique has its pros and cons, so you should choose the one that best suits your needs. That being said, `window.location.reload()` is the most common and reliable way to reload a page, so it's the one you should use most of the time.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Alternative options 30-seconds-of-code": {
    "prefix": "hjs Alternative options 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The previous two options should cover the vast majority of use cases. Yet, there are some other options available for removing elements from an array, which might be preferable in certain cases. For example, if you like the interface of `Array.prototype.splice()` but need immutability, the [shank snippet](/js/s/shank) might be the solution for you. Similarly, when working with large unsorted arrays, there's a [fast removal trick](/js/s/fast-remove-array-element) that might be of interest to you.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Set the property to undefined 30-seconds-of-code": {
    "prefix": "hjs Set the property to undefined 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Setting a property to `undefined` isn't generally optimal, as the property itself will still be present in the object, albeit `undefined`. It also mutates the original object, which might be undesired. You might want to use this in cases where you check for the property's value or truthiness but not its presence.\r",
      "\r",
      "```js\r",
      "const pet = {\r",
      "  species: 'dog',\r",
      "  age: 3,\r",
      "  name: 'celeste',\r",
      "  gender: 'female'\r",
      "};\r",
      "\r",
      "pet.gender = undefined;\r",
      "Object.keys(pet); // ['species', 'age', 'name', 'gender']\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Use the delete operator 30-seconds-of-code": {
    "prefix": "hjs Use the delete operator 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The `delete` operator is technically the correct way to remove a property from a JavaScript object. Unlike the previous option, `delete` will completely remove the property from the object, but it will still cause a mutation.\r",
      "\r",
      "```js\r",
      "const pet = {\r",
      "  species: 'dog',\r",
      "  age: 3,\r",
      "  name: 'celeste',\r",
      "  gender: 'female'\r",
      "};\r",
      "\r",
      "delete pet.gender;\r",
      "Object.keys(pet); // ['species', 'age', 'name']\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Use object destructuring 30-seconds-of-code": {
    "prefix": "hjs Use object destructuring 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Using the spread syntax, (`...`), you can destructure and assign the object with specific properties omitted to a new object. This trick comes in handy especially if you want to remove a subset of properties instead of just one and has the added benefit of not mutating the original object.\r",
      "\r",
      "```js\r",
      "const pet = {\r",
      "  species: 'dog',\r",
      "  age: 3,\r",
      "  name: 'celeste',\r",
      "  gender: 'female'\r",
      "};\r",
      "\r",
      "const { gender, ...newPet } = pet;\r",
      "Object.keys(pet); // ['species', 'age', 'name', 'gender]\r",
      "Object.keys(newPet); // ['species', 'age', 'name']\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Regular expression 30-seconds-of-code": {
    "prefix": "hjs Regular expression 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Provided that the number is converted to a fixed-point string, you can use a regular expression to remove trailing zeros. All you have to do is match the decimal point (`\\.`) and replace any zeros after it (`0+`) until the end of the string (`$`).\r",
      "\r",
      "```js\r",
      "const toFixedWithoutZeros = (num, precision) =>\r",
      "  num.toFixed(precision).replace(/\\.0+$/, '');\r",
      "\r",
      "toFixedWithoutZeros(1.001, 2); // '1'\r",
      "toFixedWithoutZeros(1.500, 2); // '1.50'\r",
      "```\r",
      "\r",
      "The main issue with this approach is that the regular expression will only remove trailing zeros if the decimal part has no other digits before them. Writing a regular expression to remove trailing zeros from any number is a bit more involved and gets harder to read. Thus, this approach is discouraged.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Multiply by 1 30-seconds-of-code": {
    "prefix": "hjs Multiply by 1 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A better way to remove trailing zeros is to multiply by `1`. This method will remove trailing zeros from the decimal part of the number, accounting for non-zero digits after the decimal point. The only downside is that the result is a numeric value, so it has to be converted back to a string.\r",
      "\r",
      "```js\r",
      "const toFixedWithoutZeros = (num, precision) =>\r",
      "  `${1 * num.toFixed(precision)}`;\r",
      "\r",
      "toFixedWithoutZeros(1.001, 2); // '1'\r",
      "toFixedWithoutZeros(1.500, 2); // '1.5'\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Number.parseFloat 30-seconds-of-code": {
    "prefix": "hjs Number.parseFloat 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Similar to the previous approach, you can use `Number.parseFloat()` to remove trailing zeros from a number. This method also accounts for non-zero digits after the decimal point. We recommend this approach as it's the most readable.\r",
      "\r",
      "```js\r",
      "const toFixedWithoutZeros = (num, precision) =>\r",
      "  `${Number.parseFloat(num.toFixed(precision))}`;\r",
      "\r",
      "toFixedWithoutZeros(1.001, 2); // '1'\r",
      "toFixedWithoutZeros(1.500, 2); // '1.5'\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs String.prototype.replaceAll() 30-seconds-of-code": {
    "prefix": "hjs String.prototype.replaceAll() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Modern JavaScript engines have a built-in method called `String.prototype.replaceAll()`. This method can be used to replace all occurrences of a string in another string with relative ease.\r",
      "\r",
      "```js\r",
      "const str = 'Hello World';\r",
      "\r",
      "str.replaceAll('o', 'x'); // 'Hellx Wxrld'\r",
      "```\r",
      "\r",
      "Using `String.prototype.replaceAll()` is the recommended approach, as it's straightforward. If, however, you need to support older browsers, consider the option below.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs String.prototype.replace() 30-seconds-of-code": {
    "prefix": "hjs String.prototype.replace() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Before the introduction of `String.prototype.replaceAll()`, `String.prototype.replace()` was the method of choice for this sort of task. It's supported by all JavaScript engines, old and new and is very similar to `String.prototype.replaceAll()`.\r",
      "\r",
      "While this method doesn't replace all occurrences of a string, it supports regular expressions. Knowing the string to be replaced, a regular expression can be created with the global (`'g'`) flag. Then, it can be passed to `String.prototype.replace()` to replace all occurrences of the string. The only issue here is that special characters need to be escaped, so that they are matched correctly. The [escapeRegExp snippet](/js/s/escape-reg-exp) comes in handy for this task.\r",
      "\r",
      "```js\r",
      "const escapeRegExp = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r",
      "const replaceAll = (str, subStr, newSubStr) =>\r",
      "  str.replace(new RegExp(escapeRegExp(subStr), 'g'), newSubStr);\r",
      "\r",
      "const str = 'Hello World';\r",
      "\r",
      "replaceAll(str, 'o', 'x'); // 'Hellx Wxrld'\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs SemVer versions 30-seconds-of-code": {
    "prefix": "hjs SemVer versions 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "SemVer versions are formatted in **three numeric components**, as follows:\r",
      "\r",
      "```\r",
      "{major}.{minor}.{patch}\r",
      "```\r",
      "\r",
      "Each component represents a specific type of change made to the software.\r",
      "\r",
      "- **Major version**: Significant changes that may **break compatibility** with previous versions. Developers should carefully review the documentation and test their code against the new version before upgrading.\r",
      "- **Minor version**: Backwards-compatible **additions or improvements** that don't break compatibility with previous versions. Users can typically upgrade to a new minor version without worrying about major changes that might require code modifications.\r",
      "- **Patch version**: Backwards-compatible **bug fixes, patches, or maintenance** releases. Patch releases are intended to be safe and shouldn't introduce new features or breaking changes.\r",
      "\r",
      "The following table summarizes the different types of changes represented by each component:\r",
      "\r",
      "| Component | Type of change | Example |\r",
      "| --------- | -------------- | ------- |\r",
      "| Major     | Incompatible   | Breaking changes, rewrites, architectural changes |\r",
      "| Minor     | Compatible     | New features, functionalities, enhancements |\r",
      "| Patch     | Compatible     | Bug fixes, patches, maintenance releases |\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Releases and pre-releases 30-seconds-of-code": {
    "prefix": "hjs Releases and pre-releases 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The **first version** of a software package is typically denoted as `1.0.0`. This is because the initial release of a software package is considered to be a major version, and the first version of a major version is always `1.0.0`. Versions starting with `0.x.x` are considered to be pre-release versions and are not intended for production use.\r",
      "\r",
      "Additionally, SemVer allows for **pre-release versions** to be appended to the version number. These are denoted by a hyphen followed by a series of alphanumeric identifiers, such as `1.0.0-alpha.1` or `1.0.0-beta.2`. Pre-release versions are typically used to indicate that the software is still under active development and may not be ready for production use.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Specifying which version to use 30-seconds-of-code": {
    "prefix": "hjs Specifying which version to use 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "When installing a package, you can specify which version to use by appending the version number to the package name, as follows:\r",
      "\r",
      "```shell\r",
      "npm install my-package@1.0.0\r",
      "```\r",
      "\r",
      "If you don't specify a version, npm will install the **latest version** of the package. You can also use the `^` or `~` symbols to specify a range of versions. For example, `^1.0.0` will install the latest version of the package that is compatible with `1.0.0`. Similarly, `~1.0.0` will install the latest version of the package that is compatible with `1.0.0` and has the same major version. Here's a quick summary of the different ways to specify a version:\r",
      "\r",
      "- Exact version: `1.0.4`\r",
      "- Patch releases: `1.0` or `1.0.x` or `~1.0.4`\r",
      "- Minor releases: `1` or `1.x` or `^1.0.4`\r",
      "\r",
      "Note that you can also change the version of each dependency by editing the `package.json` file directly. Just remember to run `npm install` after making any changes to the `package.json` file.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs setTimeout 30-seconds-of-code": {
    "prefix": "hjs setTimeout 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "JavaScript's `setTimeout()` sets a timer which executes some code once the timer expires. Only the code inside the `setTimeout()` callback will execute after the timer expires. This can lead to nesting issues, as well as code executing out of order if you are not careful.\r",
      "\r",
      "```js\r",
      "const printNums = () => {\r",
      "  console.log(1);\r",
      "  setTimeout(() => console.log(2), 500);\r",
      "  console.log(3);\r",
      "};\r",
      "\r",
      "printNums(); // Logs: 1, 3, 2 (2 logs after 500ms)\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Synchronous version 30-seconds-of-code": {
    "prefix": "hjs Synchronous version 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "While strongly discouraged, `Date.prototype.getTime()` can be used inside a `while` loop to pause execution for a set amount of time. You can easily define a synchronous `sleep()` function like this:\r",
      "\r",
      "```js\r",
      "const sleepSync = (ms) => {\r",
      "  const end = new Date().getTime() + ms;\r",
      "  while (new Date().getTime() < end) { /* do nothing */ }\r",
      "}\r",
      "\r",
      "const printNums = () => {\r",
      "  console.log(1);\r",
      "  sleepSync(500);\r",
      "  console.log(2);\r",
      "  console.log(3);\r",
      "};\r",
      "\r",
      "printNums(); // Logs: 1, 2, 3 (2 and 3 log after 500ms)\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Asynchronous version 30-seconds-of-code": {
    "prefix": "hjs Asynchronous version 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A less intrusive way to go about implementing a `sleep()` function is to utilize the `async` and `await` keywords added in JavaScript ES6, a `Promise` and `setTimeout()`. Note that the resulting function must be executed in an `async` function and has to be called with `await`:\r",
      "\r",
      "```js\r",
      "const sleep = (ms) =>\r",
      "  new Promise(resolve => setTimeout(resolve, ms));\r",
      "\r",
      "const printNums = async() => {\r",
      "  console.log(1);\r",
      "  await sleep(500);\r",
      "  console.log(2);\r",
      "  console.log(3);\r",
      "};\r",
      "\r",
      "printNums(); // Logs: 1, 2, 3 (2 and 3 log after 500ms)\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Clone an array 30-seconds-of-code": {
    "prefix": "hjs Clone an array 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The spread operator can be used to clone an array into a new array. This trick can come in handy when working with arrays of primitives. However, it only shallow clones the array, meaning nested non-primitive values will not be cloned.\r",
      "\r",
      "```js\r",
      "const arr = [1, 2, 3];\r",
      "const arr2 = [...arr];\r",
      "// [1, 2, 3]\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Merge multiple arrays 30-seconds-of-code": {
    "prefix": "hjs Merge multiple arrays 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Using the spread operator, it’s possible to combine two or more arrays into one. You should think of this trick as cloning two arrays into a new one. Due to that, the shallow cloning limitation mentioned previously applies here, too.\r",
      "\r",
      "```js\r",
      "const arr1 = [1, 2, 3];\r",
      "const arr2 = [4, 5, 6];\r",
      "const combined = [...arr1, ...arr2];\r",
      "// [1, 2, 3, 4, 5, 6]\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Add items to an array 30-seconds-of-code": {
    "prefix": "hjs Add items to an array 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Similarly to previous tricks, it’s possible to spread an array into a new one and add individual elements, too. This can also be combined with merging multiple arrays, if desired.\r",
      "\r",
      "```js\r",
      "const arr = [1, 2, 3];\r",
      "const arr2 = [0, ...arr, 4];\r",
      "// [0, 1, 2, 3, 4]\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Spread syntax 30-seconds-of-code": {
    "prefix": "hjs Spread syntax 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The spread operator (`...`) allows you to expand a single array into its values. Some common use-cases for the spread operator include:\r",
      "\r",
      "- Expanding an array's values to pass them as arguments to a function that does not accept an array.\r",
      "- Cloning an array by spreading its values into a new array (`[]`).\r",
      "- Concatenating arrays by spreading them into a new array (`[]`).\r",
      "- Flattening an array of arrays one level, by spreading nested arrays.\r",
      "- Converting a non-array iterable (e.g. a string or a `Set`) to an array.\r",
      "\r",
      "```js\r",
      "// Array's values as arguments\r",
      "const a = [1, 2, 3];\r",
      "Math.max(...a); // 3\r",
      "\r",
      "// Clone an array\r",
      "const b = [4, 5, 6];\r",
      "const c = [...b]; // c = [4, 5, 6], b !== c\r",
      "\r",
      "// Concatenate two arrays\r",
      "const d = [...a, ...b]; // d = [1, 2, 3, 4, 5, 6]\r",
      "\r",
      "// Flatten an array\r",
      "const e = [[1, 2], [3, 4]];\r",
      "const f = [...e[0], ...e[1]]; // f = [1, 2, 3, 4]\r",
      "\r",
      "// Convert iterable to array\r",
      "const g = [...'hello']; // g = ['h', 'e', 'l', 'l', 'o']\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Rest syntax 30-seconds-of-code": {
    "prefix": "hjs Rest syntax 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The rest parameter syntax allows you to collapse any remaining arguments into an array. While it looks very similar to the spread operator, the rest parameter syntax is only used in function declarations (arrow or otherwise).\r",
      "\r",
      "```js\r",
      "// Rest parameter syntax, not to be confused with the spread operator\r",
      "const fn = (str, ...nums) => `${str}_${nums.join('')}`;\r",
      "fn('hi', 1, 2, 3); // 'hi_123', `nums` will be [1, 2, 3]\r",
      "\r",
      "const data = [4, 5, 6];\r",
      "// Spread operator, expanding the array\r",
      "fn('hey', ...data); // 'hey_456', `nums` will be [4, 5, 6]\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs String.prototype.includes() 30-seconds-of-code": {
    "prefix": "hjs String.prototype.includes() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The most straightforward substring search option is `String.prototype.includes()`, introduced in ES6. It's a simple method that returns a boolean value depending on whether the string contains the substring or not.\r",
      "\r",
      "```js\r",
      "const str = 'Hello world';\r",
      "str.includes('world'); // true\r",
      "str.includes('foo'); // false\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs String.prototype.indexOf() 30-seconds-of-code": {
    "prefix": "hjs String.prototype.indexOf() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Another option is `String.prototype.indexOf()`, which can be preferable if you need to support legacy browsers. As this methods returns the index of the first occurrence of the substring, you need to compare it to `-1` to know if the substring was found or not.\r",
      "\r",
      "```js\r",
      "const str = 'Hello world';\r",
      "str.indexOf('world') !== -1; // true\r",
      "str.indexOf('foo') !== -1; // false\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Case-insensitive substring search 30-seconds-of-code": {
    "prefix": "hjs Case-insensitive substring search 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Both methods presented so far are case-sensitive. If you need to search for a substring that is case-insensitive, you can use `String.prototype.toLowerCase()` to convert both strings to lowercase. Then you can compare them, using any of the previous methods.\r",
      "\r",
      "```js\r",
      "const str = 'Hello world';\r",
      "const token = 'WORLD';\r",
      "str.toLowerCase().includes(token.toLowerCase()); // true\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Similarities 30-seconds-of-code": {
    "prefix": "hjs Similarities 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "I think it's helpful to identify the similarities of these two properties before diving into the differences. This will also clarify how they're used in most cases.\r",
      "\r",
      "Suppose you have an HTML element, containing some text:\r",
      "\r",
      "```html\r",
      "<p id=\"greeting\">Hi there! My name is <strong>Bubbles</strong>.</p>\r",
      "```\r",
      "\r",
      "Both of these properties will return the text content of the element, including the text content of any **child elements**. They will also **ignore any HTML tags** that may be present in the element's content. And, they can be used to **set the text content** of the element, too.\r",
      "\r",
      "```js\r",
      "const greeting = document.getElementById('greeting');\r",
      "\r",
      "greeting.innerText; // \"Hi there! My name is Bubbles.\"\r",
      "greeting.textContent; // \"Hi there! My name is Bubbles.\"\r",
      "\r",
      "greeting.innerText = 'Hello!'; // <p id=\"greeting\">Hello!</p>\r",
      "greeting.textContent = 'Hi!'; // <p id=\"greeting\">Hi!</p>\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Differences 30-seconds-of-code": {
    "prefix": "hjs Differences 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "So far, these two properties appear to do the exact same thing. In fact, they both offer some convenient features that make them very useful. However, they start to exhibit some differences when the element's content is a little more complex.\r",
      "\r",
      "Take the following HTML element, for example:\r",
      "\r",
      "```html\r",
      "<div class=\"card\">\r",
      "  <style>\r",
      "    p { color: red; }\r",
      "    strong { text-transform: uppercase; }\r",
      "    small { display: none; }\r",
      "  </style>\r",
      "  <p>Hi   there!<br />My name is <strong>Bubbles</strong>.</p>\r",
      "  <small>And I'm a <strong>dog</strong>.</small>\r",
      "</div>\r",
      "```\r",
      "\r",
      "Let's take a look at the output of each of these two properties and see how they differ.\r",
      "\r",
      "```js\r",
      "const card = document.querySelector('.card');\r",
      "\r",
      "card.innerText;\r",
      "/*\r",
      "\"Hi there!\r",
      "My name is BUBBLES.\"\r",
      "*/\r",
      "\r",
      "card.textContent;\r",
      "/*\r",
      "\"\r",
      "\r",
      "    p { color: red; }\r",
      "    strong { text-transform: uppercase; }\r",
      "    small { display: none; }\r",
      "\r",
      "  Hi   there!My name is Bubbles.\r",
      "  And I'm a dog.\r",
      "\"\r",
      "*/\r",
      "```\r",
      "\r",
      "It's drastically different in this case, right? `HTMLElement.innerText` is supposed to roughly **match what the user sees** in the browser. Another way to think of this is that its output should closely resemble what the user would get if they were to select the element's content and copy it to their clipboard.\r",
      "\r",
      "The first thing to notice, based on this definition, is that **hidden elements are ignored**. This applies to elements that don't render, such as `<style>` and `<script>`, but also to elements that are hidden using CSS. In this example, the `<small>` element is hidden, so it's not included in the output of `HTMLElement.innerText`.\r",
      "\r",
      "Secondly, the output of `HTMLElement.innerText` is **normalized**. This means that all whitespace is collapsed into a single space, and all line breaks are replaced with a single line break. If present, `<br>` tags are also respected, so they're replaced with a line break.\r",
      "\r",
      "The final point I want to make is that `HTMLElement.innerText` applies **text transformations** to the element's content. In this case, the `<strong>` element is transformed to uppercase, so the output of `HTMLElement.innerText` reflects this.\r",
      "\r",
      "On the other hand, `Node.textContent` returns the **exact text content** of the element, including any whitespace and line breaks. Yet, `<br>` tags are stripped without any sort of replacement. It also includes the text content of any hidden elements, such as `<style>` and `<script>` and no text transformations are applied.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Performance 30-seconds-of-code": {
    "prefix": "hjs Performance 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "But, wait! There's more! While `HTMLElement.innerText` seems like the sensible choice, it comes with a performance caveat. In order to figure out what the browser renders, CSS has to be considered, triggering a [reflow](https://developer.mozilla.org/en-US/docs/Glossary/Reflow). This can be **computationally expensive**, and can create inadvertent performance bottlenecks.\r",
      "\r",
      "In my opinion, a good rule of thumb is to prefer `Node.textContent` for plain text elements, if possible. For more complex elements, try identifying how they're affected by layout and user interactions. For example, a complex element that's rendered only once and never altered, would be a use case for `HTMLElement.innerText`, but you can store the output in a variable and reuse it.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs What is `this`? 30-seconds-of-code": {
    "prefix": "hjs What is `this`? 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "In JavaScript, the `this` keyword refers to the object that is currently executing the code. The short version of what `this` evaluates to is as follows:\r",
      "\r",
      "- By default, `this` refers to the global object.\r",
      "- In a function, when not in strict mode, `this` refers to the global object.\r",
      "- In a function, when in strict mode, `this` is `undefined`.\r",
      "- In an arrow function, `this` retains the value of the enclosing lexical context's `this`.\r",
      "- In an object method, `this` refers to the object the method was called on.\r",
      "- In a constructor call, `this` is bound to the new object being constructed.\r",
      "- In an event handler, `this` is bound to the element on which the listener is placed.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Global context 30-seconds-of-code": {
    "prefix": "hjs Global context 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "In the global execution context, `this` refers to the global object.\r",
      "\r",
      "```js\r",
      "console.log(this === window); // true\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Function context 30-seconds-of-code": {
    "prefix": "hjs Function context 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "When not in strict mode, a function's `this` refers to the global object.\r",
      "\r",
      "```js\r",
      "function f() {\r",
      "  return this;\r",
      "}\r",
      "\r",
      "console.log(f() === window); // true\r",
      "```\r",
      "\r",
      "When in strict mode, a function's `this` will be `undefined` if not set when entering the execution context.\r",
      "\r",
      "```js\r",
      "'use strict';\r",
      "\r",
      "function f() {\r",
      "  return this;\r",
      "}\r",
      "\r",
      "console.log(f()); // undefined\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Object context 30-seconds-of-code": {
    "prefix": "hjs Object context 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "When a function is called as a method of an object, `this` refers to the object the method is called on. This applies to methods defined anywhere in the object's prototype chain (i.e. own and inherited methods).\r",
      "\r",
      "```js\r",
      "const obj = {\r",
      "  f: function() {\r",
      "    return this;\r",
      "  }\r",
      "};\r",
      "\r",
      "const myObj = Object.create(obj);\r",
      "myObj.foo = 1;\r",
      "\r",
      "console.log(myObj.f()); // { foo: 1 }\r",
      "```\r",
      "\r",
      "Similarly, when used inside a constructor, `this` refers to the object being constructed.\r",
      "\r",
      "```js\r",
      "class C {\r",
      "  constructor() {\r",
      "    this.x = 10;\r",
      "  }\r",
      "}\r",
      "\r",
      "const obj = new C();\r",
      "console.log(obj.x); // 10\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Arrow function context 30-seconds-of-code": {
    "prefix": "hjs Arrow function context 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "In arrow functions, `this` retains the value of the enclosing lexical context's `this`.\r",
      "\r",
      "```js\r",
      "const f = () => this;\r",
      "\r",
      "console.log(f() === window); // true\r",
      "\r",
      "const obj = {\r",
      "  foo: function() {\r",
      "    const baz = () => this;\r",
      "    return baz();\r",
      "  },\r",
      "  bar: () => this\r",
      "};\r",
      "\r",
      "console.log(obj.foo()); // { foo, bar }\r",
      "console.log(obj.bar() === window); // true\r",
      "```\r",
      "\r",
      "Notice how in the second example, an arrow function's `this` refers to the global object unless wrapped inside a regular `function` call, whose `this` refers to the object it's called from and its lexical context is retained by the arrow function.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Event handler context 30-seconds-of-code": {
    "prefix": "hjs Event handler context 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "When used in an event handler, `this` refers to the element on which the listener is placed.\r",
      "\r",
      "```js\r",
      "const el = document.getElementById('my-el');\r",
      "\r",
      "el.addEventListener('click', function() {\r",
      "  console.log(this === el); // true\r",
      "});\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Binding `this` 30-seconds-of-code": {
    "prefix": "hjs Binding `this` 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Using `Function.prototype.bind()` returns a new function from an existing one, where `this` is permanently bound to the first argument of `bind()`.\r",
      "\r",
      "```js\r",
      "function f() {\r",
      "  return this.foo;\r",
      "}\r",
      "\r",
      "var x = f.bind({foo: 'hello'});\r",
      "console.log(x()); // 'hello'\r",
      "```\r",
      "\r",
      "Similarly, using `Function.prototype.call()` or `Function.prototype.apply()` will bind the called function's `this` to the first argument of either of these functions only for this call.\r",
      "\r",
      "```js\r",
      "function f() {\r",
      "  return this.foo;\r",
      "}\r",
      "\r",
      "console.log(f.call({foo: 'hi'})); // 'hi'\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Delays are not exact 30-seconds-of-code": {
    "prefix": "hjs Delays are not exact 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "I went into detail about how JavaScript engines execute code in [the Event Loop explanation](/js/s/event-loop-explained), but let me recap here. As JavaScript is single-threaded, tasks are queued to be executed in a loop. Thus, `setTimeout()` and `setInterval()` are tasks that will be executed after at least the given amount of time has elapsed. There is no guarantee, however, that the task will be executed exactly after the given amount of time has elapsed. The delay is a suggestion, signifying the **minimum amount of time** that must pass before the task is executed. The actual delay can be longer, depending on the current state of the JavaScript engine.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Browser factors 30-seconds-of-code": {
    "prefix": "hjs Browser factors 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Apart from engine-related delays, there are a few other factors that play a role in the actual delay of a task. Briefly, these are:\r",
      "\r",
      "- Browsers **throttle nested timeouts and intervals** with a delay of at least 4ms, but this can vary depending on the browser.\r",
      "- Timeouts and intervals in **inactive/background tabs are throttled** to a minimum of 1000ms to increase battery life.\r",
      "- **Known tracking scripts in background tabs** can be throttled even further after a certain amount of time.\r",
      "\r",
      "On a side note, some browsers store delays as a 32-bit signed integer, meaning that delays over 24.8 days will cause an overflow and execute immediately.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs undeclared 30-seconds-of-code": {
    "prefix": "hjs undeclared 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A variable is undeclared if it has not been declared with an appropriate keyword (i.e. `var`, `let` or `const`). Accessing an undeclared variable will throw a `ReferenceError`.\r",
      "\r",
      "```js\r",
      "console.log(x); // ReferenceError: x is not defined\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs undefined 30-seconds-of-code": {
    "prefix": "hjs undefined 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A variable is `undefined` if it hasn't been assigned a value. `undefined` is a primitive data type in JavaScript and represents the absence of a value, intentional or otherwise.\r",
      "\r",
      "```js\r",
      "let x;\r",
      "console.log(x); // undefined\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs null 30-seconds-of-code": {
    "prefix": "hjs null 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A variable is assigned a value of `null` like any other value. `null` is also primitive data type in JavaScript and always represents the intentional absence of a value.\r",
      "\r",
      "```js\r",
      "let x = null;\r",
      "console.log(x); // null\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Checking for empty states 30-seconds-of-code": {
    "prefix": "hjs Checking for empty states 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Undeclared variables will throw an error, which makes them easy to spot and are not very common anyways. `undefined` and `null` can be easily spotted with a conditional as they are both falsy values. Due to that, `null` and `undefined` are loosely equal (`==`), but not strictly equal (`===`).\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs No accidental global variables 30-seconds-of-code": {
    "prefix": "hjs No accidental global variables 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Strict mode makes it impossible to accidentally create global variables due to mistyped variable names. Assignments, which would accidentally create global variables, instead throw an error in strict mode:\r",
      "\r",
      "```js\r",
      "'use strict';\r",
      "myVariable = 42;\r",
      "// The above line will throw a ReferenceError, assuming no global\r",
      "// variable named myVariable has been declared previously\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Elimination of silent errors 30-seconds-of-code": {
    "prefix": "hjs Elimination of silent errors 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Strict mode changes some previously-accepted mistakes into errors. These include:\r",
      "\r",
      "- Assignments which would otherwise silently fail\r",
      "- Deleting undeletable properties or plain names\r",
      "- Duplicated names in function arguments\r",
      "- 0-prefixed octal literals\r",
      "- Setting properties on primitives\r",
      "\r",
      "```js\r",
      "'use strict';\r",
      "\r",
      "let undefined = 5; // TypeError (non-writable global)\r",
      "let obj = {};\r",
      "Object.defineProperty(obj1, 'x', { value: 1, writable: false });\r",
      "obj.x = 2; // TypeError (non-writable property);\r",
      "\r",
      "delete Object.prototype; // TypeError (undeletable property)\r",
      "delete something; // SyntaxError (plain name)\r",
      "\r",
      "const sum (a, b, b) { // SyntaxError (duplicated argument name)\r",
      "  return a + b + b;\r",
      "}\r",
      "\r",
      "const x = 012; // SyntaxError (0-prefixed octal literal)\r",
      "\r",
      "false.true = 10; // TypeError (property on primitive)\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Simplified `eval` 30-seconds-of-code": {
    "prefix": "hjs Simplified `eval` 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Strict mode makes `eval` more transparent by preventing the introduction of new variables in the surrounding scope. In strict mode, `eval` creates variables only for the code being evaluated.\r",
      "\r",
      "```js\r",
      "'use strict';\r",
      "let x = 1;\r",
      "eval('let x = 3; console.log(x);'); // LOGS: 3\r",
      "console.log(x); // LOGS: 1\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Simplified `arguments` 30-seconds-of-code": {
    "prefix": "hjs Simplified `arguments` 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Strict mode simplifies `arguments`, by removing some of their side effects. `arguments` aren't aliased, thus they always refer to the original arguments when the function was invoked. Moreover, `arguments.callee` and `arguments.caller` are no longer supported.\r",
      "\r",
      "```js\r",
      "'use strict';\r",
      "function f(x) {\r",
      "  x = 5;\r",
      "  return x === arguments[0];\r",
      "}\r",
      "\r",
      "f(10); // false\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs No `this` boxing 30-seconds-of-code": {
    "prefix": "hjs No `this` boxing 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Strict mode makes JavaScript more secure, by restricting access the global object via `this`. In strict mode, `this` is not boxed (forced into being an object), meaning that if unspecified it will be `undefined` instead of the global object.\r",
      "\r",
      "```js\r",
      "'use strict';\r",
      "function f() {\r",
      "  return this;\r",
      "}\r",
      "\r",
      "f(); // undefined\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Other changes 30-seconds-of-code": {
    "prefix": "hjs Other changes 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Strict mode implements a few more, less commonly-mentioned changes. These include:\r",
      "\r",
      "- `with` is prohibited, resulting in an error if used\r",
      "- `Function.prototype.arguments` and `Function.prototype.caller` are non-deletable properties which throw when set or retrieved\r",
      "- `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`, and `yield` are reserved keywords\r",
      "- Function statements are only allowed at the top level of a script of function\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Scope 30-seconds-of-code": {
    "prefix": "hjs Scope 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "When we talk about scope, we mean the visibility of one or more entities (e.g variables) to certain parts of our code. There are two types of scopes: global and local. Local scope can in turn be separated into block, function and other types of more specific scopes.\r",
      "\r",
      "**Global scope**: Variables defined globally (i.e. not inside a block or function) are part of the global scope and can be accessed from anywhere in the code. When declared in the global scope, `var`, `let` and `const` behave the same in terms of scope.\r",
      "\r",
      "**Local scope**: Variables defined inside a block or function can only be accessed from the block or function where they were defined, as well as nested local scopes. When declared inside a block scope, `var` will be available but `undefined` in outer scopes, while `let` and `const` will not exist in outer scopes. When declared inside a function scope, `var`, `let` and `const` will all be non-existent in outer scopes.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Hoisting 30-seconds-of-code": {
    "prefix": "hjs Hoisting 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "While variables declared with `var` are hoisted to the enclosing scope, variables declared with `let` or `const` are not initialized until their definition is evaluated.\r",
      "\r",
      "```js\r",
      "const hoistingExample = () => {\r",
      "  console.log(a); // undefined\r",
      "  var a = 'var';\r",
      "  console.log(a); // 'var'\r",
      "\r",
      "  console.log(b); // ReferenceError\r",
      "  let b = 'let';\r",
      "  console.log(b); // 'let'\r",
      "};\r",
      "```\r",
      "\r",
      "If you want to learn more, we have [an article covering JavaScript hoisting in more depth](/js/s/variable-hoisting).\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Global object property 30-seconds-of-code": {
    "prefix": "hjs Global object property 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "At the top level, variables declared with `var`, unlike ones declared with `let` or `const`, create a property on the global object.\r",
      "\r",
      "```js\r",
      "var a = 'var';\r",
      "let b = 'let';\r",
      "\r",
      "console.log(window.a); // 'var'\r",
      "console.log(window.b); // undefined\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Redeclaration 30-seconds-of-code": {
    "prefix": "hjs Redeclaration 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "In strict mode, variables declared with `var` can be re-declared in the same scope, whereas this is not allowed for variables declared with `let` or `const`.\r",
      "\r",
      "```js\r",
      "'use strict';\r",
      "var a = 'var1';\r",
      "var a = 'var2';\r",
      "\r",
      "let b = 'let1';\r",
      "let b = 'let2'; // SyntaxError\r",
      "```\r",
      "\r",
      "If you want to learn more, we have [an article covering JavaScript's strict mode in more depth](/js/s/use-strict).\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs function 30-seconds-of-code": {
    "prefix": "hjs function 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "When using `function` declarations, the function can be called before it's defined and it will work as expected. For example:\r",
      "\r",
      "```js\r",
      "hello(); // logs 'Hello world!'\r",
      "\r",
      "function hello() {\r",
      "  console.log('Hello world!');\r",
      "}\r",
      "\r",
      "hello(); // logs 'Hello world!'\r",
      "```\r",
      "\r",
      "In the example above the `function` declaration is hoisted to the top of its scope and, due to the nature of function declarations, it's available before it's declared. However, this is the only case that behaves this way.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs var 30-seconds-of-code": {
    "prefix": "hjs var 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "`var` declarations on the other hand behave differently, returning `undefined` when accessed before initialization. For example:\r",
      "\r",
      "```js\r",
      "console.log(x); // logs 'undefined'\r",
      "f(); // throws 'Uncaught TypeError: f is not a function'\r",
      "\r",
      "var x = 1;\r",
      "var f = () => 'Hi!';\r",
      "\r",
      "console.log(x); // logs '1'\r",
      "f(); // returns 'Hi!'\r",
      "```\r",
      "\r",
      "As you can see in this example, the `var` declarations are hoisted to the top of their scope, but their values are not initialized until the code that initializes them executes, thus being `undefined` up until that point.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs const and let 30-seconds-of-code": {
    "prefix": "hjs const and let 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Finally, `const` and `let` declarations are hoisted, but they are not initialized to `undefined`. Instead, they will give you an error, which is also how `class` declarations behave. For example:\r",
      "\r",
      "```js\r",
      "console.log(y); // throws 'Uncaught ReferenceError: Cannot access \"y\" before initialization'\r",
      "g();  // throws 'Uncaught ReferenceError: Cannot access \"g\" before initialization'\r",
      "\r",
      "let y = 2;\r",
      "const g = () => 'Hey!';\r",
      "\r",
      "console.log(y); // logs '2'\r",
      "f(); // returns 'Hey!'\r",
      "```\r",
      "\r",
      "Generally, `const` and `let` provide more of a headache-free experience for a variety of reasons and this is no exception. Where accessing variables declared with `var` before initialization fails silently, doing the same for `const` or `let` results in a clear, easy to debug error.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Best practices 30-seconds-of-code": {
    "prefix": "hjs Best practices 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- Always define variables, functions, objects and classes before using them. ESLint can probably help you with that.\r",
      "- If your environment/team allows it, prefer `const` and `let`over `var` to minimize headaches.\r",
      "- If possible, use only arrow functions or `function` declarations. Consistency can help reduce confusion.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs Variable definition 30-seconds-of-code": {
    "prefix": "hjs Variable definition 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "JavaScript provides two ways to define a variable (`var` and `let`) and one way to define a constant value (`const`).\r",
      "\r",
      "`let` and `const` behave the same in terms of scope, both being block scoped (see below). On the other hand, `var` behaves differently by being function scoped (see below), meaning `var` declarations inside a block scope will also be available to the nearest outer function block.\r",
      "\r",
      "It is generally preferred to use `let` and `const` to avoid confusion when it comes to scoping. However, it is important to note that `var` can be a useful JavaScript feature when used in the correct circumstances.\r",
      "\r",
      "![Visualization of JavaScript variable scope](./illustrations/js-variable-scope.png)\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs window.location.protocol 30-seconds-of-code": {
    "prefix": "hjs window.location.protocol 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The protocol schema of the URL (usually `http:` or `https:`)\r",
      "- Sample value: `https:`\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs window.location.hostname 30-seconds-of-code": {
    "prefix": "hjs window.location.hostname 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The domain name of the URL\r",
      "- Sample value: `dev.30secondsofcode.org`\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs window.location.port 30-seconds-of-code": {
    "prefix": "hjs window.location.port 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The port number of the URL\r",
      "- Sample value: `8000`\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs window.location.host 30-seconds-of-code": {
    "prefix": "hjs window.location.host 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The domain name and port number of the URL\r",
      "- Sample value: `dev.30secondsofcode.org:8000`\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs window.location.origin 30-seconds-of-code": {
    "prefix": "hjs window.location.origin 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The protocol schema, domain name and port number of the URL\r",
      "- Sample value: `https://dev.30secondsofcode.org:8000`\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs window.location.pathname 30-seconds-of-code": {
    "prefix": "hjs window.location.pathname 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The path of the URL, including the leading slash\r",
      "- Sample value: `/c/js`\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs window.location.search 30-seconds-of-code": {
    "prefix": "hjs window.location.search 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The query string of the URL, including the leading question mark\r",
      "- Sample value: `?page=2&sort=asc`\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs window.location.hash 30-seconds-of-code": {
    "prefix": "hjs window.location.hash 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The fragment identifier of the URL, including the leading hash\r",
      "- Sample value: `#search`\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hjs window.location.href 30-seconds-of-code": {
    "prefix": "hjs window.location.href 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- The full URL, including the protocol schema, domain name, port number, path, query string and fragment identifier\r",
      "- Sample value: `https://dev.30secondsofcode.org:8000/c/js?page=2&sort=asc#search`\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  }
}