{
  "hreact PropTypes.shape() 30-seconds-of-code": {
    "prefix": "hreact PropTypes.shape() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The `PropTypes.shape()` validator can be used when describing an object whose keys are known ahead of time, and may represent different types. For example:\r",
      "\r",
      "```js\r",
      "import PropTypes from 'prop-types';\r",
      "// Expected prop object - keys known ahead of time\r",
      "const myProp = {\r",
      "  name: 'John',\r",
      "  surname: 'Smith',\r",
      "  age: 27\r",
      "};\r",
      "// PropTypes validation for the prop object\r",
      "MyComponent.propTypes = {\r",
      "  myProp: PropTypes.shape({\r",
      "    name: PropTypes.string,\r",
      "    surname: PropTypes.string,\r",
      "    age: PropTypes.number\r",
      "  })\r",
      "};\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact PropTypes.objectOf() 30-seconds-of-code": {
    "prefix": "hreact PropTypes.objectOf() 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "The `PropTypes.objectOf()` validator is used when describing an object whose keys might not be known ahead of time, and often represent the same type. For example:\r",
      "\r",
      "```js\r",
      "import PropTypes from 'prop-types';\r",
      "// Expected prop object - dynamic keys (i.e. user ids)\r",
      "const myProp = {\r",
      "  25891102: 'johnsmith',\r",
      "  34712915: 'ducklord',\r",
      "  76912999: 'mrquacks'\r",
      "};\r",
      "// PropTypes validation for the prop object\r",
      "MyComponent.propTypes = {\r",
      "  myProp: PropTypes.objectOf(PropTypes.number)\r",
      "};\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Identifying the problems 30-seconds-of-code": {
    "prefix": "hreact Identifying the problems 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "While the code in the example is not that complicated right now, complexity can increase very fast as more action types need to be handled by our application. This is due to the fact that each `action.type`'s logic is nested inside the `reducer` function, thus adding more code and complexity with each new action.\r",
      "\r",
      "Another issue we can identify is that each `action` has a different structure, which increases cognitive load for future maintainers, as they have to remember what keys their `action` needs to have. There's also the added issue of running into a case where `action.type` might be needed to pass actual data to the state (i.e. `state.type` could exist).\r",
      "\r",
      "Finally, our `action.type` values are hardcoded inside the `reducer` function, making it hard to remember and sync across other files and components. This might seem like the least of our problems, but it's probably the easiest one to fix, so let's start there.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Define action types 30-seconds-of-code": {
    "prefix": "hreact Define action types 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Starting with removing the hardcoded strings for each of the `action.type` values, we can make the code more maintainable and easier to read by extracting them to an object:\r",
      "\r",
      "```js\r",
      "const ACTION_TYPES = {\r",
      "  CREATE_ID: 'createID',\r",
      "  SET_NAME: 'setName',\r",
      "  ADD_PROPERTY: 'addProperty',\r",
      "  REMOVE_PROPERTY: 'removeProperty'\r",
      "};\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Create a common action structure 30-seconds-of-code": {
    "prefix": "hreact Create a common action structure 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Our `action` objects aren't consistent in terms of structure with the exception of sharing a `type` key which we use to identify each action. If we hope to reduce mental strain and minimize headaches, we should make these more consistent. The easiest way to do so would be to put the whole action `payload` under a top-level key and nest any values passed to the action inside it:\r",
      "\r",
      "```js\r",
      "// Structure of any action passed to our reducer function\r",
      "const action = {\r",
      "  // Any of the previously defined action types\r",
      "  type: ACTION_TYPES.CREATE_ID,\r",
      "  // Nest name, propertyValue and propertyKey inside this object\r",
      "  payload: { /* ... */ }\r",
      "}\r",
      "```\r",
      "\r",
      "If you plug it into the previous code right away, it might seem counter-intuitive at first, but bear with me for a minute. It will all come together soon.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Extract nested logic 30-seconds-of-code": {
    "prefix": "hreact Extract nested logic 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Finally, we are ready to implement the most drastic fix which the previous two changes will help us facilitate - extracting nested logic. The first issue we identified was that each `action.type`'s logic was nested inside the `reducer` function. We can fix that by moving each `case` into its own function:\r",
      "\r",
      "```js\r",
      "const createID = state => ({\r",
      "  ...state,\r",
      "  id: generateID(),\r",
      "});\r",
      "\r",
      "const setName = (state, { name }) => ({\r",
      "  ...state,\r",
      "  name,\r",
      "});\r",
      "\r",
      "const addProperty = (state, { propertyName, propertyValue }) => ({\r",
      "  ...state,\r",
      "  [propertyName]: propertyValue,\r",
      "});\r",
      "\r",
      "const removeProperty = (state, { propertyName }) => {\r",
      "  const properties = Object.keys(state.properties).reduce((acc, key) => {\r",
      "    if (key !== propertyName) acc[key] = state.properties[key];\r",
      "    return acc;\r",
      "  }, {});\r",
      "  return { ...state, properties };\r",
      "};\r",
      "```\r",
      "\r",
      "Each function has a single responsibility. Any complexity associated with each `action.type` is now part of a function responsible for that specific action type. Testing these smaller functions is a lot easier now, as they are focused on a single task, instead of being nested into a larger, more complex `reducer`.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Putting it all together 30-seconds-of-code": {
    "prefix": "hreact Putting it all together 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Having implemented the above changes, let's take a look at what our final code looks like:\r",
      "\r",
      "```js\r",
      "const initialState = {\r",
      "  id: null,\r",
      "  name: '',\r",
      "  properties: {},\r",
      "};\r",
      "\r",
      "const ACTION_TYPES = {\r",
      "  CREATE_ID: 'createID',\r",
      "  SET_NAME: 'setName',\r",
      "  ADD_PROPERTY: 'addProperty',\r",
      "  REMOVE_PROPERTY: 'removeProperty'\r",
      "};\r",
      "\r",
      "const generateID = () => Math.floor(Math.random() * 1000);\r",
      "\r",
      "const createID = state => ({\r",
      "  ...state,\r",
      "  id: generateID(),\r",
      "});\r",
      "\r",
      "const setName = (state, { name }) => ({\r",
      "  ...state,\r",
      "  name,\r",
      "});\r",
      "\r",
      "const addProperty = (state, { propertyName, propertyValue }) => ({\r",
      "  ...state,\r",
      "  [propertyName]: propertyValue,\r",
      "});\r",
      "\r",
      "const removeProperty = (state, { propertyName }) => {\r",
      "  const properties = Object.keys(state.properties).reduce((acc, key) => {\r",
      "    if (key !== propertyName) acc[key] = state.properties[key];\r",
      "    return acc;\r",
      "  }, {});\r",
      "  return { ...state, properties };\r",
      "};\r",
      "\r",
      "const reducer = (state = initialState, action) => {\r",
      "  switch (action.type) {\r",
      "    case TYPES.CREATE_ID:\r",
      "      return createId(state, action.payload);\r",
      "    case TYPES.SET_NAME:\r",
      "      return setName(state, action.payload);\r",
      "    case TYPES.ADD_PROPERTY:\r",
      "      return addProperty(state, action.payload);\r",
      "    case TYPES.REMOVE_PROPERTY:\r",
      "      return removeProperty(state, action.payload);\r",
      "    default:\r",
      "      return state;\r",
      "  }\r",
      "};\r",
      "```\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact React rendering 30-seconds-of-code": {
    "prefix": "hreact React rendering 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- [React rendering basics](/blog/s/react-rendering-basics)\r",
      "- [React rendering optimization](/blog/s/react-rendering-optimization)\r",
      "- React rendering state (this blog post)\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Rendering introduction 30-seconds-of-code": {
    "prefix": "hreact Rendering introduction 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "**Rendering** is the process during which React moves down the component tree starting at the root, looking for all the components flagged for update, asking them to describe their desired UI structure based on the current combination of `props` and `state`. For each flagged component, React will call its `render()` method (for class components) or `FunctionComponent()` (for function components), and save the output produced after converting the JSX result into a plain JS object, using `React.createElement()`.\r",
      "\r",
      "After collecting the render output from the entire component tree, React will diff the new tree (the **virtual DOM**) with the current DOM tree and collect the list of changes that need to be made to the DOM to produce the desired UI structure. After this process, known as **reconciliation**, React applies all the calculated changes to the DOM.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Render and commit phases 30-seconds-of-code": {
    "prefix": "hreact Render and commit phases 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Conceptually, this work is divided into two phases:\r",
      "\r",
      "- **Render phase**: rendering components, calculating changes\r",
      "- **Commit phase**: applying the changes to the DOM\r",
      "\r",
      "After the **commit phase** is complete, React will run `componentDidMount` and `componentDidUpdate` lifecycle methods, as well as `useLayoutEffect()` and, after a short timeout, `useEffect()` hooks.\r",
      "\r",
      "Two key takeaways here are the following:\r",
      "\r",
      "- Rendering is not the same as updating the DOM\r",
      "- A component may be rendered without any visible changes\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Rendering reasons 30-seconds-of-code": {
    "prefix": "hreact Rendering reasons 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "After the initial render has completed, there are a few different things that will cause a re-render:\r",
      "\r",
      "- `this.setState()` (class components)\r",
      "- `this.forceUpdate()` (class components)\r",
      "- `useState()` setters (function components)\r",
      "- `useReducer()` dispatches (function components)\r",
      "- `ReactDOM.render()` again (on the root component)\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Rendering behavior 30-seconds-of-code": {
    "prefix": "hreact Rendering behavior 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "React's default behavior is to **recursively render all child components inside of it when a parent component is rendered**. This means that it does not care if a component's `props` have changed - as long as the parent component rendered, its children will render unconditionally.\r",
      "\r",
      "To put this another way, calling `setState()` in the root component without any other changes, will cause React to re-render every single component in the component tree. Most likely, most of the components will return the exact same render output as the last render, meaning React will not have to make any changes to the DOM, but the rendering and diffing calculations will be performed regardless, taking time and effort.\r",
      "\r",
      "[Continue on React rendering optimization](/blog/s/react-rendering-optimization)\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Optimization opportunities 30-seconds-of-code": {
    "prefix": "hreact Optimization opportunities 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "As we've seen in the [previous blog post](/blog/s/react-rendering-basics), **rendering** is React's way of knowing if it needs to make changes in the DOM, but there are certain cases where work and calculations performed during the **render phase** can be a wasted effort. After all, if a component's render output is identical, there will be no DOM updates, thus the work wasn't necessary.\r",
      "\r",
      "Render output should always be based on the current combination of `props` and `state`, so it is possible to know ahead of time if a component's render output will be the same so long as its `props` and `state` remain unchanged. This is the key observation on top of which optimizing React rendering is based, as it hinges on our code doing less work and skipping component rendering when possible.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Optimization techniques 30-seconds-of-code": {
    "prefix": "hreact Optimization techniques 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "React offers a handful of APIs that allow us to optimize the rendering process:\r",
      "\r",
      "- `shouldComponentUpdate` (class components): Lifecycle method, called before rendering, returning a boolean (`false` to skip rendering, `true` to proceed as usual). Logic can vary as necessary, but the most common case is checking if the component's `props` and `state` have changed.\r",
      "- `React.PureComponent` (class components): Base class that implements the previously described `props` and `state` change check in its `shouldComponentUpdate` lifecycle method.\r",
      "- `React.memo()` (any component): Higher-order component (HOC) that wraps any given component. It implements the same kind of functionality as `React.PureComponent`, but can also wrap function components.\r",
      "\r",
      "All of these techniques use **shallow equality** for comparisons. Skipping rendering a component means skipping the default recursive behavior of rendering children, effectively skipping the whole subtree of components.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Reference memoization 30-seconds-of-code": {
    "prefix": "hreact Reference memoization 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Passing new references as `props` to a child component doesn't usually matter, as it will re-render regardless when the parent changes. However, if you are trying to optimize a child component's rendering by checking if its `props` have changed, passing new references will cause a render. This behavior is ok if the new references are updated data, but if it's a new reference to the same callback function passed down by the parent, it's rather problematic.\r",
      "\r",
      "This is less of an issue in class components, as they have instance methods whose references don't change, although any sort of generated callbacks passed down to a component's children can result in new references. As far as function components are concerned, React provides the `useMemo()` hook for memoizing values, and the `useCallback()` hook specifically for memoizing callbacks.\r",
      "\r",
      "`useMemo()` and `useCallback()` can provide performance benefits but, as with any other memoization usage, it's important to think about their necessity and the net benefit they provide in the long run. A good rule of thumb is to consider using them for pure functional components that re-render often with the same `props` and/or might do heavy calculations and avoid them elsewhere.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Performance measurement 30-seconds-of-code": {
    "prefix": "hreact Performance measurement 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "**React Developer Tools** provide a handy **Profiler** tab that allows you to visualize and explore the rendering process of your React applications. Under this tab, you will find a settings icon which will allow you to _Highlight updates when components render_, as well as _Record why each component rendered while profiling_ - I highly suggest ticking both of them. Recording the initial render and re-renders of the website can provide invaluable insights about the application's bottlenecks and issues and also highlight optimization opportunities (often using one of the techniques described above).\r",
      "\r",
      "Finally, remember that React's development builds are significantly slower than production builds, so take all the measurements you see with a grain of salt as absolute times in development are not a valuable metric. Identifying unnecessary renders, memoization and optimization opportunities, as well as potential bottlenecks is where you should focus.\r",
      "\r",
      "[Continue on React rendering state](/blog/s/react-rendering-state)\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Context API 30-seconds-of-code": {
    "prefix": "hreact Context API 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "React's **Context API** provides a way to pass data through the component tree without using `props`, but should not be used for state management as it requires manual updating. Any component inside a context's `Provider` can access the data in the context instance using a `Consumer` component or, for function components only, the `useContext()` hook.\r",
      "\r",
      "When a new reference is passed to a context `Provider` it will cause any connected components to update. React will look for any components consuming the context in the component tree and update them to reflect the change in the context's value. Passing a new object to a context `Provider` is essentially a new reference, as the context holds a single value (in this case an object).\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Context optimization 30-seconds-of-code": {
    "prefix": "hreact Context optimization 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "By default, any update to a parent component that renders a context `Provider` will cause all of the child components to re-render regardless of changes in the context, due to React's rendering process. To avoid re-rendering child components when a parent changes, **memoization** can be used, which will cause React to skip the whole subtree of a skipped component.\r",
      "\r",
      "When the context is updated, React additionally checks for components consuming the context down the subtree. This allows context-consuming components under a memoized parent that does not re-render to consume the updated context and render as necessary. After a context-consuming component re-renders, React will keep on recursively rendering its child components as usual.\r",
      "\r",
      "Oftentimes, it's a good idea to memoize the component immediately under a context `Provider`. That way updates to the parent component will not cause a re-render for the whole subtree, but only the components that consume the context.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact React-Redux 30-seconds-of-code": {
    "prefix": "hreact React-Redux 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "React-Redux provides bindings for **Redux**, a state container for JavaScript applications, and works a little differently from React's Context API. One of the key differences is that React-Redux only re-renders components that need to render, due to the fact that components subscribed to the Redux store read the latest store state, diff the values and force re-render only if the relevant data has changed, while React is not involved at all in the subscription callback process.\r",
      "\r",
      "While this most likely means that fewer components will have to re-render compared to using a context, React-Redux always executes its `mapStateToProps` and `useSelector` functions for every connected component in the tree whenever the store state is updated. These calculations are usually less expensive than React's rendering, but if there are costly calculations performed or new references returned when they shouldn't, it might become problematic.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact React-Redux optimization 30-seconds-of-code": {
    "prefix": "hreact React-Redux optimization 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "React-Redux provides two ways of connecting to its store, performing the necessary work and returning the combined `props`:\r",
      "\r",
      "- `connect` (any component): Higher-order component (HOC) that wraps any given component\r",
      "- `useSelector` (function components): Hook called inside function components\r",
      "\r",
      "`connect` acts a lot like memoizing a React component (i.e. using `React.PureComponent` or `React.memo()`), updating the wrapped component only when the combined `props` have changed. This means that passing new references from the parent or the passed functions will still cause a re-render. Components wrapped with `connect` usually read smaller pieces of data from the store state, are less likely to re-render due to that and usually affect fewer components down their tree.\r",
      "\r",
      "On the other hand, `useSelector` has no way of stopping a component from rendering when its parent component renders. When exclusively using `useSelector`, larger parts of the component tree will re-render due to Redux store updates than they would with `connect`, since there aren't other components using `connect` to prevent them from doing so. You can use `React.memo()` as necessary, to optimize this behavior by preventing unnecessary re-rendering.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Adding selected to an option 30-seconds-of-code": {
    "prefix": "hreact Adding selected to an option 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "A very common way of setting a `<select>` input's value is by adding a `selected` attribute to one of its `<option>` elements. For example:\r",
      "\r",
      "```jsx\r",
      "const Select = ({ values, callback, selected }) => {\r",
      "  return (\r",
      "    <select\r",
      "      disabled={disabled}\r",
      "      readOnly={readonly}\r",
      "      onChange={({ target: { value } }) => callback(value)}\r",
      "    >\r",
      "      {values.map(([value, text]) => (\r",
      "        <option selected={selected === value} value={value}>\r",
      "          {text}\r",
      "        </option>\r",
      "      ))}\r",
      "    </select>\r",
      "  );\r",
      "}\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Setting value for the select 30-seconds-of-code": {
    "prefix": "hreact Setting value for the select 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "While this approach closely resembles HTML and feels intuitive, there is an easier way to do the same thing. [React](https://reactjs.org/docs/forms.html#the-select-tag) provides us with a shared API between `<input type=\"text\">`, `<textarea>` and `<select>` where we can use `value` or `defaultValue` (depending if the input is controlled or not) to set the field's value.\r",
      "\r",
      "Using this API, we minimize the effort of checking for the selected value, as well as making the code easier to read and update as necessary. Here's an example:\r",
      "\r",
      "```jsx\r",
      "const Select = ({ values, callback, selected }) => {\r",
      "  return (\r",
      "    <select\r",
      "      disabled={disabled}\r",
      "      readOnly={readonly}\r",
      "      defaultValue={selected}\r",
      "      onChange={({ target: { value } }) => callback(value)}\r",
      "    >\r",
      "      {values.map(([value, text]) => (\r",
      "        <option value={value}>\r",
      "          {text}\r",
      "        </option>\r",
      "      ))}\r",
      "    </select>\r",
      "  );\r",
      "}\r",
      "```\r",
      "\r",
      "Note that the above implementation uses `defaultValue`, therefore it implies that the component is uncontrolled. You can convert this `Select` component into a controlled component by using `value` instead of `defaultValue`.\r",
      "\r",
      "For a more detailed explanation of the component, as well as usage examples, you can check out the [Select component](/react/s/select).\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Components that update asynchronously 30-seconds-of-code": {
    "prefix": "hreact Components that update asynchronously 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Recently, while working on a side-project, we started using the [React DnD library](https://react-dnd.github.io/react-dnd), as we wanted to implement a multi-container drag and drop system with cards.\r",
      "\r",
      "After spending the better part of a day implementing the functionality, we decided to add some tests to ensure everything will keep working as expected. In the aforementioned project, we use [React Testing Library](https://testing-library.com/docs/react-testing-library/intro) to write tests for our components.\r",
      "\r",
      "While testing the drag functionality, we came across a very stubborn test. Here's a simplified version of our `Card` component:\r",
      "\r",
      "```jsx\r",
      "import React from 'react';\r",
      "import { useDrag } from 'react-dnd';\r",
      "\r",
      "const Card = ({\r",
      "  card: {\r",
      "    id,\r",
      "    title\r",
      "  }\r",
      "}) => {\r",
      "  const [style, drag] = useDrag({\r",
      "    item: { id, type: 'card' },\r",
      "    collect: monitor => ({\r",
      "      opacity: monitor.isDragging() ? 0 : 1\r",
      "    })\r",
      "  });\r",
      "\r",
      "  return (\r",
      "    <li className=\"card\" id={id} ref={drag} style={style}>\r",
      "      {title}\r",
      "    </li>\r",
      "  );\r",
      "};\r",
      "```\r",
      "\r",
      "And here's the test we were trying to write originally:\r",
      "\r",
      "```jsx\r",
      "import React from 'react';\r",
      "import { fireEvent } from '@testing-library/react';\r",
      "import Card from './components/Card';\r",
      "// This a little helper we have written to connect to redux and react-dnd\r",
      "import renderDndConnected from './test_utils/renderDndConnected';\r",
      "\r",
      "describe('<Card/>', () => {\r",
      "  let card;\r",
      "\r",
      "  beforeEach(() => {\r",
      "    const utils = renderDndConnected(\r",
      "      <Card card={{ id: '1', title: 'Card' }} />\r",
      "    );\r",
      "    card = utils.container.querySelector('.card');\r",
      "  });\r",
      "\r",
      "  it('initial opacity is 1', () => {\r",
      "    expect(card.style.opacity).toEqual('1');\r",
      "  });\r",
      "\r",
      "  describe('when drag starts', () => {\r",
      "    beforeEach(() => {\r",
      "      fireEvent.dragStart(card);\r",
      "    });\r",
      "\r",
      "    it('opacity is 0', () => {\r",
      "      expect(card.style.opacity).toEqual('0');\r",
      "    });\r",
      "  });\r",
      "});\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact The dreaded `act(...)` warning 30-seconds-of-code": {
    "prefix": "hreact The dreaded `act(...)` warning 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "While the test was obviously not working, the console was constantly nagging about wrapping the test in `act()`:\r",
      "\r",
      "```\r",
      "When testing, code that causes React state updates should be wrapped into act(...):\r",
      "\r",
      "act(() => {\r",
      "  /* fire events that update state */\r",
      "});\r",
      "/* assert on the output */\r",
      "\r",
      "This ensures that you're testing the behavior the user would see in the browser.\r",
      "```\r",
      "\r",
      "This message wasn't very helpful in identifying the underlying issue. The only thing it highlighted was that the test didn't update the component style immediately. There were pending updates after the test completed. To put it plainly, the test was failing because the `dragStart` event didn't immediately update the `Card` components' style (i.e. set the new `opacity`).\r",
      "\r",
      "As a side note, the `Card` component is connected to Redux, which might relate to the issue, but it would most likely happen even without Redux. That's probably due to the fact that `collect` takes some amount of time to run and send an update to the component.\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Solving the issue 30-seconds-of-code": {
    "prefix": "hreact Solving the issue 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "Digging deeper, we found that apart from `act()`, there are also other options, such as `waitFor()` and `waitForDomChange()`. These seem more intuitive simply because of the name and way they're written (using either `async await` or promises). However, `waitForDomChange()` didn't work properly for our case and our version of `react-testing-library` (which shipped with `react-scripts`) was outdated and did not export `waitFor()`, which took us a good half an hour to figure out.\r",
      "\r",
      "After updating `react-testing-library`, we were still not ready to go, as the console started displaying the following error:\r",
      "\r",
      "```\r",
      "TypeError: MutationObserver is not a constructor\r",
      "```\r",
      "\r",
      "This required some searching, which eventually led us to [this issue](https://github.com/testing-library/react-testing-library/issues/662) which helped us figure out that a solution was to replace the `test` script in our `package.json` with this line:\r",
      "\r",
      "```json\r",
      "{\r",
      "  // ...\r",
      "  \"scripts\": {\r",
      "    \"test\": \"react-scripts test --env=jsdom-fourteen\"\r",
      "    // ...\r",
      "  }\r",
      "}\r",
      "```\r",
      "\r",
      "Now to finally write a test that works! As mentioned above, we opted to use `waitFor()` from `react-testing-library`, which was actually the only change to the original testing code, except for the dependency bump and the script change described above. Here's the test after making the necessary changes:\r",
      "\r",
      "```jsx\r",
      "import React from 'react';\r",
      "import { fireEvent, waitFor } from '@testing-library/react';\r",
      "// This a little helper we have written to connect to redux and react-dnd\r",
      "import renderDndConnected from './test_utils/renderDndConnected';\r",
      "import Card from './components/Card';\r",
      "\r",
      "describe('<Card/>', () => {\r",
      "  let card;\r",
      "\r",
      "  beforeEach(() => {\r",
      "    const utils = renderDndConnected(\r",
      "      <Card card={{ id: '1', title: 'Card' }} />\r",
      "    );\r",
      "    card = utils.container.querySelector('.card');\r",
      "  });\r",
      "\r",
      "  it('initial opacity is 1', () => {\r",
      "    expect(card.style.opacity).toEqual('1');\r",
      "  });\r",
      "\r",
      "  describe('when drag starts', () => {\r",
      "    beforeEach(() => {\r",
      "      fireEvent.dragStart(card);\r",
      "    });\r",
      "\r",
      "    it('opacity is 0', async() => {\r",
      "      await waitFor(() => expect(card.style.opacity).toEqual('0'));\r",
      "    });\r",
      "  });\r",
      "});\r",
      "```\r",
      "\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  },
  "hreact Summary 30-seconds-of-code": {
    "prefix": "hreact Summary 30-seconds-of-code",
    "type": "md",
    "isCode": false,
    "body": [
      "\r",
      "- A message about code that causes React state updates not being wrapped in `act(...)` might indicate that a component updated after the test ended.\r",
      "- Using `waitFor()` can solve the issue by making tests asynchronous, but you might need to bump your `react-testing-library` version if you are using older versions of `react-scripts`.\r",
      "- If you see errors related to `MutationObserver`, you might need to change your `test` script to include `--env=jsdom-fourteen` as a parameter.\r",
      ""
    ],
    "description": "https://github.com/30-seconds/30-seconds-of-code"
  }
}