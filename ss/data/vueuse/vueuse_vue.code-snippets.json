{
  "hvue computedInject - vueuse": {
    "prefix": "hvue computedInject - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Component\r",
      "---\r",
      "\r",
      "# computedInject\r",
      "\r",
      "Combine computed and inject\r",
      "\r",
      "## Usage\r",
      "\r",
      "In Provider Component\r",
      "```ts\r",
      "import type { InjectionKey, Ref } from 'vue'\r",
      "import { provide, ref } from 'vue'\r",
      "\r",
      "interface Item {\r",
      "  key: number\r",
      "  value: string\r",
      "}\r",
      "\r",
      "export const ArrayKey: InjectionKey<Ref<Item[]>> = Symbol('symbol-key')\r",
      "\r",
      "const array = ref([{ key: 1, value: '1' }, { key: 2, value: '2' }, { key: 3, value: '3' }])\r",
      "\r",
      "provide(ArrayKey, array)\r",
      "```\r",
      "\r",
      "In Receiver Component\r",
      "```ts\r",
      "import { computedInject } from '@vueuse/core'\r",
      "\r",
      "import { ArrayKey } from './provider'\r",
      "\r",
      "const computedArray = computedInject(ArrayKey, (source) => {\r",
      "  const arr = [...source.value]\r",
      "  arr.unshift({ key: 0, value: 'all' })\r",
      "  return arr\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef, InjectionKey } from 'vue-demi'\r",
      "import { computed, inject } from 'vue-demi'\r",
      "\r",
      "export type ComputedInjectGetter<T, K> = (source: T | undefined, ctx?: any) => K\r",
      "export type ComputedInjectGetterWithDefault<T, K> = (source: T, ctx?: any) => K\r",
      "export type ComputedInjectSetter<T> = (v: T) => void\r",
      "\r",
      "export interface WritableComputedInjectOptions<T, K> {\r",
      "  get: ComputedInjectGetter<T, K>\r",
      "  set: ComputedInjectSetter<K>\r",
      "}\r",
      "\r",
      "export interface WritableComputedInjectOptionsWithDefault<T, K> {\r",
      "  get: ComputedInjectGetterWithDefault<T, K>\r",
      "  set: ComputedInjectSetter<K>\r",
      "}\r",
      "\r",
      "export function computedInject<T, K = any>(\r",
      "  key: InjectionKey<T> | string,\r",
      "  getter: ComputedInjectGetter<T, K>\r",
      "): ComputedRef<K | undefined>\r",
      "export function computedInject<T, K = any>(\r",
      "  key: InjectionKey<T> | string,\r",
      "  options: WritableComputedInjectOptions<T, K>\r",
      "): ComputedRef<K | undefined>\r",
      "export function computedInject<T, K = any>(\r",
      "  key: InjectionKey<T> | string,\r",
      "  getter: ComputedInjectGetterWithDefault<T, K>,\r",
      "  defaultSource: T,\r",
      "  treatDefaultAsFactory?: false\r",
      "): ComputedRef<K>\r",
      "export function computedInject<T, K = any>(\r",
      "  key: InjectionKey<T> | string,\r",
      "  options: WritableComputedInjectOptionsWithDefault<T, K>,\r",
      "  defaultSource: T | (() => T),\r",
      "  treatDefaultAsFactory: true\r",
      "): ComputedRef<K>\r",
      "export function computedInject<T, K = any>(\r",
      "  key: InjectionKey<T> | string,\r",
      "  options: ComputedInjectGetter<T, K> | WritableComputedInjectOptions<T, K>,\r",
      "  defaultSource?: T | (() => T),\r",
      "  treatDefaultAsFactory?: boolean,\r",
      ") {\r",
      "  let source = inject(key) as T | undefined\r",
      "  if (defaultSource)\r",
      "    source = inject(key, defaultSource as T) as T\r",
      "  if (treatDefaultAsFactory)\r",
      "    source = inject(key, defaultSource, treatDefaultAsFactory) as T\r",
      "\r",
      "  if (typeof options === 'function') {\r",
      "    return computed(ctx => options(source, ctx))\r",
      "  }\r",
      "  else {\r",
      "    return computed({\r",
      "      get: ctx => options.get(source, ctx),\r",
      "      set: options.set,\r",
      "    })\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { provide, ref } from 'vue'\r",
      "import Receiver, { ArrayKey } from './demoReceiver.vue'\r",
      "\r",
      "const array = ref([{ key: 1, value: '1' }, { key: 2, value: '2' }, { key: 3, value: '3' }])\r",
      "\r",
      "provide(ArrayKey, array)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div grid md:grid-cols-2 grid-cols-1 gap-4>\r",
      "    <div md:border=\"0 r-1 dark:(black opacity-50)\">\r",
      "      <div text-primary font-bold mb-2>\r",
      "        Array\r",
      "      </div>\r",
      "      <pre>{{ array }}</pre>\r",
      "    </div>\r",
      "    <Receiver />\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue createTemplatePromise - vueuse": {
    "prefix": "hvue createTemplatePromise - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Component\r",
      "outline: deep\r",
      "---\r",
      "\r",
      "# createTemplatePromise\r",
      "\r",
      "Template as Promise. Useful for constructing custom Dialogs, Modals, Toasts, etc.\r",
      "\r",
      "::: warning\r",
      "This function only works for Vue 3\r",
      ":::\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { createTemplatePromise } from '@vueuse/core'\r",
      "\r",
      "const TemplatePromise = createTemplatePromise<ReturnType>()\r",
      "\r",
      "async function open() {\r",
      "  const result = await TemplatePromise.start()\r",
      "  // button is clicked, result is 'ok'\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <TemplatePromise v-slot=\"{ promise, resolve, reject, args }\">\r",
      "    <!-- your UI -->\r",
      "    <button @click=\"resolve('ok')\">OK</button>\r",
      "  </TemplatePromise>\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Features\r",
      "\r",
      "- **Programmatic** - call your UI as a promise\r",
      "- **Template** - use Vue template to render, not a new DSL\r",
      "- **TypeScript** - full type safety via generic type\r",
      "- **Renderless** - you take full control of the UI\r",
      "- **Transition** - use support Vue transition\r",
      "\r",
      "This function is migrated from [vue-template-promise](https://github.com/antfu/vue-template-promise)\r",
      "\r",
      "## Usage\r",
      "\r",
      "`createTemplatePromise` returns a **Vue Component** that you can directly use in your template with `<script setup>`\r",
      "\r",
      "```ts\r",
      "import { createTemplatePromise } from '@vueuse/core'\r",
      "\r",
      "const TemplatePromise = createTemplatePromise()\r",
      "const MyPromise = createTemplatePromise<boolean>() // with generic type\r",
      "```\r",
      "\r",
      "In template, use `v-slot` to access the promise and resolve functions.\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <TemplatePromise v-slot=\"{ promise, resolve, reject, args }\">\r",
      "    <!-- you can have anything -->\r",
      "    <button @click=\"resolve('ok')\">OK</button>\r",
      "  </TemplatePromise>\r",
      "  <MyPromise v-slot=\"{ promise, resolve, reject, args }\">\r",
      "    <!-- another one -->\r",
      "  </MyPromise>\r",
      "</template>\r",
      "```\r",
      "\r",
      "The slot will not be rendered initially (similar to `v-if=\"false\"`), until you call the `start` method from the component.\r",
      "\r",
      "```ts\r",
      "const result = await TemplatePromise.start()\r",
      "```\r",
      "\r",
      "Once `resolve` or `reject` is called in the template, the promise will be resolved or rejected, returning the value you passed in. Once resolved, the slot will be removed automatically.\r",
      "\r",
      "### Passing Arguments\r",
      "\r",
      "You can pass arguments to the `start` with arguments.\r",
      "\r",
      "```ts\r",
      "import { createTemplatePromise } from '@vueuse/core'\r",
      "\r",
      "const TemplatePromise = createTemplatePromise<boolean, [string, number]>()\r",
      "```\r",
      "\r",
      "```ts\r",
      "const result = await TemplatePromise.start('hello', 123) // Pr\r",
      "```\r",
      "\r",
      "And in the template slot, you can access the arguments via `args` property.\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <TemplatePromise v-slot=\"{ args, resolve }\">\r",
      "    <div>{{ args[0] }}</div> <!-- hello -->\r",
      "    <div>{{ args[1] }}</div> <!-- 123 -->\r",
      "    <button @click=\"resolve(true)\">OK</button>\r",
      "  </TemplatePromise>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Transition\r",
      "\r",
      "You can use transition to animate the slot.\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "const TemplatePromise = createTemplatePromise<ReturnType>({\r",
      "  transition: {\r",
      "    name: 'fade',\r",
      "    appear: true,\r",
      "  },\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <TemplatePromise v-slot=\"{ resolve }\">\r",
      "    <!-- your UI -->\r",
      "    <button @click=\"resolve('ok')\">OK</button>\r",
      "  </TemplatePromise>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      ".fade-enter-active, .fade-leave-active {\r",
      "  transition: opacity .5s;\r",
      "}\r",
      ".fade-enter, .fade-leave-to {\r",
      "  opacity: 0;\r",
      "}\r",
      "</style>\r",
      "```\r",
      "\r",
      "Learn more about [Vue Transition](https://v3.vuejs.org/guide/transitions-overview.html).\r",
      "\r",
      "## Motivation\r",
      "\r",
      "The common approach to call a dialog or a model programmatically would be like this:\r",
      "\r",
      "```ts\r",
      "const dialog = useDialog()\r",
      "const result = await dialog.open({\r",
      "  title: 'Hello',\r",
      "  content: 'World',\r",
      "})\r",
      "```\r",
      "\r",
      "This would work by sending these information to the top-level component and let it render the dialog. However, it limits the flexibility you could express in the UI. For example, you could want the title to be red, or have extra buttons, etc. You would end up with a lot of options like:\r",
      "\r",
      "```ts\r",
      "const result = await dialog.open({\r",
      "  title: 'Hello',\r",
      "  titleClass: 'text-red',\r",
      "  content: 'World',\r",
      "  contentClass: 'text-blue text-sm',\r",
      "  buttons: [\r",
      "    { text: 'OK', class: 'bg-red', onClick: () => {} },\r",
      "    { text: 'Cancel', class: 'bg-blue', onClick: () => {} },\r",
      "  ],\r",
      "  // ...\r",
      "})\r",
      "```\r",
      "\r",
      "Even this is not flexible enough. If you want more, you might end up with manual render function.\r",
      "\r",
      "```ts\r",
      "const result = await dialog.open({\r",
      "  title: 'Hello',\r",
      "  contentSlot: () => h(MyComponent, { content }),\r",
      "})\r",
      "```\r",
      "\r",
      "This is like reinventing a new DSL in the script to express the UI template.\r",
      "\r",
      "So this function allows **expressing the UI in templates instead of scripts**, where it is supposed to be, while still being able to be manipulated programmatically.\r",
      "# Source TS",
      "```js",
      "import type { DefineComponent, Ref, TransitionGroupProps } from 'vue-demi'\r",
      "import { Fragment, TransitionGroup, defineComponent, h, isVue3, ref, shallowReactive } from 'vue-demi'\r",
      "\r",
      "export interface TemplatePromiseProps<Return, Args extends any[] = []> {\r",
      "  /**\r",
      "   * The promise instance.\r",
      "   */\r",
      "  promise: Promise<Return> | undefined\r",
      "  /**\r",
      "   * Resolve the promise.\r",
      "   */\r",
      "  resolve: (v: Return | Promise<Return>) => void\r",
      "  /**\r",
      "   * Reject the promise.\r",
      "   */\r",
      "  reject: (v: any) => void\r",
      "  /**\r",
      "   * Arguments passed to TemplatePromise.start()\r",
      "   */\r",
      "  args: Args\r",
      "  /**\r",
      "   * Indicates if the promise is resolving.\r",
      "   * When passing another promise to `resolve`, this will be set to `true` until the promise is resolved.\r",
      "   */\r",
      "  isResolving: boolean\r",
      "  /**\r",
      "   * Options passed to createTemplatePromise()\r",
      "   */\r",
      "  options: TemplatePromiseOptions\r",
      "  /**\r",
      "   * Unique key for list rendering.\r",
      "   */\r",
      "  key: number\r",
      "}\r",
      "\r",
      "export interface TemplatePromiseOptions {\r",
      "  /**\r",
      "   * Determines if the promise can be called only once at a time.\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  singleton?: boolean\r",
      "\r",
      "  /**\r",
      "   * Transition props for the promise.\r",
      "   */\r",
      "  transition?: TransitionGroupProps\r",
      "}\r",
      "\r",
      "export type TemplatePromise<Return, Args extends any[] = []> = DefineComponent<{}> & {\r",
      "  new(): {\r",
      "    $slots: {\r",
      "      default(_: TemplatePromiseProps<Return, Args>): any\r",
      "    }\r",
      "  }\r",
      "} & {\r",
      "  start: (...args: Args) => Promise<Return>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Creates a template promise component.\r",
      " *\r",
      " * @see https://vueuse.org/createTemplatePromise\r",
      " */\r",
      "export function createTemplatePromise<Return, Args extends any[] = []>(\r",
      "  options: TemplatePromiseOptions = {},\r",
      "): TemplatePromise<Return, Args> {\r",
      "  // compatibility: Vue 3 or above\r",
      "  if (!isVue3) {\r",
      "    if (process.env.NODE_ENV !== 'production')\r",
      "      throw new Error('[VueUse] createTemplatePromise only works in Vue 3 or above.')\r",
      "    // @ts-expect-error incompatible\r",
      "    return\r",
      "  }\r",
      "\r",
      "  let index = 0\r",
      "  const instances = ref([]) as Ref<TemplatePromiseProps<Return, Args>[]>\r",
      "\r",
      "  function create(...args: Args) {\r",
      "    const props = shallowReactive({\r",
      "      key: index++,\r",
      "      args,\r",
      "      promise: undefined,\r",
      "      resolve: () => {},\r",
      "      reject: () => {},\r",
      "      isResolving: false,\r",
      "      options,\r",
      "    }) as TemplatePromiseProps<Return, Args>\r",
      "\r",
      "    instances.value.push(props)\r",
      "\r",
      "    props.promise = new Promise<Return>((_resolve, _reject) => {\r",
      "      props.resolve = (v) => {\r",
      "        props.isResolving = true\r",
      "        return _resolve(v)\r",
      "      }\r",
      "      props.reject = _reject\r",
      "    })\r",
      "      .finally(() => {\r",
      "        props.promise = undefined\r",
      "        const index = instances.value.indexOf(props)\r",
      "        if (index !== -1)\r",
      "          instances.value.splice(index, 1)\r",
      "      })\r",
      "\r",
      "    return props.promise\r",
      "  }\r",
      "\r",
      "  function start(...args: Args) {\r",
      "    if (options.singleton && instances.value.length > 0)\r",
      "      return instances.value[0].promise\r",
      "    return create(...args)\r",
      "  }\r",
      "\r",
      "  const component = defineComponent((_, { slots }) => {\r",
      "    const renderList = () => instances.value.map(props => h(Fragment, { key: props.key }, slots.default?.(props)))\r",
      "    if (options.transition)\r",
      "      return () => h(TransitionGroup, options.transition, renderList)\r",
      "    return renderList\r",
      "  })\r",
      "\r",
      "  // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\r",
      "  // @ts-ignore There's a breaking type change in Vue 3.3 <https://github.com/vuejs/core/pull/7963>\r",
      "  component.start = start\r",
      "\r",
      "  return component as any\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { createTemplatePromise } from '.'\r",
      "\r",
      "type DialogResult = 'ok' | 'cancel'\r",
      "\r",
      "const TemplatePromise = createTemplatePromise<DialogResult, [string]>({\r",
      "  transition: {\r",
      "    name: 'fade',\r",
      "    appear: true,\r",
      "  },\r",
      "})\r",
      "\r",
      "async function open(idx: number) {\r",
      "  console.log(idx, 'Before')\r",
      "  const result = await TemplatePromise.start(`Hello ${idx}`)\r",
      "  console.log(idx, 'After', result)\r",
      "}\r",
      "\r",
      "function asyncFn() {\r",
      "  return new Promise<DialogResult>((resolve) => {\r",
      "    setTimeout(() => {\r",
      "      resolve('ok')\r",
      "    }, 1000)\r",
      "  })\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"flex gap-2\">\r",
      "    <button @click=\"open(1)\">\r",
      "      Open 1\r",
      "    </button>\r",
      "    <button @click=\"open(2)\">\r",
      "      Open 2\r",
      "    </button>\r",
      "    <button @click=\"open(1); open(2)\">\r",
      "      Open 1 & 2\r",
      "    </button>\r",
      "  </div>\r",
      "  <TemplatePromise v-slot=\"{ resolve, args, isResolving }\">\r",
      "    <div class=\"fixed inset-0 bg-black/10 flex items-center z-30\">\r",
      "      <dialog open class=\"border-gray/10 shadow rounded ma\">\r",
      "        <div>Dialog {{ args[0] }}</div>\r",
      "        <p>Open console to see logs</p>\r",
      "        <div class=\"flex gap-2 justify-end\">\r",
      "          <button class=\"w-35\" @click=\"resolve('cancel')\">\r",
      "            Cancel\r",
      "          </button>\r",
      "          <button class=\"w-35\" :disabled=\"isResolving\" @click=\"resolve(asyncFn())\">\r",
      "            {{ isResolving ? 'Confirming...' : 'OK' }}\r",
      "          </button>\r",
      "        </div>\r",
      "      </dialog>\r",
      "    </div>\r",
      "  </TemplatePromise>\r",
      "</template>\r",
      "\r",
      "<style>\r",
      ".fade-enter-active,\r",
      ".fade-leave-active {\r",
      "  transition: opacity 0.5s ease;\r",
      "}\r",
      "\r",
      ".fade-enter-from,\r",
      ".fade-leave-to {\r",
      "  opacity: 0;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue onClickOutside - vueuse": {
    "prefix": "hvue onClickOutside - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# onClickOutside\r",
      "\r",
      "Listen for clicks outside of an element. Useful for modal or dropdown.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html {18}\r",
      "<template>\r",
      "  <div ref=\"target\">\r",
      "    Hello world\r",
      "  </div>\r",
      "  <div>\r",
      "    Outside element\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<script>\r",
      "import { ref } from 'vue'\r",
      "import { onClickOutside } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const target = ref(null)\r",
      "\r",
      "    onClickOutside(target, (event) => console.log(event))\r",
      "\r",
      "    return { target }\r",
      "  }\r",
      "}\r",
      "</script>\r",
      "```\r",
      "\r",
      "> This function uses [Event.composedPath()](https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath) which is NOT supported by IE 11, Edge 18 and below. If you are targeting these browsers, we recommend you to include [this code snippet](https://gist.github.com/sibbng/13e83b1dd1b733317ce0130ef07d4efd) on your project.\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<OnClickOutside @trigger=\"count++\" :options=\"{ ignore: [/* ... */] }\">\r",
      "  <div>\r",
      "    Click Outside of Me\r",
      "  </div>\r",
      "</OnClickOutside>\r",
      "```\r",
      "## Directive Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { vOnClickOutside } from '@vueuse/components'\r",
      "\r",
      "const modal = ref(false)\r",
      "function closeModal() {\r",
      "  modal.value = false\r",
      "}\r",
      "\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"modal = true\">\r",
      "    Open Modal\r",
      "  </button>\r",
      "  <div v-if=\"modal\" v-on-click-outside=\"closeModal\">\r",
      "    Hello World\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "You can also set the handler as an array to set the configuration items of the instruction.\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { ref } from 'vue'\r",
      "import { vOnClickOutside } from '@vueuse/components'\r",
      "\r",
      "const modal = ref(false)\r",
      "\r",
      "const ignoreElRef = ref()\r",
      "\r",
      "const onClickOutsideHandler = [\r",
      "  (ev) => {\r",
      "    console.log(ev)\r",
      "    modal.value = false\r",
      "  },\r",
      "  { ignore: [ignoreElRef] }\r",
      "]\r",
      "\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"modal = true\">\r",
      "    Open Modal\r",
      "  </button>\r",
      "\r",
      "  <div ref=\"ignoreElRef\">\r",
      "    click outside ignore element\r",
      "  </div>\r",
      "\r",
      "  <div v-if=\"modal\" v-on-click-outside=\"onClickOutsideHandler\">\r",
      "    Hello World\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Fn } from '@vueuse/shared'\r",
      "import { isIOS, noop } from '@vueuse/shared'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface OnClickOutsideOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * List of elements that should not trigger the event.\r",
      "   */\r",
      "  ignore?: (MaybeElementRef | string)[]\r",
      "  /**\r",
      "   * Use capturing phase for internal event listener.\r",
      "   * @default true\r",
      "   */\r",
      "  capture?: boolean\r",
      "  /**\r",
      "   * Run handler function if focus moves to an iframe.\r",
      "   * @default false\r",
      "   */\r",
      "  detectIframe?: boolean\r",
      "}\r",
      "\r",
      "export type OnClickOutsideHandler<T extends { detectIframe: OnClickOutsideOptions['detectIframe'] } = { detectIframe: false }> = (evt: T['detectIframe'] extends true ? PointerEvent | FocusEvent : PointerEvent) => void\r",
      "\r",
      "let _iOSWorkaround = false\r",
      "\r",
      "/**\r",
      " * Listen for clicks outside of an element.\r",
      " *\r",
      " * @see https://vueuse.org/onClickOutside\r",
      " * @param target\r",
      " * @param handler\r",
      " * @param options\r",
      " */\r",
      "export function onClickOutside<T extends OnClickOutsideOptions>(\r",
      "  target: MaybeElementRef,\r",
      "  handler: OnClickOutsideHandler<{ detectIframe: T['detectIframe'] }>,\r",
      "  options: T = {} as T,\r",
      ") {\r",
      "  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options\r",
      "\r",
      "  if (!window)\r",
      "    return\r",
      "\r",
      "  // Fixes: https://github.com/vueuse/vueuse/issues/1520\r",
      "  // How it works: https://stackoverflow.com/a/39712411\r",
      "  if (isIOS && !_iOSWorkaround) {\r",
      "    _iOSWorkaround = true\r",
      "    Array.from(window.document.body.children)\r",
      "      .forEach(el => el.addEventListener('click', noop))\r",
      "    window.document.documentElement.addEventListener('click', noop)\r",
      "  }\r",
      "\r",
      "  let shouldListen = true\r",
      "\r",
      "  const shouldIgnore = (event: PointerEvent) => {\r",
      "    return ignore.some((target) => {\r",
      "      if (typeof target === 'string') {\r",
      "        return Array.from(window.document.querySelectorAll(target))\r",
      "          .some(el => el === event.target || event.composedPath().includes(el))\r",
      "      }\r",
      "      else {\r",
      "        const el = unrefElement(target)\r",
      "        return el && (event.target === el || event.composedPath().includes(el))\r",
      "      }\r",
      "    })\r",
      "  }\r",
      "\r",
      "  const listener = (event: PointerEvent) => {\r",
      "    const el = unrefElement(target)\r",
      "\r",
      "    if (!el || el === event.target || event.composedPath().includes(el))\r",
      "      return\r",
      "\r",
      "    if (event.detail === 0)\r",
      "      shouldListen = !shouldIgnore(event)\r",
      "\r",
      "    if (!shouldListen) {\r",
      "      shouldListen = true\r",
      "      return\r",
      "    }\r",
      "\r",
      "    handler(event)\r",
      "  }\r",
      "\r",
      "  const cleanup = [\r",
      "    useEventListener(window, 'click', listener, { passive: true, capture }),\r",
      "    useEventListener(window, 'pointerdown', (e) => {\r",
      "      const el = unrefElement(target)\r",
      "      if (el)\r",
      "        shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e)\r",
      "    }, { passive: true }),\r",
      "    detectIframe && useEventListener(window, 'blur', (event) => {\r",
      "      setTimeout(() => {\r",
      "        const el = unrefElement(target)\r",
      "        if (\r",
      "          window.document.activeElement?.tagName === 'IFRAME'\r",
      "          && !el?.contains(window.document.activeElement)\r",
      "        )\r",
      "          handler(event as any)\r",
      "      }, 0)\r",
      "    }),\r",
      "  ].filter(Boolean) as Fn[]\r",
      "\r",
      "  const stop = () => cleanup.forEach(fn => fn())\r",
      "\r",
      "  return stop\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import type { OnClickOutsideHandler } from '@vueuse/core'\r",
      "import { onClickOutside } from '@vueuse/core'\r",
      "import { vOnClickOutside } from './directive'\r",
      "\r",
      "const modal = ref(false)\r",
      "const modalRef = ref(null)\r",
      "\r",
      "onClickOutside(\r",
      "  modalRef,\r",
      "  (event) => {\r",
      "    console.log(event)\r",
      "    modal.value = false\r",
      "  },\r",
      ")\r",
      "\r",
      "const dropdown = ref(false)\r",
      "const dropdownHandler: OnClickOutsideHandler = (event) => {\r",
      "  console.log(event)\r",
      "  dropdown.value = false\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"modal = true\">\r",
      "    Open Modal\r",
      "  </button>\r",
      "  <div class=\"ml-2 relative inline-block\">\r",
      "    <button @click.stop=\"dropdown = !dropdown\">\r",
      "      Toggle Dropdown\r",
      "    </button>\r",
      "    <div\r",
      "      v-if=\"dropdown\"\r",
      "      v-on-click-outside.bubble=\"dropdownHandler\"\r",
      "      class=\"dropdown-inner\"\r",
      "    >\r",
      "      Click outside of the dropdown to close it.\r",
      "    </div>\r",
      "  </div>\r",
      "  <div v-if=\"modal\" ref=\"modalRef\" class=\"modal\">\r",
      "    <div class=\"inner\">\r",
      "      <button class=\"button small\" title=\"Close\" @click=\"modal = false\">\r",
      "        ùñ∑\r",
      "      </button>\r",
      "      <p class=\"heading\">\r",
      "        Demo Modal\r",
      "      </p>\r",
      "      <p>Click outside of the modal to close it.</p>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      ".modal {\r",
      "  position: fixed;\r",
      "  left: 50%;\r",
      "  top: 50%;\r",
      "  transform: translate(-50%, -50%);\r",
      "  width: 420px;\r",
      "  max-width: 100%;\r",
      "  z-index: 10;\r",
      "}\r",
      ".inner {\r",
      "  background-color: var(--vp-c-bg);\r",
      "  padding: 0.4em 2em;\r",
      "  border-radius: 5px;\r",
      "  border: 1px solid var(--vp-c-divider);\r",
      "  box-shadow: 2px 2px 10px rgba(10, 10, 10, 0.1);\r",
      "}\r",
      ".dropdown-inner {\r",
      "  background-color: var(--vp-c-bg);\r",
      "  padding: 0.5em;\r",
      "  position: absolute;\r",
      "  left: 0;\r",
      "  z-index: 10;\r",
      "  border-radius: 5px;\r",
      "  border: 1px solid var(--vp-c-divider);\r",
      "  box-shadow: 2px 2px 5px rgba(10, 10, 10, 0.1);\r",
      "}\r",
      ".heading {\r",
      "  font-weight: bold;\r",
      "  font-size: 1.4rem;\r",
      "  margin-bottom: 2rem;\r",
      "}\r",
      ".button {\r",
      "  position: absolute;\r",
      "  top: -0.9rem;\r",
      "  right: -0.5rem;\r",
      "  font-weight: bold;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue onKeyStroke - vueuse": {
    "prefix": "hvue onKeyStroke - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# onKeyStroke\r",
      "\r",
      "Listen for keyboard keystrokes.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { onKeyStroke } from '@vueuse/core'\r",
      "\r",
      "onKeyStroke('ArrowDown', (e) => {\r",
      "  e.preventDefault()\r",
      "})\r",
      "```\r",
      "\r",
      "See [this table](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) for all key codes.\r",
      "\r",
      "### Listen To Multiple Keys\r",
      "\r",
      "```js\r",
      "import { onKeyStroke } from '@vueuse/core'\r",
      "\r",
      "onKeyStroke(['s', 'S', 'ArrowDown'], (e) => {\r",
      "  e.preventDefault()\r",
      "})\r",
      "\r",
      "// listen to all keys by [true / skip the keyDefine]\r",
      "onKeyStroke(true, (e) => {\r",
      "  e.preventDefault()\r",
      "})\r",
      "onKeyStroke((e) => {\r",
      "  e.preventDefault()\r",
      "})\r",
      "```\r",
      "\r",
      "### Custom Event Target\r",
      "\r",
      "```js\r",
      "onKeyStroke('A', (e) => {\r",
      "  console.log('Key A pressed on document')\r",
      "}, { target: document })\r",
      "```\r",
      "\r",
      "### Ignore Repeated Events\r",
      "\r",
      "The callback will trigger only once when pressing `A` and **hold down**.\r",
      "\r",
      "```js\r",
      "import { onKeyStroke } from '@vueuse/core'\r",
      "\r",
      "// use `autoRepeat` option\r",
      "onKeyStroke('A', (e) => {\r",
      "  console.log('Key A pressed')\r",
      "}, { dedupe: false })\r",
      "```\r",
      "\r",
      "Reference: [KeyboardEvent.repeat](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat)\r",
      "\r",
      "## Directive Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { vOnKeyStroke } from '@vueuse/components'\r",
      "function onUpdate(e: KeyboardEvent) {\r",
      "  // impl...\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <input v-on-key-stroke:c,v=\"onUpdate\" type=\"text\">\r",
      "  <!-- with options -->\r",
      "  <input v-on-key-stroke:c,v=\"[onUpdate, { eventName: 'keyup' }]\" type=\"text\">\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Custom Keyboard Event\r",
      "\r",
      "```js\r",
      "onKeyStroke('Shift', (e) => {\r",
      "  console.log('Shift key up')\r",
      "}, { eventName: 'keyup' })\r",
      "```\r",
      "\r",
      "Or\r",
      "\r",
      "```js\r",
      "onKeyUp('Shift', () => console.log('Shift key up'))\r",
      "```\r",
      "\r",
      "\r",
      "## Shorthands\r",
      "\r",
      "- `onKeyDown` - alias for `onKeyStroke(key, handler, {eventName: 'keydown'})`\r",
      "- `onKeyPressed` - alias for `onKeyStroke(key, handler, {eventName: 'keypress'})`\r",
      "- `onKeyUp` -  alias for `onKeyStroke(key, handler, {eventName: 'keyup'})`\r",
      "# Source TS",
      "```js",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export type KeyPredicate = (event: KeyboardEvent) => boolean\r",
      "export type KeyFilter = true | string | string[] | KeyPredicate\r",
      "export type KeyStrokeEventName = 'keydown' | 'keypress' | 'keyup'\r",
      "export interface OnKeyStrokeOptions {\r",
      "  eventName?: KeyStrokeEventName\r",
      "  target?: MaybeRefOrGetter<EventTarget | null | undefined>\r",
      "  passive?: boolean\r",
      "  /**\r",
      "   * Set to `true` to ignore repeated events when the key is being held down.\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  dedupe?: MaybeRefOrGetter<boolean>\r",
      "}\r",
      "\r",
      "function createKeyPredicate(keyFilter: KeyFilter): KeyPredicate {\r",
      "  if (typeof keyFilter === 'function')\r",
      "    return keyFilter\r",
      "\r",
      "  else if (typeof keyFilter === 'string')\r",
      "    return (event: KeyboardEvent) => event.key === keyFilter\r",
      "\r",
      "  else if (Array.isArray(keyFilter))\r",
      "    return (event: KeyboardEvent) => keyFilter.includes(event.key)\r",
      "\r",
      "  return () => true\r",
      "}\r",
      "\r",
      "export function onKeyStroke(key: KeyFilter, handler: (event: KeyboardEvent) => void, options?: OnKeyStrokeOptions): () => void\r",
      "export function onKeyStroke(handler: (event: KeyboardEvent) => void, options?: OnKeyStrokeOptions): () => void\r",
      "\r",
      "/**\r",
      " * Listen for keyboard keystrokes.\r",
      " *\r",
      " * @see https://vueuse.org/onKeyStroke\r",
      " */\r",
      "export function onKeyStroke(key: KeyFilter, handler: (event: KeyboardEvent) => void, options?: OnKeyStrokeOptions): () => void\r",
      "export function onKeyStroke(handler: (event: KeyboardEvent) => void, options?: OnKeyStrokeOptions): () => void\r",
      "export function onKeyStroke(...args: any[]) {\r",
      "  let key: KeyFilter\r",
      "  let handler: (event: KeyboardEvent) => void\r",
      "  let options: OnKeyStrokeOptions = {}\r",
      "\r",
      "  if (args.length === 3) {\r",
      "    key = args[0]\r",
      "    handler = args[1]\r",
      "    options = args[2]\r",
      "  }\r",
      "  else if (args.length === 2) {\r",
      "    if (typeof args[1] === 'object') {\r",
      "      key = true\r",
      "      handler = args[0]\r",
      "      options = args[1]\r",
      "    }\r",
      "    else {\r",
      "      key = args[0]\r",
      "      handler = args[1]\r",
      "    }\r",
      "  }\r",
      "  else {\r",
      "    key = true\r",
      "    handler = args[0]\r",
      "  }\r",
      "\r",
      "  const {\r",
      "    target = defaultWindow,\r",
      "    eventName = 'keydown',\r",
      "    passive = false,\r",
      "    dedupe = false,\r",
      "  } = options\r",
      "  const predicate = createKeyPredicate(key)\r",
      "  const listener = (e: KeyboardEvent) => {\r",
      "    if (e.repeat && toValue(dedupe))\r",
      "      return\r",
      "\r",
      "    if (predicate(e))\r",
      "      handler(e)\r",
      "  }\r",
      "\r",
      "  return useEventListener(target, eventName, listener, passive)\r",
      "}\r",
      "\r",
      "/**\r",
      " * Listen to the keydown event of the given key.\r",
      " *\r",
      " * @see https://vueuse.org/onKeyStroke\r",
      " * @param key\r",
      " * @param handler\r",
      " * @param options\r",
      " */\r",
      "export function onKeyDown(key: KeyFilter, handler: (event: KeyboardEvent) => void, options: Omit<OnKeyStrokeOptions, 'eventName'> = {}) {\r",
      "  return onKeyStroke(key, handler, { ...options, eventName: 'keydown' })\r",
      "}\r",
      "\r",
      "/**\r",
      " * Listen to the keypress event of the given key.\r",
      " *\r",
      " * @see https://vueuse.org/onKeyStroke\r",
      " * @param key\r",
      " * @param handler\r",
      " * @param options\r",
      " */\r",
      "export function onKeyPressed(key: KeyFilter, handler: (event: KeyboardEvent) => void, options: Omit<OnKeyStrokeOptions, 'eventName'> = {}) {\r",
      "  return onKeyStroke(key, handler, { ...options, eventName: 'keypress' })\r",
      "}\r",
      "\r",
      "/**\r",
      " * Listen to the keyup event of the given key.\r",
      " *\r",
      " * @see https://vueuse.org/onKeyStroke\r",
      " * @param key\r",
      " * @param handler\r",
      " * @param options\r",
      " */\r",
      "export function onKeyUp(key: KeyFilter, handler: (event: KeyboardEvent) => void, options: Omit<OnKeyStrokeOptions, 'eventName'> = {}) {\r",
      "  return onKeyStroke(key, handler, { ...options, eventName: 'keyup' })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { onKeyStroke } from '@vueuse/core'\r",
      "\r",
      "const translateX = ref(0)\r",
      "const translateY = ref(0)\r",
      "\r",
      "onKeyStroke(['w', 'W', 'ArrowUp'], () => {\r",
      "  translateY.value -= 10\r",
      "})\r",
      "\r",
      "onKeyStroke(['s', 'S', 'ArrowDown'], () => {\r",
      "  translateY.value += 10\r",
      "})\r",
      "\r",
      "onKeyStroke(['a', 'A', 'ArrowLeft'], () => {\r",
      "  translateX.value -= 10\r",
      "})\r",
      "\r",
      "onKeyStroke(['d', 'D', 'ArrowRight'], () => {\r",
      "  translateX.value += 10\r",
      "}, { dedupe: true })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div class=\"container border-base\">\r",
      "      <div class=\"ball\" :style=\"{ transform: `translate(${translateX}px, ${translateY}px)` }\" />\r",
      "    </div>\r",
      "    <div class=\"text-center mt-4\">\r",
      "      <p>Use the arrow keys or w a s d keys to control the movement of the ball.</p>\r",
      "      <p>Repeated events are ignored on the key `d` or `->`.</p>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      ".container {\r",
      "  display: flex;\r",
      "  justify-content: center;\r",
      "  align-items: center;\r",
      "  width: 100%;\r",
      "  max-width: 400px;\r",
      "  height: 100px;\r",
      "  margin: auto;\r",
      "  overflow: hidden;\r",
      "  border: 1px solid #a1a1a130;\r",
      "  border-radius: 5px;\r",
      "}\r",
      "\r",
      ".ball {\r",
      "  width: 16px;\r",
      "  height: 16px;\r",
      "  background: #a1a1a1;\r",
      "  border-radius: 50%;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue onLongPress - vueuse": {
    "prefix": "hvue onLongPress - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# onLongPress\r",
      "\r",
      "Listen for a long press on an element.\r",
      "\r",
      "Function provides modifiers in options\r",
      "  * stop\r",
      "  * once\r",
      "  * prevent\r",
      "  * capture\r",
      "  * self\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { onLongPress } from '@vueuse/core'\r",
      "\r",
      "const htmlRefHook = ref<HTMLElement | null>(null)\r",
      "const longPressedHook = ref(false)\r",
      "\r",
      "const onLongPressCallbackHook = (e: PointerEvent) => {\r",
      "  longPressedHook.value = true\r",
      "}\r",
      "const resetHook = () => {\r",
      "  longPressedHook.value = false\r",
      "}\r",
      "\r",
      "onLongPress(\r",
      "  htmlRefHook,\r",
      "  onLongPressCallbackHook,\r",
      "  { modifiers: { prevent: true } }\r",
      ")\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>Long Pressed: {{ longPressedHook }}</p>\r",
      "\r",
      "  <button ref=\"htmlRefHook\" class=\"ml-2 button small\">\r",
      "    Press long\r",
      "  </button>\r",
      "\r",
      "  <button class=\"ml-2 button small\" @click=\"resetHook\">\r",
      "    Reset\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { OnLongPress } from '@vueuse/components'\r",
      "\r",
      "const longPressedComponent = ref(false)\r",
      "\r",
      "const onLongPressCallbackComponent = (e: PointerEvent) => {\r",
      "  longPressedComponent.value = true\r",
      "}\r",
      "const resetComponent = () => {\r",
      "  longPressedComponent.value = false\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>Long Pressed: {{ longPressedComponent }}</p>\r",
      "\r",
      "  <OnLongPress\r",
      "    as=\"button\"\r",
      "    class=\"ml-2 button small\"\r",
      "    @trigger=\"onLongPressCallbackComponent\"\r",
      "  >\r",
      "    Press long\r",
      "  </OnLongPress>\r",
      "\r",
      "  <button class=\"ml-2 button small\" @click=\"resetComponent\">\r",
      "    Reset\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Directive Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { vOnLongPress } from '@vueuse/components'\r",
      "\r",
      "const longPressedDirective = ref(false)\r",
      "\r",
      "const onLongPressCallbackDirective = (e: PointerEvent) => {\r",
      "  longPressedDirective.value = true\r",
      "}\r",
      "const resetDirective = () => {\r",
      "  longPressedDirective.value = false\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>Long Pressed: {{ longPressedDirective }}</p>\r",
      "\r",
      "  <button v-on-long-press.prevent=\"onLongPressCallbackDirective\" class=\"ml-2 button small\">\r",
      "    Press long\r",
      "  </button>\r",
      "\r",
      "  <button\r",
      "    v-on-long-press=\"[onLongPressCallbackDirective, {delay: 1000, modifiers: { stop: true }}]\"\r",
      "    class=\"ml-2button small\"\r",
      "  >\r",
      "    Press long (with options)\r",
      "  </button>\r",
      "\r",
      "  <button class=\"ml-2 button small\" @click=\"resetDirective\">\r",
      "    Reset\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed } from 'vue-demi'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "\r",
      "const DEFAULT_DELAY = 500\r",
      "\r",
      "export interface OnLongPressOptions {\r",
      "  /**\r",
      "   * Time in ms till `longpress` gets called\r",
      "   *\r",
      "   * @default 500\r",
      "   */\r",
      "  delay?: number\r",
      "\r",
      "  modifiers?: OnLongPressModifiers\r",
      "}\r",
      "\r",
      "export interface OnLongPressModifiers {\r",
      "  stop?: boolean\r",
      "  once?: boolean\r",
      "  prevent?: boolean\r",
      "  capture?: boolean\r",
      "  self?: boolean\r",
      "}\r",
      "\r",
      "export function onLongPress(\r",
      "  target: MaybeElementRef,\r",
      "  handler: (evt: PointerEvent) => void,\r",
      "  options?: OnLongPressOptions,\r",
      ") {\r",
      "  const elementRef = computed(() => unrefElement(target))\r",
      "\r",
      "  let timeout: ReturnType<typeof setTimeout> | undefined\r",
      "\r",
      "  function clear() {\r",
      "    if (timeout) {\r",
      "      clearTimeout(timeout)\r",
      "      timeout = undefined\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function onDown(ev: PointerEvent) {\r",
      "    if (options?.modifiers?.self && ev.target !== elementRef.value)\r",
      "      return\r",
      "\r",
      "    clear()\r",
      "\r",
      "    if (options?.modifiers?.prevent)\r",
      "      ev.preventDefault()\r",
      "\r",
      "    if (options?.modifiers?.stop)\r",
      "      ev.stopPropagation()\r",
      "\r",
      "    timeout = setTimeout(\r",
      "      () => handler(ev),\r",
      "      options?.delay ?? DEFAULT_DELAY,\r",
      "    )\r",
      "  }\r",
      "\r",
      "  const listenerOptions: AddEventListenerOptions = {\r",
      "    capture: options?.modifiers?.capture,\r",
      "    once: options?.modifiers?.once,\r",
      "  }\r",
      "\r",
      "  useEventListener(elementRef, 'pointerdown', onDown, listenerOptions)\r",
      "  useEventListener(elementRef, ['pointerup', 'pointerleave'], clear, listenerOptions)\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { onLongPress } from '@vueuse/core'\r",
      "\r",
      "const htmlRef = ref<HTMLElement | null>(null)\r",
      "const htmlRefOptions = ref<HTMLElement | null>(null)\r",
      "\r",
      "const longPressed = ref(false)\r",
      "\r",
      "function onLongPressCallback(e: PointerEvent) {\r",
      "  longPressed.value = true\r",
      "}\r",
      "\r",
      "function reset() {\r",
      "  longPressed.value = false\r",
      "}\r",
      "\r",
      "onLongPress(htmlRef, onLongPressCallback)\r",
      "onLongPress(htmlRefOptions, onLongPressCallback, { delay: 1000 })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>Long Pressed: <BooleanDisplay :value=\"longPressed\" /></p>\r",
      "  <button ref=\"htmlRef\" class=\"ml-2 button small\">\r",
      "    Press long (500ms)\r",
      "  </button>\r",
      "  <button ref=\"htmlRefOptions\" class=\"ml-2 button small\">\r",
      "    Press long (1000ms)\r",
      "  </button>\r",
      "  <button class=\"ml-2 button small\" @click=\"reset\">\r",
      "    Reset\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue onStartTyping - vueuse": {
    "prefix": "hvue onStartTyping - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# onStartTyping\r",
      "\r",
      "Fires when users start typing on non-editable elements.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<input ref=\"input\" type=\"text\" placeholder=\"Start typing to focus\" />\r",
      "```\r",
      "\r",
      "```ts {7-10}\r",
      "import { onStartTyping } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const input = ref(null)\r",
      "\r",
      "    onStartTyping(() => {\r",
      "      if (!input.value.active)\r",
      "        input.value.focus()\r",
      "    })\r",
      "\r",
      "    return {\r",
      "      input,\r",
      "    }\r",
      "  },\r",
      "}\r",
      "```\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/streamich/react-use by Vadim Dalecky */\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "\r",
      "function isFocusedElementEditable() {\r",
      "  const { activeElement, body } = document\r",
      "\r",
      "  if (!activeElement)\r",
      "    return false\r",
      "\r",
      "  // If not element has focus, we assume it is not editable, too.\r",
      "  if (activeElement === body)\r",
      "    return false\r",
      "\r",
      "  // Assume <input> and <textarea> elements are editable.\r",
      "  switch (activeElement.tagName) {\r",
      "    case 'INPUT':\r",
      "    case 'TEXTAREA':\r",
      "      return true\r",
      "  }\r",
      "\r",
      "  // Check if any other focused element id editable.\r",
      "  return activeElement.hasAttribute('contenteditable')\r",
      "}\r",
      "\r",
      "function isTypedCharValid({\r",
      "  keyCode,\r",
      "  metaKey,\r",
      "  ctrlKey,\r",
      "  altKey,\r",
      "}: KeyboardEvent) {\r",
      "  if (metaKey || ctrlKey || altKey)\r",
      "    return false\r",
      "\r",
      "  // 0...9\r",
      "  if (keyCode >= 48 && keyCode <= 57)\r",
      "    return true\r",
      "\r",
      "  // A...Z\r",
      "  if (keyCode >= 65 && keyCode <= 90)\r",
      "    return true\r",
      "\r",
      "  // a...z\r",
      "  if (keyCode >= 97 && keyCode <= 122)\r",
      "    return true\r",
      "\r",
      "  // All other keys.\r",
      "  return false\r",
      "}\r",
      "\r",
      "/**\r",
      " * Fires when users start typing on non-editable elements.\r",
      " *\r",
      " * @see https://vueuse.org/onStartTyping\r",
      " * @param callback\r",
      " * @param options\r",
      " */\r",
      "export function onStartTyping(callback: (event: KeyboardEvent) => void, options: ConfigurableDocument = {}) {\r",
      "  const { document = defaultDocument } = options\r",
      "\r",
      "  const keydown = (event: KeyboardEvent) => {\r",
      "    !isFocusedElementEditable()\r",
      "      && isTypedCharValid(event)\r",
      "      && callback(event)\r",
      "  }\r",
      "\r",
      "  if (document)\r",
      "    useEventListener(document, 'keydown', keydown, { passive: true })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { onStartTyping } from '@vueuse/core'\r",
      "\r",
      "const input = ref<HTMLInputElement | null>(null)\r",
      "\r",
      "onStartTyping(() => {\r",
      "  if (input.value !== document.activeElement)\r",
      "    input.value!.focus()\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note>Type anything</note>\r",
      "  <input ref=\"input\" type=\"text\" placeholder=\"Start typing to focus\">\r",
      "  <input type=\"text\" placeholder=\"Start typing has no effect here\">\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useActiveElement - vueuse": {
    "prefix": "hvue useActiveElement - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useActiveElement\r",
      "\r",
      "Reactive `document.activeElement`\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useActiveElement } from '@vueuse/core'\r",
      "\r",
      "const activeElement = useActiveElement()\r",
      "\r",
      "watch(activeElement, (el) => {\r",
      "  console.log('focus changed to', el)\r",
      "})\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseActiveElement v-slot=\"{ element }\">\r",
      "  Active element is {{ element.dataset.id }}\r",
      "</UseActiveElement>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computedWithControl } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableDocumentOrShadowRoot, ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface UseActiveElementOptions extends ConfigurableWindow, ConfigurableDocumentOrShadowRoot {\r",
      "  /**\r",
      "   * Search active element deeply inside shadow dom\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  deep?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive `document.activeElement`\r",
      " *\r",
      " * @see https://vueuse.org/useActiveElement\r",
      " * @param options\r",
      " */\r",
      "export function useActiveElement<T extends HTMLElement>(\r",
      "  options: UseActiveElementOptions = {},\r",
      ") {\r",
      "  const {\r",
      "    window = defaultWindow,\r",
      "    deep = true,\r",
      "  } = options\r",
      "  const document = options.document ?? window?.document\r",
      "\r",
      "  const getDeepActiveElement = () => {\r",
      "    let element = document?.activeElement\r",
      "    if (deep) {\r",
      "      while (element?.shadowRoot)\r",
      "        element = element?.shadowRoot?.activeElement\r",
      "    }\r",
      "    return element\r",
      "  }\r",
      "\r",
      "  const activeElement = computedWithControl(\r",
      "    () => null,\r",
      "    () => getDeepActiveElement() as T | null | undefined,\r",
      "  )\r",
      "\r",
      "  if (window) {\r",
      "    useEventListener(window, 'blur', (event) => {\r",
      "      if (event.relatedTarget !== null)\r",
      "        return\r",
      "      activeElement.trigger()\r",
      "    }, true)\r",
      "    useEventListener(window, 'focus', activeElement.trigger, true)\r",
      "  }\r",
      "\r",
      "  return activeElement\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed } from 'vue'\r",
      "import { useActiveElement } from '@vueuse/core'\r",
      "\r",
      "const activeElement = useActiveElement()\r",
      "const key = computed(() => activeElement.value?.dataset?.id || 'null')\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note\r",
      "    class=\"mb-3\"\r",
      "  >\r",
      "    Select the inputs below to see the changes\r",
      "  </note>\r",
      "  <div\r",
      "    class=\"\r",
      "    grid\r",
      "    grid-cols-1\r",
      "    md:grid-cols-3\r",
      "    gap-2\"\r",
      "  >\r",
      "    <input\r",
      "      v-for=\"i in 6\"\r",
      "      :key=\"i\"\r",
      "      type=\"text\"\r",
      "      :data-id=\"i\"\r",
      "      class=\"!my-0 !min-w-0\"\r",
      "      :placeholder=\"`${i}`\"\r",
      "    >\r",
      "  </div>\r",
      "  <div class=\"mt-2\">\r",
      "    Current Active Element:\r",
      "    <span class=\"text-primary\">{{ key }}</span>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useAnimate - vueuse": {
    "prefix": "hvue useAnimate - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Animation\r",
      "---\r",
      "\r",
      "# useAnimate\r",
      "\r",
      "Reactive [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API).\r",
      "\r",
      "## Usage\r",
      "\r",
      "### Basic Usage\r",
      "\r",
      "The `useAnimate` function will return the animate and its control function.\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <span ref=\"el\" style=\"display:inline-block\">useAnimate</span>\r",
      "</template>\r",
      "\r",
      "<script setup>\r",
      "import { ref } from 'vue'\r",
      "import { useAnimate } from '@vueuse/core'\r",
      "\r",
      "const el = ref()\r",
      "const {\r",
      "  isSupported,\r",
      "  animate,\r",
      "\r",
      "  // actions\r",
      "  play,\r",
      "  pause,\r",
      "  reverse,\r",
      "  finish,\r",
      "  cancel,\r",
      "\r",
      "  // states\r",
      "  pending,\r",
      "  playState,\r",
      "  replaceState,\r",
      "  startTime,\r",
      "  currentTime,\r",
      "  timeline,\r",
      "  playbackRate,\r",
      "} = useAnimate(el, { transform: 'rotate(360deg)' }, 1000)\r",
      "</script>\r",
      "```\r",
      "\r",
      "### Custom Keyframes\r",
      "\r",
      "Either an array of keyframe objects, or a keyframe object, or a `ref`. See [Keyframe Formats](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Keyframe_Formats) for more details.\r",
      "\r",
      "```ts\r",
      "const keyframes = { transform: 'rotate(360deg)' }\r",
      "// Or\r",
      "const keyframes = [\r",
      "  { transform: 'rotate(0deg)' },\r",
      "  { transform: 'rotate(360deg)' },\r",
      "]\r",
      "// Or\r",
      "const keyframes = ref([\r",
      "  { clipPath: 'circle(20% at 0% 30%)' },\r",
      "  { clipPath: 'circle(20% at 50% 80%)' },\r",
      "  { clipPath: 'circle(20% at 100% 30%)' },\r",
      "])\r",
      "\r",
      "useAnimate(el, keyframes, 1000)\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef, Ref, ShallowRef, WritableComputedRef } from 'vue-demi'\r",
      "import { computed, nextTick, shallowReactive, shallowRef, watch } from 'vue-demi'\r",
      "import type { MaybeRef, Mutable } from '@vueuse/shared'\r",
      "import { isObject, objectOmit, toValue, tryOnMounted, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { MaybeComputedElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useRafFn } from '../useRafFn'\r",
      "\r",
      "export interface UseAnimateOptions extends KeyframeAnimationOptions, ConfigurableWindow {\r",
      "  /**\r",
      "   * Will automatically run play when `useAnimate` is used\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "  /**\r",
      "   * Whether to commits the end styling state of an animation to the element being animated\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  commitStyles?: boolean\r",
      "  /**\r",
      "   * Whether to persists the animation\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  persist?: boolean\r",
      "  /**\r",
      "   * Executed after animation initialization\r",
      "   */\r",
      "  onReady?: (animate: Animation) => void\r",
      "  /**\r",
      "   * Callback when error is caught.\r",
      "   */\r",
      "  onError?: (e: unknown) => void\r",
      "}\r",
      "\r",
      "export type UseAnimateKeyframes = MaybeRef<Keyframe[] | PropertyIndexedKeyframes | null>\r",
      "\r",
      "export interface UseAnimateReturn {\r",
      "  isSupported: Ref<boolean>\r",
      "  animate: ShallowRef<Animation | undefined>\r",
      "  play: () => void\r",
      "  pause: () => void\r",
      "  reverse: () => void\r",
      "  finish: () => void\r",
      "  cancel: () => void\r",
      "\r",
      "  pending: ComputedRef<boolean>\r",
      "  playState: ComputedRef<AnimationPlayState>\r",
      "  replaceState: ComputedRef<AnimationReplaceState>\r",
      "  startTime: WritableComputedRef<CSSNumberish | number | null>\r",
      "  currentTime: WritableComputedRef<CSSNumberish | null>\r",
      "  timeline: WritableComputedRef<AnimationTimeline | null>\r",
      "  playbackRate: WritableComputedRef<number>\r",
      "}\r",
      "\r",
      "type AnimateStoreKeys = Extract<keyof Animation, 'startTime' | 'currentTime' | 'timeline' | 'playbackRate' | 'pending' | 'playState' | 'replaceState'>\r",
      "\r",
      "type AnimateStore = Mutable<Pick<Animation, AnimateStoreKeys>>\r",
      "\r",
      "/**\r",
      " * Reactive Web Animations API\r",
      " *\r",
      " * @see https://vueuse.org/useAnimate\r",
      " * @param target\r",
      " * @param keyframes\r",
      " * @param options\r",
      " */\r",
      "export function useAnimate(\r",
      "  target: MaybeComputedElementRef,\r",
      "  keyframes: UseAnimateKeyframes,\r",
      "  options?: number | UseAnimateOptions,\r",
      "): UseAnimateReturn {\r",
      "  let config: UseAnimateOptions\r",
      "  let animateOptions: undefined | number | KeyframeAnimationOptions\r",
      "\r",
      "  if (isObject(options)) {\r",
      "    config = options\r",
      "    animateOptions = objectOmit(options, ['window', 'immediate', 'commitStyles', 'persist', 'onReady', 'onError'])\r",
      "  }\r",
      "  else {\r",
      "    config = { duration: options }\r",
      "    animateOptions = options\r",
      "  }\r",
      "\r",
      "  const {\r",
      "    window = defaultWindow,\r",
      "    immediate = true,\r",
      "    commitStyles,\r",
      "    persist,\r",
      "    playbackRate: _playbackRate = 1,\r",
      "    onReady,\r",
      "    onError = (e: unknown) => {\r",
      "      console.error(e)\r",
      "    },\r",
      "  } = config\r",
      "\r",
      "  const isSupported = useSupported(() => window && HTMLElement && 'animate' in HTMLElement.prototype)\r",
      "\r",
      "  const animate = shallowRef<Animation | undefined>(undefined)\r",
      "  const store = shallowReactive<AnimateStore>({\r",
      "    startTime: null,\r",
      "    currentTime: null,\r",
      "    timeline: null,\r",
      "    playbackRate: _playbackRate,\r",
      "    pending: false,\r",
      "    playState: immediate ? 'idle' : 'paused',\r",
      "    replaceState: 'active',\r",
      "  })\r",
      "\r",
      "  const pending = computed(() => store.pending)\r",
      "  const playState = computed(() => store.playState)\r",
      "  const replaceState = computed(() => store.replaceState)\r",
      "\r",
      "  const startTime = computed<CSSNumberish | number | null>({\r",
      "    get() {\r",
      "      return store.startTime\r",
      "    },\r",
      "    set(value) {\r",
      "      store.startTime = value\r",
      "      if (animate.value)\r",
      "        animate.value.startTime = value\r",
      "    },\r",
      "  })\r",
      "\r",
      "  const currentTime = computed({\r",
      "    get() {\r",
      "      return store.currentTime\r",
      "    },\r",
      "    set(value) {\r",
      "      store.currentTime = value\r",
      "      if (animate.value) {\r",
      "        animate.value.currentTime = value\r",
      "        syncResume()\r",
      "      }\r",
      "    },\r",
      "  })\r",
      "\r",
      "  const timeline = computed({\r",
      "    get() {\r",
      "      return store.timeline\r",
      "    },\r",
      "    set(value) {\r",
      "      store.timeline = value\r",
      "      if (animate.value)\r",
      "        animate.value.timeline = value\r",
      "    },\r",
      "  })\r",
      "\r",
      "  const playbackRate = computed({\r",
      "    get() {\r",
      "      return store.playbackRate\r",
      "    },\r",
      "    set(value) {\r",
      "      store.playbackRate = value\r",
      "      if (animate.value)\r",
      "        animate.value.playbackRate = value\r",
      "    },\r",
      "  })\r",
      "\r",
      "  const play = () => {\r",
      "    if (animate.value) {\r",
      "      try {\r",
      "        animate.value.play()\r",
      "        syncResume()\r",
      "      }\r",
      "      catch (e) {\r",
      "        syncPause()\r",
      "        onError(e)\r",
      "      }\r",
      "    }\r",
      "    else {\r",
      "      update()\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const pause = () => {\r",
      "    try {\r",
      "      animate.value?.pause()\r",
      "      syncPause()\r",
      "    }\r",
      "    catch (e) {\r",
      "      onError(e)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const reverse = () => {\r",
      "    !animate.value && update()\r",
      "    try {\r",
      "      animate.value?.reverse()\r",
      "      syncResume()\r",
      "    }\r",
      "    catch (e) {\r",
      "      syncPause()\r",
      "      onError(e)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const finish = () => {\r",
      "    try {\r",
      "      animate.value?.finish()\r",
      "      syncPause()\r",
      "    }\r",
      "    catch (e) {\r",
      "      onError(e)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const cancel = () => {\r",
      "    try {\r",
      "      animate.value?.cancel()\r",
      "      syncPause()\r",
      "    }\r",
      "    catch (e) {\r",
      "      onError(e)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  watch(() => unrefElement(target), (el) => {\r",
      "    el && update()\r",
      "  })\r",
      "\r",
      "  watch(() => keyframes, (value) => {\r",
      "    !animate.value && update()\r",
      "\r",
      "    if (!unrefElement(target) && animate.value) {\r",
      "      animate.value.effect = new KeyframeEffect(\r",
      "        unrefElement(target)!,\r",
      "        toValue(value),\r",
      "        animateOptions,\r",
      "      )\r",
      "    }\r",
      "  }, { deep: true })\r",
      "\r",
      "  tryOnMounted(() => {\r",
      "    nextTick(() => update(true))\r",
      "  })\r",
      "\r",
      "  tryOnScopeDispose(cancel)\r",
      "\r",
      "  function update(init?: boolean) {\r",
      "    const el = unrefElement(target)\r",
      "    if (!isSupported.value || !el)\r",
      "      return\r",
      "\r",
      "    animate.value = el.animate(toValue(keyframes), animateOptions)\r",
      "\r",
      "    if (commitStyles)\r",
      "      animate.value.commitStyles()\r",
      "    if (persist)\r",
      "      animate.value.persist()\r",
      "    if (_playbackRate !== 1)\r",
      "      animate.value.playbackRate = _playbackRate\r",
      "\r",
      "    if (init && !immediate)\r",
      "      animate.value.pause()\r",
      "    else\r",
      "      syncResume()\r",
      "\r",
      "    onReady?.(animate.value)\r",
      "  }\r",
      "\r",
      "  useEventListener(animate, ['cancel', 'finish', 'remove'], syncPause)\r",
      "\r",
      "  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\r",
      "    if (!animate.value)\r",
      "      return\r",
      "    store.pending = animate.value.pending\r",
      "    store.playState = animate.value.playState\r",
      "    store.replaceState = animate.value.replaceState\r",
      "    store.startTime = animate.value.startTime\r",
      "    store.currentTime = animate.value.currentTime\r",
      "    store.timeline = animate.value.timeline\r",
      "    store.playbackRate = animate.value.playbackRate\r",
      "  }, { immediate: false })\r",
      "\r",
      "  function syncResume() {\r",
      "    if (isSupported.value)\r",
      "      resumeRef()\r",
      "  }\r",
      "\r",
      "  function syncPause() {\r",
      "    if (isSupported.value && window)\r",
      "      window.requestAnimationFrame(pauseRef)\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    animate,\r",
      "\r",
      "    // actions\r",
      "    play,\r",
      "    pause,\r",
      "    reverse,\r",
      "    finish,\r",
      "    cancel,\r",
      "\r",
      "    // state\r",
      "    pending,\r",
      "    playState,\r",
      "    replaceState,\r",
      "    startTime,\r",
      "    currentTime,\r",
      "    timeline,\r",
      "    playbackRate,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { reactive, shallowRef } from 'vue'\r",
      "import { useAnimate } from '@vueuse/core'\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import type { MaybeElement } from '@vueuse/core'\r",
      "\r",
      "const el = shallowRef<MaybeElement>()\r",
      "\r",
      "const {\r",
      "  play,\r",
      "  pause,\r",
      "  reverse,\r",
      "  finish,\r",
      "  cancel,\r",
      "  startTime,\r",
      "  currentTime,\r",
      "  playbackRate,\r",
      "  playState,\r",
      "  replaceState,\r",
      "  pending,\r",
      "} = useAnimate(\r",
      "  el,\r",
      "  [\r",
      "    { clipPath: 'circle(20% at 0% 30%)' },\r",
      "    { clipPath: 'circle(20% at 50% 80%)' },\r",
      "    { clipPath: 'circle(20% at 100% 30%)' },\r",
      "  ],\r",
      "  {\r",
      "    duration: 3000,\r",
      "    iterations: 5,\r",
      "    direction: 'alternate',\r",
      "    easing: 'cubic-bezier(0.46, 0.03, 0.52, 0.96)',\r",
      "  },\r",
      ")\r",
      "\r",
      "const text = stringify(reactive({\r",
      "  startTime,\r",
      "  currentTime,\r",
      "  playbackRate,\r",
      "  playState,\r",
      "  replaceState,\r",
      "  pending,\r",
      "}))\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div class=\"flex items-center justify-center w-full h-60\">\r",
      "      <p ref=\"el\" class=\"text-5xl! text-$vp-c-brand font-800\">\r",
      "        VueUse useAnimate\r",
      "      </p>\r",
      "    </div>\r",
      "    <div>\r",
      "      <button v-if=\"playState === 'running'\" @click=\"pause\">\r",
      "        pause\r",
      "      </button>\r",
      "      <button v-else @click=\"play\">\r",
      "        play\r",
      "      </button>\r",
      "      <button @click=\"reverse\">\r",
      "        reverse\r",
      "      </button>\r",
      "      <button @click=\"finish\">\r",
      "        finish\r",
      "      </button>\r",
      "      <button @click=\"cancel\">\r",
      "        cancel\r",
      "      </button>\r",
      "    </div>\r",
      "    <pre class=\"code-block\">{{ text }}</pre>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useAsyncQueue - vueuse": {
    "prefix": "hvue useAsyncQueue - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useAsyncQueue\r",
      "\r",
      "Executes each asynchronous task sequentially and passes the current task result to the next task\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useAsyncQueue } from '@vueuse/core'\r",
      "\r",
      "function p1() {\r",
      "  return new Promise((resolve) => {\r",
      "    setTimeout(() => {\r",
      "      resolve(1000)\r",
      "    }, 10)\r",
      "  })\r",
      "}\r",
      "\r",
      "function p2(result: number) {\r",
      "  return new Promise((resolve) => {\r",
      "    setTimeout(() => {\r",
      "      resolve(1000 + result)\r",
      "    }, 20)\r",
      "  })\r",
      "}\r",
      "\r",
      "const { activeIndex, result } = useAsyncQueue([p1, p2])\r",
      "\r",
      "console.log(activeIndex.value) // current pending task index\r",
      "\r",
      "console.log(result) // the tasks result\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { noop } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { reactive, ref } from 'vue-demi'\r",
      "\r",
      "export type UseAsyncQueueTask<T> = (...args: any[]) => T | Promise<T>\r",
      "\r",
      "export interface UseAsyncQueueResult<T> {\r",
      "  state: 'aborted' | 'fulfilled' | 'pending' | 'rejected'\r",
      "  data: T | null\r",
      "}\r",
      "\r",
      "export interface UseAsyncQueueReturn<T> {\r",
      "  activeIndex: Ref<number>\r",
      "  result: T\r",
      "}\r",
      "\r",
      "export interface UseAsyncQueueOptions {\r",
      "  /**\r",
      "   * Interrupt tasks when current task fails.\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  interrupt?: boolean\r",
      "\r",
      "  /**\r",
      "   * Trigger it when the tasks fails.\r",
      "   *\r",
      "   */\r",
      "  onError?: () => void\r",
      "\r",
      "  /**\r",
      "   * Trigger it when the tasks ends.\r",
      "   *\r",
      "   */\r",
      "  onFinished?: () => void\r",
      "\r",
      "  /**\r",
      "   * A AbortSignal that can be used to abort the task.\r",
      "   */\r",
      "  signal?: AbortSignal\r",
      "}\r",
      "\r",
      "/**\r",
      " * Asynchronous queue task controller.\r",
      " *\r",
      " * @see https://vueuse.org/useAsyncQueue\r",
      " * @param tasks\r",
      " * @param options\r",
      " */\r",
      "export function useAsyncQueue<T1>(tasks: [UseAsyncQueueTask<T1>], options?: UseAsyncQueueOptions): UseAsyncQueueReturn<[UseAsyncQueueResult<T1>]>\r",
      "export function useAsyncQueue<T1, T2>(tasks: [UseAsyncQueueTask<T1>, UseAsyncQueueTask<T2>], options?: UseAsyncQueueOptions): UseAsyncQueueReturn<[UseAsyncQueueResult<T1>, UseAsyncQueueResult<T2>]>\r",
      "export function useAsyncQueue<T1, T2, T3>(tasks: [UseAsyncQueueTask<T1>, UseAsyncQueueTask<T2>, UseAsyncQueueTask<T3>], options?: UseAsyncQueueOptions): UseAsyncQueueReturn<[UseAsyncQueueResult<T1>, UseAsyncQueueResult<T2>, UseAsyncQueueResult<T3>]>\r",
      "export function useAsyncQueue<T1, T2, T3, T4>(tasks: [UseAsyncQueueTask<T1>, UseAsyncQueueTask<T2>, UseAsyncQueueTask<T3>, UseAsyncQueueTask<T4>], options?: UseAsyncQueueOptions): UseAsyncQueueReturn<[UseAsyncQueueResult<T1>, UseAsyncQueueResult<T2>, UseAsyncQueueResult<T3>, UseAsyncQueueResult<T4>]>\r",
      "export function useAsyncQueue<T1, T2, T3, T4, T5>(tasks: [UseAsyncQueueTask<T1>, UseAsyncQueueTask<T2>, UseAsyncQueueTask<T3>, UseAsyncQueueTask<T4>, UseAsyncQueueTask<T5>], options?: UseAsyncQueueOptions): UseAsyncQueueReturn<[UseAsyncQueueResult<T1>, UseAsyncQueueResult<T2>, UseAsyncQueueResult<T3>, UseAsyncQueueResult<T4>, UseAsyncQueueResult<T5>]>\r",
      "export function useAsyncQueue<T>(tasks: UseAsyncQueueTask<T>[], options?: UseAsyncQueueOptions): UseAsyncQueueReturn<UseAsyncQueueResult<T>[]>\r",
      "export function useAsyncQueue<T = any>(tasks: UseAsyncQueueTask<any>[], options: UseAsyncQueueOptions = {}): UseAsyncQueueReturn<UseAsyncQueueResult<T>[]> {\r",
      "  const {\r",
      "    interrupt = true,\r",
      "    onError = noop,\r",
      "    onFinished = noop,\r",
      "    signal,\r",
      "  } = options\r",
      "\r",
      "  const promiseState: Record<\r",
      "    UseAsyncQueueResult<T>['state'],\r",
      "    UseAsyncQueueResult<T>['state']\r",
      "  > = {\r",
      "    aborted: 'aborted',\r",
      "    fulfilled: 'fulfilled',\r",
      "    pending: 'pending',\r",
      "    rejected: 'rejected',\r",
      "  }\r",
      "\r",
      "  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }))\r",
      "\r",
      "  const result = reactive(initialResult) as UseAsyncQueueResult<T>[]\r",
      "\r",
      "  const activeIndex = ref<number>(-1)\r",
      "\r",
      "  if (!tasks || tasks.length === 0) {\r",
      "    onFinished()\r",
      "    return {\r",
      "      activeIndex,\r",
      "      result,\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function updateResult(state: UseAsyncQueueResult<T>['state'], res: unknown) {\r",
      "    activeIndex.value++\r",
      "    result[activeIndex.value].data = res as T\r",
      "    result[activeIndex.value].state = state\r",
      "  }\r",
      "\r",
      "  tasks.reduce((prev, curr) => {\r",
      "    return prev\r",
      "      .then((prevRes) => {\r",
      "        if (signal?.aborted) {\r",
      "          updateResult(promiseState.aborted, new Error('aborted'))\r",
      "          return\r",
      "        }\r",
      "\r",
      "        if (\r",
      "          result[activeIndex.value]?.state === promiseState.rejected\r",
      "          && interrupt\r",
      "        ) {\r",
      "          onFinished()\r",
      "          return\r",
      "        }\r",
      "\r",
      "        const done = curr(prevRes).then((currentRes: any) => {\r",
      "          updateResult(promiseState.fulfilled, currentRes)\r",
      "          activeIndex.value === tasks.length - 1 && onFinished()\r",
      "          return currentRes\r",
      "        })\r",
      "\r",
      "        if (!signal)\r",
      "          return done\r",
      "\r",
      "        return Promise.race([done, whenAborted(signal)])\r",
      "      })\r",
      "      .catch((e) => {\r",
      "        if (signal?.aborted) {\r",
      "          updateResult(promiseState.aborted, e)\r",
      "          return e\r",
      "        }\r",
      "\r",
      "        updateResult(promiseState.rejected, e)\r",
      "        onError()\r",
      "        return e\r",
      "      })\r",
      "  }, Promise.resolve())\r",
      "\r",
      "  return {\r",
      "    activeIndex,\r",
      "    result,\r",
      "  }\r",
      "}\r",
      "\r",
      "function whenAborted(signal: AbortSignal): Promise<never> {\r",
      "  return new Promise((resolve, reject) => {\r",
      "    const error = new Error('aborted')\r",
      "\r",
      "    if (signal.aborted)\r",
      "      reject(error)\r",
      "    else\r",
      "      signal.addEventListener('abort', () => reject(error), { once: true })\r",
      "  })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useAsyncQueue } from '@vueuse/core'\r",
      "\r",
      "function p1() {\r",
      "  return new Promise((resolve) => {\r",
      "    setTimeout(() => {\r",
      "      resolve(1000)\r",
      "    }, 10)\r",
      "  })\r",
      "}\r",
      "\r",
      "function p2(result: number) {\r",
      "  return new Promise((resolve) => {\r",
      "    setTimeout(() => {\r",
      "      resolve(1000 + result)\r",
      "    }, 20)\r",
      "  })\r",
      "}\r",
      "\r",
      "const { activeIndex, result } = useAsyncQueue([p1, p2])\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <note>activeIndex: {{ activeIndex }}</note>\r",
      "    <note>result: {{ result }}</note>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useAsyncState - vueuse": {
    "prefix": "hvue useAsyncState - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: State\r",
      "---\r",
      "\r",
      "# useAsyncState\r",
      "\r",
      "Reactive async state. Will not block your setup function and will trigger changes once the promise is ready.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import axios from 'axios'\r",
      "import { useAsyncState } from '@vueuse/core'\r",
      "\r",
      "const { state, isReady, isLoading } = useAsyncState(\r",
      "  axios\r",
      "    .get('https://jsonplaceholder.typicode.com/todos/1')\r",
      "    .then(t => t.data),\r",
      "  { id: null },\r",
      ")\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { noop, promiseTimeout, until } from '@vueuse/shared'\r",
      "import type { Ref, UnwrapRef } from 'vue-demi'\r",
      "import { ref, shallowRef } from 'vue-demi'\r",
      "\r",
      "export interface UseAsyncStateReturnBase<Data, Params extends any[], Shallow extends boolean> {\r",
      "  state: Shallow extends true ? Ref<Data> : Ref<UnwrapRef<Data>>\r",
      "  isReady: Ref<boolean>\r",
      "  isLoading: Ref<boolean>\r",
      "  error: Ref<unknown>\r",
      "  execute: (delay?: number, ...args: Params) => Promise<Data>\r",
      "}\r",
      "\r",
      "export type UseAsyncStateReturn<Data, Params extends any[], Shallow extends boolean> =\r",
      "  UseAsyncStateReturnBase<Data, Params, Shallow>\r",
      "  & PromiseLike<UseAsyncStateReturnBase<Data, Params, Shallow>>\r",
      "\r",
      "export interface UseAsyncStateOptions<Shallow extends boolean, D = any> {\r",
      "  /**\r",
      "   * Delay for executing the promise. In milliseconds.\r",
      "   *\r",
      "   * @default 0\r",
      "   */\r",
      "  delay?: number\r",
      "\r",
      "  /**\r",
      "   * Execute the promise right after the function is invoked.\r",
      "   * Will apply the delay if any.\r",
      "   *\r",
      "   * When set to false, you will need to execute it manually.\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "\r",
      "  /**\r",
      "   * Callback when error is caught.\r",
      "   */\r",
      "  onError?: (e: unknown) => void\r",
      "\r",
      "  /**\r",
      "   * Callback when success is caught.\r",
      "   * @param {D} data\r",
      "   */\r",
      "  onSuccess?: (data: D) => void\r",
      "\r",
      "  /**\r",
      "   * Sets the state to initialState before executing the promise.\r",
      "   *\r",
      "   * This can be useful when calling the execute function more than once (for\r",
      "   * example, to refresh data). When set to false, the current state remains\r",
      "   * unchanged until the promise resolves.\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  resetOnExecute?: boolean\r",
      "\r",
      "  /**\r",
      "   * Use shallowRef.\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  shallow?: Shallow\r",
      "  /**\r",
      "   *\r",
      "   * An error is thrown when executing the execute function\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  throwError?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive async state. Will not block your setup function and will trigger changes once\r",
      " * the promise is ready.\r",
      " *\r",
      " * @see https://vueuse.org/useAsyncState\r",
      " * @param promise         The promise / async function to be resolved\r",
      " * @param initialState    The initial state, used until the first evaluation finishes\r",
      " * @param options\r",
      " */\r",
      "export function useAsyncState<Data, Params extends any[] = [], Shallow extends boolean = true>(\r",
      "  promise: Promise<Data> | ((...args: Params) => Promise<Data>),\r",
      "  initialState: Data,\r",
      "  options?: UseAsyncStateOptions<Shallow, Data>,\r",
      "): UseAsyncStateReturn<Data, Params, Shallow> {\r",
      "  const {\r",
      "    immediate = true,\r",
      "    delay = 0,\r",
      "    onError = noop,\r",
      "    onSuccess = noop,\r",
      "    resetOnExecute = true,\r",
      "    shallow = true,\r",
      "    throwError,\r",
      "  } = options ?? {}\r",
      "  const state = shallow ? shallowRef(initialState) : ref(initialState)\r",
      "  const isReady = ref(false)\r",
      "  const isLoading = ref(false)\r",
      "  const error = shallowRef<unknown | undefined>(undefined)\r",
      "\r",
      "  async function execute(delay = 0, ...args: any[]) {\r",
      "    if (resetOnExecute)\r",
      "      state.value = initialState\r",
      "    error.value = undefined\r",
      "    isReady.value = false\r",
      "    isLoading.value = true\r",
      "\r",
      "    if (delay > 0)\r",
      "      await promiseTimeout(delay)\r",
      "\r",
      "    const _promise = typeof promise === 'function'\r",
      "      ? promise(...args as Params)\r",
      "      : promise\r",
      "\r",
      "    try {\r",
      "      const data = await _promise\r",
      "      state.value = data\r",
      "      isReady.value = true\r",
      "      onSuccess(data)\r",
      "    }\r",
      "    catch (e) {\r",
      "      error.value = e\r",
      "      onError(e)\r",
      "      if (throwError)\r",
      "        throw e\r",
      "    }\r",
      "    finally {\r",
      "      isLoading.value = false\r",
      "    }\r",
      "\r",
      "    return state.value as Data\r",
      "  }\r",
      "\r",
      "  if (immediate)\r",
      "    execute(delay)\r",
      "\r",
      "  const shell: UseAsyncStateReturnBase<Data, Params, Shallow> = {\r",
      "    state: state as Shallow extends true ? Ref<Data> : Ref<UnwrapRef<Data>>,\r",
      "    isReady,\r",
      "    isLoading,\r",
      "    error,\r",
      "    execute,\r",
      "  }\r",
      "\r",
      "  function waitUntilIsLoaded() {\r",
      "    return new Promise<UseAsyncStateReturnBase<Data, Params, Shallow>>((resolve, reject) => {\r",
      "      until(isLoading).toBe(false)\r",
      "        .then(() => resolve(shell))\r",
      "        .catch(reject)\r",
      "    })\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    ...shell,\r",
      "    then(onFulfilled, onRejected) {\r",
      "      return waitUntilIsLoaded()\r",
      "        .then(onFulfilled, onRejected)\r",
      "    },\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import axios from 'axios'\r",
      "import YAML from 'js-yaml'\r",
      "import { useAsyncState } from '@vueuse/core'\r",
      "\r",
      "const { isLoading, state, isReady, execute } = useAsyncState(\r",
      "  (args) => {\r",
      "    const id = args?.id || 1\r",
      "    return axios.get(`https://jsonplaceholder.typicode.com/todos/${id}`).then(t => t.data)\r",
      "  },\r",
      "  {},\r",
      "  {\r",
      "    delay: 2000,\r",
      "    resetOnExecute: false,\r",
      "  },\r",
      ")\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <note>Ready: {{ isReady.toString() }}</note>\r",
      "    <note>Loading: {{ isLoading.toString() }}</note>\r",
      "    <pre lang=\"json\" class=\"ml-2\">{{ YAML.dump(state) }}</pre>\r",
      "    <button @click=\"execute(2000, { id: 2 })\">\r",
      "      Execute\r",
      "    </button>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useBase64 - vueuse": {
    "prefix": "hvue useBase64 - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useBase64\r",
      "\r",
      "Reactive base64 transforming. Supports plain text, buffer, files, canvas, objects, maps, sets and images.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { Ref, ref } from 'vue'\r",
      "import { useBase64 } from '@vueuse/core'\r",
      "\r",
      "const text = ref('')\r",
      "\r",
      "const { base64 } = useBase64(text)\r",
      "```\r",
      "\r",
      "If you use object, array, map or set you can provide serializer in options. Otherwise, your data will be serialized by default serializer.\r",
      "Objects and arrays will be transformed in string by JSON.stringify. Map and set will be transformed in object and array respectively before stringify.\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { isRef, ref, watch } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { isClient, toValue } from '@vueuse/shared'\r",
      "import { getDefaultSerialization } from './serialization'\r",
      "\r",
      "export interface ToDataURLOptions {\r",
      "  /**\r",
      "   * MIME type\r",
      "   */\r",
      "  type?: string | undefined\r",
      "  /**\r",
      "   * Image quality of jpeg or webp\r",
      "   */\r",
      "  quality?: any\r",
      "}\r",
      "\r",
      "export interface UseBase64ObjectOptions<T> {\r",
      "  serializer: (v: T) => string\r",
      "}\r",
      "\r",
      "export interface UseBase64Return {\r",
      "  base64: Ref<string>\r",
      "  promise: Ref<Promise<string>>\r",
      "  execute: () => Promise<string>\r",
      "}\r",
      "\r",
      "export function useBase64(target: MaybeRefOrGetter<string>): UseBase64Return\r",
      "export function useBase64(target: MaybeRefOrGetter<Blob>): UseBase64Return\r",
      "export function useBase64(target: MaybeRefOrGetter<ArrayBuffer>): UseBase64Return\r",
      "export function useBase64(target: MaybeRefOrGetter<HTMLCanvasElement>, options?: ToDataURLOptions): UseBase64Return\r",
      "export function useBase64(target: MaybeRefOrGetter<HTMLImageElement>, options?: ToDataURLOptions): UseBase64Return\r",
      "export function useBase64<T extends Record<string, unknown>>(target: MaybeRefOrGetter<T>, options?: UseBase64ObjectOptions<T>): UseBase64Return\r",
      "export function useBase64<T extends Map<string, unknown>>(target: MaybeRefOrGetter<T>, options?: UseBase64ObjectOptions<T>): UseBase64Return\r",
      "export function useBase64<T extends Set<unknown>>(target: MaybeRefOrGetter<T>, options?: UseBase64ObjectOptions<T>): UseBase64Return\r",
      "export function useBase64<T>(target: MaybeRefOrGetter<T[]>, options?: UseBase64ObjectOptions<T[]>): UseBase64Return\r",
      "export function useBase64(\r",
      "  target: any,\r",
      "  options?: any,\r",
      ") {\r",
      "  const base64 = ref('')\r",
      "  const promise = ref() as Ref<Promise<string>>\r",
      "\r",
      "  function execute() {\r",
      "    if (!isClient)\r",
      "      return\r",
      "\r",
      "    promise.value = new Promise<string>((resolve, reject) => {\r",
      "      try {\r",
      "        const _target = toValue(target)\r",
      "        if (_target == null) {\r",
      "          resolve('')\r",
      "        }\r",
      "        else if (typeof _target === 'string') {\r",
      "          resolve(blobToBase64(new Blob([_target], { type: 'text/plain' })))\r",
      "        }\r",
      "        else if (_target instanceof Blob) {\r",
      "          resolve(blobToBase64(_target))\r",
      "        }\r",
      "        else if (_target instanceof ArrayBuffer) {\r",
      "          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))))\r",
      "        }\r",
      "        else if (_target instanceof HTMLCanvasElement) {\r",
      "          resolve(_target.toDataURL(options?.type, options?.quality))\r",
      "        }\r",
      "        else if (_target instanceof HTMLImageElement) {\r",
      "          const img = _target.cloneNode(false) as HTMLImageElement\r",
      "          img.crossOrigin = 'Anonymous'\r",
      "          imgLoaded(img).then(() => {\r",
      "            const canvas = document.createElement('canvas')\r",
      "            const ctx = canvas.getContext('2d')!\r",
      "            canvas.width = img.width\r",
      "            canvas.height = img.height\r",
      "            ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\r",
      "            resolve(canvas.toDataURL(options?.type, options?.quality))\r",
      "          }).catch(reject)\r",
      "        }\r",
      "        else if (typeof _target === 'object') {\r",
      "          const _serializeFn = options?.serializer || getDefaultSerialization(_target)\r",
      "\r",
      "          const serialized = _serializeFn(_target)\r",
      "\r",
      "          return resolve(blobToBase64(new Blob([serialized], { type: 'application/json' })))\r",
      "        }\r",
      "        else {\r",
      "          reject(new Error('target is unsupported types'))\r",
      "        }\r",
      "      }\r",
      "      catch (error) {\r",
      "        reject(error)\r",
      "      }\r",
      "    })\r",
      "    promise.value.then(res => base64.value = res)\r",
      "    return promise.value\r",
      "  }\r",
      "\r",
      "  if (isRef(target) || typeof target === 'function')\r",
      "    watch(target, execute, { immediate: true })\r",
      "  else\r",
      "    execute()\r",
      "\r",
      "  return {\r",
      "    base64,\r",
      "    promise,\r",
      "    execute,\r",
      "  }\r",
      "}\r",
      "\r",
      "function imgLoaded(img: HTMLImageElement) {\r",
      "  return new Promise<void>((resolve, reject) => {\r",
      "    if (!img.complete) {\r",
      "      img.onload = () => {\r",
      "        resolve()\r",
      "      }\r",
      "      img.onerror = reject\r",
      "    }\r",
      "    else {\r",
      "      resolve()\r",
      "    }\r",
      "  })\r",
      "}\r",
      "\r",
      "function blobToBase64(blob: Blob) {\r",
      "  return new Promise<string>((resolve, reject) => {\r",
      "    const fr = new FileReader()\r",
      "    fr.onload = (e) => {\r",
      "      resolve(e.target!.result as string)\r",
      "    }\r",
      "    fr.onerror = reject\r",
      "    fr.readAsDataURL(blob)\r",
      "  })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import type { Ref } from 'vue'\r",
      "import { ref } from 'vue'\r",
      "import { useBase64 } from '@vueuse/core'\r",
      "\r",
      "const text = ref('')\r",
      "const file = ref() as Ref<File>\r",
      "const image = ref() as Ref<HTMLImageElement>\r",
      "\r",
      "const { base64: textBase64 } = useBase64(text)\r",
      "const { base64: fileBase64 } = useBase64(file)\r",
      "const { base64: imageBase64 } = useBase64(image)\r",
      "const { base64: bufferBase64 } = useBase64(new ArrayBuffer(8))\r",
      "\r",
      "function onFileInput(e: Event) {\r",
      "  file.value = (e.target as HTMLInputElement).files![0]\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div space-y-4>\r",
      "    <div grid md:grid-cols-2 gap-2>\r",
      "      <div>\r",
      "        <span>Text Input</span>\r",
      "        <textarea v-model=\"text\" h-40 type=\"text\" placeholder=\"Type something...\" />\r",
      "      </div>\r",
      "      <div>\r",
      "        <span>Base64</span>\r",
      "        <textarea h-40 :value=\"textBase64\" readonly />\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <div grid md:grid-cols-2 gap-2>\r",
      "      <div>\r",
      "        <span>Buffer Input</span>\r",
      "        <pre mt-2>new ArrayBuffer(1024)</pre>\r",
      "      </div>\r",
      "      <div>\r",
      "        <span>Base64</span>\r",
      "        <textarea h-40 :value=\"bufferBase64\" readonly />\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <div grid md:grid-cols-2 gap-2>\r",
      "      <div>\r",
      "        <span>File Input</span>\r",
      "        <div>\r",
      "          <input mt-2 type=\"file\" @input=\"onFileInput\">\r",
      "        </div>\r",
      "      </div>\r",
      "      <div>\r",
      "        <span>Base64</span>\r",
      "        <textarea h-40 :value=\"fileBase64\" readonly />\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <div grid md:grid-cols-2 gap-2>\r",
      "      <div>\r",
      "        <span>Image Input</span>\r",
      "        <img\r",
      "          ref=\"image\"\r",
      "          w-full h-40 object-cover\r",
      "          class=\"rounded mt-2\"\r",
      "          src=\"https://images.unsplash.com/photo-1494256997604-768d1f608cac?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=200&q=80\"\r",
      "        >\r",
      "      </div>\r",
      "      <div>\r",
      "        <span>Base64</span>\r",
      "        <textarea h-40 :value=\"imageBase64\" readonly />\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      "textarea {\r",
      "  min-width: 0 !important;\r",
      "  width: 100%;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useBattery - vueuse": {
    "prefix": "hvue useBattery - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useBattery\r",
      "\r",
      "Reactive [Battery Status API](https://developer.mozilla.org/en-US/docs/Web/API/Battery_Status_API), more often referred to as the Battery API, provides information about the system's battery charge level and lets you be notified by events that are sent when the battery level or charging status change. This can be used to adjust your app's resource usage to reduce battery drain when the battery is low, or to save changes before the battery runs out in order to prevent data loss.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useBattery } from '@vueuse/core'\r",
      "\r",
      "const { charging, chargingTime, dischargingTime, level } = useBattery()\r",
      "```\r",
      "\r",
      "| State           | Type      | Description                                                       |\r",
      "| --------------- | --------- | ----------------------------------------------------------------- |\r",
      "| charging        | `Boolean` | If the device is currently charging.                              |\r",
      "| chargingTime    | `Number`  | The number of seconds until the device becomes fully charged.     |\r",
      "| dischargingTime | `Number`  | The number of seconds before the device becomes fully discharged. |\r",
      "| level           | `Number`  | A number between 0 and 1 representing the current charge level.   |\r",
      "\r",
      "## Use-cases\r",
      "\r",
      "Our applications normally are not empathetic to battery level, we can make a few adjustments to our applications that will be more friendly to low battery users.\r",
      "\r",
      "- Trigger a special \"dark-mode\" battery saver theme settings.\r",
      "- Stop auto playing videos in news feeds.\r",
      "- Disable some background workers that are not critical.\r",
      "- Limit network calls and reduce CPU/Memory consumption.\r",
      "\r",
      "\r",
      "## Component Usage\r",
      "```html\r",
      "<UseBattery v-slot=\"{ charging }\">\r",
      "  Is Charging: {{ charging }}\r",
      "</UseBattery>\r",
      "```\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */\r",
      "\r",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableNavigator } from '../_configurable'\r",
      "import { defaultNavigator } from '../_configurable'\r",
      "\r",
      "export interface BatteryManager extends EventTarget {\r",
      "  charging: boolean\r",
      "  chargingTime: number\r",
      "  dischargingTime: number\r",
      "  level: number\r",
      "}\r",
      "\r",
      "type NavigatorWithBattery = Navigator & {\r",
      "  getBattery: () => Promise<BatteryManager>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive Battery Status API.\r",
      " *\r",
      " * @see https://vueuse.org/useBattery\r",
      " * @param options\r",
      " */\r",
      "export function useBattery({ navigator = defaultNavigator }: ConfigurableNavigator = {}) {\r",
      "  const events = ['chargingchange', 'chargingtimechange', 'dischargingtimechange', 'levelchange']\r",
      "\r",
      "  const isSupported = useSupported(() => navigator && 'getBattery' in navigator)\r",
      "\r",
      "  const charging = ref(false)\r",
      "  const chargingTime = ref(0)\r",
      "  const dischargingTime = ref(0)\r",
      "  const level = ref(1)\r",
      "\r",
      "  let battery: BatteryManager | null\r",
      "\r",
      "  function updateBatteryInfo(this: BatteryManager) {\r",
      "    charging.value = this.charging\r",
      "    chargingTime.value = this.chargingTime || 0\r",
      "    dischargingTime.value = this.dischargingTime || 0\r",
      "    level.value = this.level\r",
      "  }\r",
      "\r",
      "  if (isSupported.value) {\r",
      "    (navigator as NavigatorWithBattery)\r",
      "      .getBattery()\r",
      "      .then((_battery) => {\r",
      "        battery = _battery\r",
      "        updateBatteryInfo.call(battery)\r",
      "        useEventListener(battery, events, updateBatteryInfo, { passive: true })\r",
      "      })\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    charging,\r",
      "    chargingTime,\r",
      "    dischargingTime,\r",
      "    level,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseBatteryReturn = ReturnType<typeof useBattery>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { reactive } from 'vue'\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useBattery } from '@vueuse/core'\r",
      "\r",
      "const battery = reactive(useBattery())\r",
      "const text = stringify(battery)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <pre lang=\"yaml\">{{ text }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useBluetooth - vueuse": {
    "prefix": "hvue useBluetooth - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useBluetooth\r",
      "\r",
      "Reactive [Web Bluetooth API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Bluetooth_API). Provides the ability to connect and interact with Bluetooth Low Energy peripherals.\r",
      "\r",
      "The Web Bluetooth API lets websites discover and communicate with devices over the Bluetooth 4 wireless standard using the Generic Attribute Profile (GATT).\r",
      "\r",
      "N.B. It is currently partially implemented in Android M, Chrome OS, Mac, and Windows 10. For a full overview of browser compatibility please see [Web Bluetooth API Browser Compatibility](https://developer.mozilla.org/en-US/docs/Web/API/Web_Bluetooth_API#browser_compatibility)\r",
      "\r",
      "N.B. There are a number of caveats to be aware of with the web bluetooth API specification. Please refer to the [Web Bluetooth W3C Draft Report](https://webbluetoothcg.github.io/web-bluetooth/) for numerous caveats around device detection and connection.\r",
      "\r",
      "N.B. This API is not available in Web Workers (not exposed via WorkerNavigator).\r",
      "\r",
      "## Usage Default\r",
      "\r",
      "```ts\r",
      "import { useBluetooth } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isSupported,\r",
      "  isConnected,\r",
      "  device,\r",
      "  requestDevice,\r",
      "  server,\r",
      "} = useBluetooth({\r",
      "  acceptAllDevices: true,\r",
      "})\r",
      "```\r",
      "\r",
      "```vue\r",
      "<template>\r",
      "  <button @click=\"requestDevice()\">\r",
      "    Request Bluetooth Device\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "\r",
      "When the device has paired and is connected, you can then work with the server object as you wish.\r",
      "\r",
      "## Usage Battery Level Example\r",
      "\r",
      "This sample illustrates the use of the Web Bluetooth API to read battery level and be notified of changes from a nearby Bluetooth Device advertising Battery information with Bluetooth Low Energy.\r",
      "\r",
      "Here, we use the characteristicvaluechanged event listener to handle reading battery level characteristic value. This event listener will optionally handle upcoming notifications as well.\r",
      "\r",
      "```ts\r",
      "import { pausableWatch, useBluetooth } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isSupported,\r",
      "  isConnected,\r",
      "  device,\r",
      "  requestDevice,\r",
      "  server,\r",
      "} = useBluetooth({\r",
      "  acceptAllDevices: true,\r",
      "  optionalServices: [\r",
      "    'battery_service',\r",
      "  ],\r",
      "})\r",
      "\r",
      "const batteryPercent = ref<undefined | number>()\r",
      "\r",
      "const isGettingBatteryLevels = ref(false)\r",
      "\r",
      "async function getBatteryLevels() {\r",
      "  isGettingBatteryLevels.value = true\r",
      "\r",
      "  // Get the battery service:\r",
      "  const batteryService = await server.getPrimaryService('battery_service')\r",
      "\r",
      "  // Get the current battery level\r",
      "  const batteryLevelCharacteristic = await batteryService.getCharacteristic(\r",
      "    'battery_level',\r",
      "  )\r",
      "\r",
      "  // Listen to when characteristic value changes on `characteristicvaluechanged` event:\r",
      "  batteryLevelCharacteristic.addEventListener('characteristicvaluechanged', (event) => {\r",
      "    batteryPercent.value = event.target.value.getUint8(0)\r",
      "  })\r",
      "\r",
      "  // Convert received buffer to number:\r",
      "  const batteryLevel = await batteryLevelCharacteristic.readValue()\r",
      "\r",
      "  batteryPercent.value = await batteryLevel.getUint8(0)\r",
      "}\r",
      "\r",
      "const { stop } = pausableWatch(isConnected, (newIsConnected) => {\r",
      "  if (!newIsConnected || !server.value || isGettingBatteryLevels.value)\r",
      "    return\r",
      "  // Attempt to get the battery levels of the device:\r",
      "  getBatteryLevels()\r",
      "  // We only want to run this on the initial connection, as we will use an event listener to handle updates:\r",
      "  stop()\r",
      "})\r",
      "```\r",
      "\r",
      "```vue\r",
      "<template>\r",
      "  <button @click=\"requestDevice()\">\r",
      "    Request Bluetooth Device\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "\r",
      "More samples can be found on [Google Chrome's Web Bluetooth Samples](https://googlechrome.github.io/samples/web-bluetooth/).\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { computed, ref, shallowRef, watch } from 'vue-demi'\r",
      "import { tryOnMounted, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { ConfigurableNavigator } from '../_configurable'\r",
      "\r",
      "import { defaultNavigator } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "export interface UseBluetoothRequestDeviceOptions {\r",
      "  /**\r",
      "    *\r",
      "    * An array of BluetoothScanFilters. This filter consists of an array\r",
      "    * of BluetoothServiceUUIDs, a name parameter, and a namePrefix parameter.\r",
      "    *\r",
      "    */\r",
      "  filters?: BluetoothLEScanFilter[] | undefined\r",
      "  /**\r",
      "    *\r",
      "    * An array of BluetoothServiceUUIDs.\r",
      "    *\r",
      "    * @see https://developer.mozilla.org/en-US/docs/Web/API/BluetoothRemoteGATTService/uuid\r",
      "    *\r",
      "    */\r",
      "  optionalServices?: BluetoothServiceUUID[] | undefined\r",
      "}\r",
      "\r",
      "export interface UseBluetoothOptions extends UseBluetoothRequestDeviceOptions, ConfigurableNavigator {\r",
      "  /**\r",
      "    *\r",
      "    * A boolean value indicating that the requesting script can accept all Bluetooth\r",
      "    * devices. The default is false.\r",
      "    *\r",
      "    * !! This may result in a bunch of unrelated devices being shown\r",
      "    * in the chooser and energy being wasted as there are no filters.\r",
      "    *\r",
      "    *\r",
      "    * Use it with caution.\r",
      "    *\r",
      "    * @default false\r",
      "    *\r",
      "    */\r",
      "  acceptAllDevices?: boolean\r",
      "}\r",
      "\r",
      "export function useBluetooth(options?: UseBluetoothOptions): UseBluetoothReturn {\r",
      "  let {\r",
      "    acceptAllDevices = false,\r",
      "  } = options || {}\r",
      "\r",
      "  const {\r",
      "    filters = undefined,\r",
      "    optionalServices = undefined,\r",
      "    navigator = defaultNavigator,\r",
      "  } = options || {}\r",
      "\r",
      "  const isSupported = useSupported(() => navigator && 'bluetooth' in navigator)\r",
      "\r",
      "  const device = shallowRef<undefined | BluetoothDevice>(undefined)\r",
      "\r",
      "  const error = shallowRef<unknown | null>(null)\r",
      "\r",
      "  watch(device, () => {\r",
      "    connectToBluetoothGATTServer()\r",
      "  })\r",
      "\r",
      "  async function requestDevice(): Promise<void> {\r",
      "    // This is the function can only be called if Bluetooth API is supported:\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "\r",
      "    // Reset any errors we currently have:\r",
      "    error.value = null\r",
      "\r",
      "    // If filters specified, we need to ensure we  don't accept all devices:\r",
      "    if (filters && filters.length > 0)\r",
      "      acceptAllDevices = false\r",
      "\r",
      "    try {\r",
      "      device.value = await navigator?.bluetooth.requestDevice({\r",
      "        acceptAllDevices,\r",
      "        filters,\r",
      "        optionalServices,\r",
      "      })\r",
      "    }\r",
      "    catch (err) {\r",
      "      error.value = err\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const server = ref<undefined | BluetoothRemoteGATTServer>()\r",
      "\r",
      "  const isConnected = computed((): boolean => {\r",
      "    return server.value?.connected || false\r",
      "  })\r",
      "\r",
      "  async function connectToBluetoothGATTServer() {\r",
      "    // Reset any errors we currently have:\r",
      "    error.value = null\r",
      "\r",
      "    if (device.value && device.value.gatt) {\r",
      "      // Add callback to gattserverdisconnected event:\r",
      "      device.value.addEventListener('gattserverdisconnected', () => {})\r",
      "\r",
      "      try {\r",
      "        // Connect to the device:\r",
      "        server.value = await device.value.gatt.connect()\r",
      "      }\r",
      "      catch (err) {\r",
      "        error.value = err\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "\r",
      "  tryOnMounted(() => {\r",
      "    if (device.value)\r",
      "      device.value.gatt?.connect()\r",
      "  })\r",
      "\r",
      "  tryOnScopeDispose(() => {\r",
      "    if (device.value)\r",
      "      device.value.gatt?.disconnect()\r",
      "  })\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    isConnected,\r",
      "    // Device:\r",
      "    device,\r",
      "    requestDevice,\r",
      "    // Server:\r",
      "    server,\r",
      "    // Errors:\r",
      "    error,\r",
      "  }\r",
      "}\r",
      "\r",
      "export interface UseBluetoothReturn {\r",
      "  isSupported: Ref<boolean>\r",
      "  isConnected: ComputedRef<boolean>\r",
      "  device: Ref<BluetoothDevice | undefined>\r",
      "  requestDevice: () => Promise<void>\r",
      "  server: Ref<BluetoothRemoteGATTServer | undefined>\r",
      "  error: Ref<unknown | null>\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useBluetooth } from '.'\r",
      "\r",
      "const {\r",
      "  isConnected,\r",
      "  isSupported,\r",
      "  device,\r",
      "  requestDevice,\r",
      "  error,\r",
      "} = useBluetooth({\r",
      "  acceptAllDevices: true,\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"grid grid-cols-1 gap-x-4 gap-y-4\">\r",
      "    <div>{{ isSupported ? 'Bluetooth Web API Supported' : 'Your browser does not support the Bluetooth Web API' }}</div>\r",
      "\r",
      "    <div v-if=\"isSupported\">\r",
      "      <button @click=\"requestDevice()\">\r",
      "        Request Bluetooth Device\r",
      "      </button>\r",
      "    </div>\r",
      "\r",
      "    <div v-if=\"device\">\r",
      "      <p>Device Name: {{ device.name }}</p>\r",
      "    </div>\r",
      "\r",
      "    <div v-if=\"isConnected\" class=\"bg-green-500 text-white p-3 rounded-md\">\r",
      "      <p>Connected</p>\r",
      "    </div>\r",
      "\r",
      "    <div v-if=\"!isConnected\" class=\"bg-orange-800 text-white p-3 rounded-md\">\r",
      "      <p>Not Connected</p>\r",
      "    </div>\r",
      "\r",
      "    <div v-if=\"error\">\r",
      "      <div>Errors:</div>\r",
      "      <pre>\r",
      "      <code class=\"block p-5 whitespace-pre\">{{ error }}</code>\r",
      "    </pre>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useBreakpoints - vueuse": {
    "prefix": "hvue useBreakpoints - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useBreakpoints\r",
      "\r",
      "Reactive viewport breakpoints.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { breakpointsTailwind, useBreakpoints } from '@vueuse/core'\r",
      "\r",
      "const breakpoints = useBreakpoints(breakpointsTailwind)\r",
      "\r",
      "const smAndLarger = breakpoints.greaterOrEqual('sm') // sm and larger\r",
      "const largerThanSm = breakpoints.greater('sm') // only larger than sm\r",
      "const lgAndSmaller = breakpoints.smallerOrEqual('lg') // lg and smaller\r",
      "const smallerThanLg = breakpoints.smaller('lg') // only smaller than lg\r",
      "```\r",
      "\r",
      "```js\r",
      "import { useBreakpoints } from '@vueuse/core'\r",
      "\r",
      "const breakpoints = useBreakpoints({\r",
      "  tablet: 640,\r",
      "  laptop: 1024,\r",
      "  desktop: 1280,\r",
      "})\r",
      "\r",
      "const laptop = breakpoints.between('laptop', 'desktop')\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { increaseWithUnit } from '@vueuse/shared'\r",
      "import { computed } from 'vue-demi'\r",
      "import { useMediaQuery } from '../useMediaQuery'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export * from './breakpoints'\r",
      "\r",
      "export type Breakpoints<K extends string = string> = Record<K, number | string>\r",
      "\r",
      "/**\r",
      " * Reactively viewport breakpoints\r",
      " *\r",
      " * @see https://vueuse.org/useBreakpoints\r",
      " * @param options\r",
      " */\r",
      "export function useBreakpoints<K extends string>(breakpoints: Breakpoints<K>, options: ConfigurableWindow = {}) {\r",
      "  function getValue(k: K, delta?: number) {\r",
      "    let v = breakpoints[k]\r",
      "\r",
      "    if (delta != null)\r",
      "      v = increaseWithUnit(v, delta)\r",
      "\r",
      "    if (typeof v === 'number')\r",
      "      v = `${v}px`\r",
      "\r",
      "    return v\r",
      "  }\r",
      "\r",
      "  const { window = defaultWindow } = options\r",
      "\r",
      "  function match(query: string): boolean {\r",
      "    if (!window)\r",
      "      return false\r",
      "    return window.matchMedia(query).matches\r",
      "  }\r",
      "\r",
      "  const greaterOrEqual = (k: K) => {\r",
      "    return useMediaQuery(`(min-width: ${getValue(k)})`, options)\r",
      "  }\r",
      "\r",
      "  const shortcutMethods = Object.keys(breakpoints)\r",
      "    .reduce((shortcuts, k) => {\r",
      "      Object.defineProperty(shortcuts, k, {\r",
      "        get: () => greaterOrEqual(k as K),\r",
      "        enumerable: true,\r",
      "        configurable: true,\r",
      "      })\r",
      "      return shortcuts\r",
      "    }, {} as Record<K, Ref<boolean>>)\r",
      "\r",
      "  return Object.assign(shortcutMethods, {\r",
      "    greater(k: K) {\r",
      "      return useMediaQuery(`(min-width: ${getValue(k, 0.1)})`, options)\r",
      "    },\r",
      "    greaterOrEqual,\r",
      "    smaller(k: K) {\r",
      "      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options)\r",
      "    },\r",
      "    smallerOrEqual(k: K) {\r",
      "      return useMediaQuery(`(max-width: ${getValue(k)})`, options)\r",
      "    },\r",
      "    between(a: K, b: K) {\r",
      "      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options)\r",
      "    },\r",
      "    isGreater(k: K) {\r",
      "      return match(`(min-width: ${getValue(k, 0.1)})`)\r",
      "    },\r",
      "    isGreaterOrEqual(k: K) {\r",
      "      return match(`(min-width: ${getValue(k)})`)\r",
      "    },\r",
      "    isSmaller(k: K) {\r",
      "      return match(`(max-width: ${getValue(k, -0.1)})`)\r",
      "    },\r",
      "    isSmallerOrEqual(k: K) {\r",
      "      return match(`(max-width: ${getValue(k)})`)\r",
      "    },\r",
      "    isInBetween(a: K, b: K) {\r",
      "      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`)\r",
      "    },\r",
      "    current() {\r",
      "      const points = Object.keys(breakpoints).map(i => [i, greaterOrEqual(i as K)] as const)\r",
      "      return computed(() => points.filter(([, v]) => v.value).map(([k]) => k))\r",
      "    },\r",
      "  })\r",
      "}\r",
      "\r",
      "export type UseBreakpointsReturn<K extends string = string> = {\r",
      "  greater: (k: K) => ComputedRef<boolean>\r",
      "  greaterOrEqual: (k: K) => ComputedRef<boolean>\r",
      "  smaller(k: K): ComputedRef<boolean>\r",
      "  smallerOrEqual: (k: K) => ComputedRef<boolean>\r",
      "  between(a: K, b: K): ComputedRef<boolean>\r",
      "  isGreater(k: K): boolean\r",
      "  isGreaterOrEqual(k: K): boolean\r",
      "  isSmaller(k: K): boolean\r",
      "  isSmallerOrEqual(k: K): boolean\r",
      "  isInBetween(a: K, b: K): boolean\r",
      "  current(): ComputedRef<string[]>\r",
      "} & Record<K, ComputedRef<boolean>>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { breakpointsTailwind, useBreakpoints } from '@vueuse/core'\r",
      "\r",
      "const breakpoints = useBreakpoints(breakpointsTailwind)\r",
      "\r",
      "const smWidth = breakpointsTailwind.sm\r",
      "\r",
      "const current = breakpoints.current()\r",
      "const xs = breakpoints.smaller('sm')\r",
      "const xse = breakpoints.smallerOrEqual('sm')\r",
      "const sm = breakpoints.between('sm', 'md')\r",
      "const md = breakpoints.between('md', 'lg')\r",
      "const lg = breakpoints.between('lg', 'xl')\r",
      "const xl = breakpoints.between('xl', '2xl')\r",
      "const xxl = breakpoints['2xl']\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"font-mono\">\r",
      "    <div> Current breakpoints: {{ current }} </div>\r",
      "    <div> xs(&lt;{{ smWidth }}px): <BooleanDisplay :value=\"xs\" /></div>\r",
      "    <div> xs(&lt;={{ smWidth }}px): <BooleanDisplay :value=\"xse\" /></div>\r",
      "    <div> sm: <BooleanDisplay :value=\"sm\" /></div>\r",
      "    <div> md: <BooleanDisplay :value=\"md\" /></div>\r",
      "    <div> lg: <BooleanDisplay :value=\"lg\" /></div>\r",
      "    <div> xl: <BooleanDisplay :value=\"xl\" /></div>\r",
      "    <div>2xl: <BooleanDisplay :value=\"xxl\" /></div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useBroadcastChannel - vueuse": {
    "prefix": "hvue useBroadcastChannel - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useBroadcastChannel\r",
      "\r",
      "Reactive [BroadcastChannel API](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel). \r",
      "\r",
      "Closes a broadcast channel automatically component unmounted.\r",
      "\r",
      "## Usage\r",
      "\r",
      "The BroadcastChannel interface represents a named channel that any browsing \r",
      "context of a given origin can subscribe to. It allows communication between \r",
      "different documents (in different windows, tabs, frames, or iframes) of the \r",
      "same origin. \r",
      "\r",
      "Messages are broadcasted via a message event fired at all BroadcastChannel \r",
      "objects listening to the channel.\r",
      "\r",
      "```js\r",
      "import { ref } from 'vue'\r",
      "import { useBroadcastChannel } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isSupported,\r",
      "  channel,\r",
      "  post,\r",
      "  close,\r",
      "  error,\r",
      "  isClosed,\r",
      "} = useBroadcastChannel({ name: 'vueuse-demo-channel' })\r",
      "\r",
      "const message = ref('')\r",
      "\r",
      "message.value = 'Hello, VueUse World!'\r",
      "\r",
      "// Post the message to the broadcast channel:\r",
      "post(message.value)\r",
      "\r",
      "// Option to close the channel if you wish:\r",
      "close()\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref, shallowRef } from 'vue-demi'\r",
      "import { tryOnMounted, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "export interface UseBroadcastChannelOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * The name of the channel.\r",
      "   */\r",
      "  name: string\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive BroadcastChannel\r",
      " *\r",
      " * @see https://vueuse.org/useBroadcastChannel\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel\r",
      " * @param options\r",
      " *\r",
      " */\r",
      "export function useBroadcastChannel<D, P>(options: UseBroadcastChannelOptions): UseBroadcastChannelReturn<D, P> {\r",
      "  const {\r",
      "    name,\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const isSupported = useSupported(() => window && 'BroadcastChannel' in window)\r",
      "  const isClosed = ref(false)\r",
      "\r",
      "  const channel = ref<BroadcastChannel | undefined>()\r",
      "  const data = ref()\r",
      "  const error = shallowRef<Event | null>(null)\r",
      "\r",
      "  const post = (data: unknown) => {\r",
      "    if (channel.value)\r",
      "      channel.value.postMessage(data)\r",
      "  }\r",
      "\r",
      "  const close = () => {\r",
      "    if (channel.value)\r",
      "      channel.value.close()\r",
      "    isClosed.value = true\r",
      "  }\r",
      "\r",
      "  if (isSupported.value) {\r",
      "    tryOnMounted(() => {\r",
      "      error.value = null\r",
      "      channel.value = new BroadcastChannel(name)\r",
      "\r",
      "      channel.value.addEventListener('message', (e: MessageEvent) => {\r",
      "        data.value = e.data\r",
      "      }, { passive: true })\r",
      "\r",
      "      channel.value.addEventListener('messageerror', (e: MessageEvent) => {\r",
      "        error.value = e\r",
      "      }, { passive: true })\r",
      "\r",
      "      channel.value.addEventListener('close', () => {\r",
      "        isClosed.value = true\r",
      "      })\r",
      "    })\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(() => {\r",
      "    close()\r",
      "  })\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    channel,\r",
      "    data,\r",
      "    post,\r",
      "    close,\r",
      "    error,\r",
      "    isClosed,\r",
      "  }\r",
      "}\r",
      "\r",
      "export interface UseBroadcastChannelReturn<D, P> {\r",
      "  isSupported: Ref<boolean>\r",
      "  channel: Ref<BroadcastChannel | undefined>\r",
      "  data: Ref<D>\r",
      "  post: (data: P) => void\r",
      "  close: () => void\r",
      "  error: Ref<Event | null>\r",
      "  isClosed: Ref<boolean>\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref, watch } from 'vue'\r",
      "import { useBroadcastChannel } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isSupported,\r",
      "  data,\r",
      "  post,\r",
      "  error,\r",
      "} = useBroadcastChannel({ name: 'vueuse-demo-channel' })\r",
      "\r",
      "const message = ref('')\r",
      "\r",
      "watch(data, () => {\r",
      "  if (data.value)\r",
      "    alert(data.value)\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <p>\r",
      "      Supported:\r",
      "      <b>{{ isSupported }}</b>\r",
      "    </p>\r",
      "\r",
      "    <p>Please open this page in at least two tabs</p>\r",
      "  </div>\r",
      "\r",
      "  <div v-if=\"isSupported\">\r",
      "    <form @submit.prevent=\"post(message)\">\r",
      "      <input v-model=\"message\" type=\"text\">\r",
      "      <button type=\"submit\">\r",
      "        Send Message\r",
      "      </button>\r",
      "    </form>\r",
      "\r",
      "    <p v-if=\"data\">\r",
      "      received: {{ data }}\r",
      "    </p>\r",
      "\r",
      "    <p v-if=\"error\">\r",
      "      error: {{ error }}\r",
      "    </p>\r",
      "  </div>\r",
      "  <div v-else>\r",
      "    Aww, snap! The Broadcast Channel Web API is not supported in your browser.\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useBrowserLocation - vueuse": {
    "prefix": "hvue useBrowserLocation - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useBrowserLocation\r",
      "\r",
      "Reactive browser location\r",
      "\r",
      "> NOTE: If you're using Vue Router, use [`useRoute`](https://router.vuejs.org/guide/advanced/composition-api.html) provided by Vue Router instead.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useBrowserLocation } from '@vueuse/core'\r",
      "\r",
      "const location = useBrowserLocation()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseBrowserLocation v-slot=\"{ location }\">\r",
      "  Browser Location: {{ location }}\r",
      "</UseBrowserLocation>\r",
      "```\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */\r",
      "\r",
      "import { objectEntries } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { reactive, ref, watch } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "const WRITABLE_PROPERTIES = [\r",
      "  'hash', 'host', 'hostname', 'href', 'pathname', 'port', 'protocol', 'search',\r",
      "] as const\r",
      "\r",
      "export interface BrowserLocationState {\r",
      "  readonly trigger: string\r",
      "  readonly state?: any\r",
      "  readonly length?: number\r",
      "  readonly origin?: string\r",
      "  hash?: string\r",
      "  host?: string\r",
      "  hostname?: string\r",
      "  href?: string\r",
      "  pathname?: string\r",
      "  port?: string\r",
      "  protocol?: string\r",
      "  search?: string\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive browser location.\r",
      " *\r",
      " * @see https://vueuse.org/useBrowserLocation\r",
      " * @param options\r",
      " */\r",
      "export function useBrowserLocation({ window = defaultWindow }: ConfigurableWindow = {}) {\r",
      "  const refs = Object.fromEntries(\r",
      "    WRITABLE_PROPERTIES.map(key => [key, ref()]),\r",
      "  ) as Record<typeof WRITABLE_PROPERTIES[number], Ref<string | undefined>>\r",
      "\r",
      "  for (const [key, ref] of objectEntries(refs)) {\r",
      "    watch(ref, (value) => {\r",
      "      if (!window?.location || window.location[key] === value)\r",
      "        return\r",
      "      window.location[key] = value!\r",
      "    })\r",
      "  }\r",
      "\r",
      "  const buildState = (trigger: string): BrowserLocationState => {\r",
      "    const { state, length } = window?.history || {}\r",
      "    const { origin } = window?.location || {}\r",
      "\r",
      "    for (const key of WRITABLE_PROPERTIES)\r",
      "      refs[key].value = window?.location?.[key]\r",
      "\r",
      "    return reactive({\r",
      "      trigger,\r",
      "      state,\r",
      "      length,\r",
      "      origin,\r",
      "      ...refs,\r",
      "    })\r",
      "  }\r",
      "\r",
      "  const state = ref(buildState('load'))\r",
      "\r",
      "  if (window) {\r",
      "    useEventListener(window, 'popstate', () => state.value = buildState('popstate'), { passive: true })\r",
      "    useEventListener(window, 'hashchange', () => state.value = buildState('hashchange'), { passive: true })\r",
      "  }\r",
      "\r",
      "  return state\r",
      "}\r",
      "\r",
      "export type UseBrowserLocationReturn = ReturnType<typeof useBrowserLocation>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useBrowserLocation } from '@vueuse/core'\r",
      "\r",
      "const location = useBrowserLocation()\r",
      "const text = stringify(location)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  Input and hash will be changed:\r",
      "  <input v-model=\"location.hash\" type=\"text\" placeholder=\"Hash\">\r",
      "  <pre lang=\"yaml\">{{ text }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useCached - vueuse": {
    "prefix": "hvue useCached - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useCached\r",
      "\r",
      "Cache a ref with a custom comparator.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useCached } from '@vueuse/core'\r",
      "\r",
      "interface Data {\r",
      "  value: number\r",
      "  extra: number\r",
      "}\r",
      "\r",
      "const source = ref<Data>({ value: 42, extra: 0 })\r",
      "const cached = useCached(source, (a, b) => a.value === b.value)\r",
      "\r",
      "source.value = {\r",
      "  value: 42,\r",
      "  extra: 1,\r",
      "}\r",
      "\r",
      "console.log(cached.value) // { value: 42, extra: 0 }\r",
      "\r",
      "source.value = {\r",
      "  value: 43,\r",
      "  extra: 1,\r",
      "}\r",
      "\r",
      "console.log(cached.value) // { value: 43, extra: 1 }\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref, WatchOptions } from 'vue-demi'\r",
      "import { ref, watch } from 'vue-demi'\r",
      "\r",
      "export function useCached<T>(\r",
      "  refValue: Ref<T>,\r",
      "  comparator: (a: T, b: T) => boolean = (a, b) => a === b,\r",
      "  watchOptions?: WatchOptions,\r",
      "): Ref<T> {\r",
      "  const cachedValue = ref(refValue.value) as Ref<T>\r",
      "\r",
      "  watch(() => refValue.value, (value) => {\r",
      "    if (!comparator(value, cachedValue.value))\r",
      "      cachedValue.value = value\r",
      "  }, watchOptions)\r",
      "\r",
      "  return cachedValue\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useCached } from '@vueuse/core'\r",
      "\r",
      "interface Value {\r",
      "  value: number\r",
      "  extra: number\r",
      "}\r",
      "\r",
      "const value = ref<Value>({ value: 42, extra: 0 })\r",
      "function comparator(a: Value, b: Value) {\r",
      "  return a.value === b.value\r",
      "}\r",
      "const cachedValue = useCached(value, comparator)\r",
      "\r",
      "const inputValue = ref(value.value.value)\r",
      "const inputExtra = ref(value.value.extra)\r",
      "\r",
      "function onSyncClick() {\r",
      "  value.value = {\r",
      "    value: inputValue.value,\r",
      "    extra: inputExtra.value,\r",
      "  }\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div>\r",
      "      <div>Value: {{ value.value }}</div>\r",
      "      <div>Extra: {{ value.extra }}</div>\r",
      "      <div>Cached Value: {{ cachedValue.value }}</div>\r",
      "      <div>Cached Extra: {{ cachedValue.extra }}</div>\r",
      "\r",
      "      <div>\r",
      "        <label for=\"localValue\">Temp Value: </label>\r",
      "        <input id=\"localValue\" v-model.number=\"inputValue\">\r",
      "      </div>\r",
      "      <div>\r",
      "        <label for=\"localExtra\">Local Extra: </label>\r",
      "        <input id=\"localExtra\" v-model.number=\"inputExtra\">\r",
      "      </div>\r",
      "      <div>\r",
      "        <button @click=\"onSyncClick\">\r",
      "          Sync\r",
      "        </button>\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useClipboard - vueuse": {
    "prefix": "hvue useClipboard - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useClipboard\r",
      "\r",
      "Reactive [Clipboard API](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API). Provides the ability to respond to clipboard commands (cut, copy, and paste) as well as to asynchronously read from and write to the system clipboard. Access to the contents of the clipboard is gated behind the [Permissions API](https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API). Without user permission, reading or altering the clipboard contents is not permitted.\r",
      "\r",
      "<CourseLink href=\"https://vueschool.io/lessons/reactive-browser-wrappers-in-vueuse-useclipboard?friend=vueuse\">Learn how to reactively save text to the clipboard with this FREE video lesson from Vue School!</CourseLink>\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useClipboard } from '@vueuse/core'\r",
      "\r",
      "const source = ref('Hello')\r",
      "const { text, copy, copied, isSupported } = useClipboard({ source })\r",
      "```\r",
      "\r",
      "```html\r",
      " <div v-if=\"isSupported\">\r",
      "    <button @click='copy(source)'>\r",
      "      <!-- by default, `copied` will be reset in 1.5s -->\r",
      "      <span v-if='!copied'>Copy</span>\r",
      "      <span v-else>Copied!</span>\r",
      "    </button>\r",
      "    <p>\r",
      "      Current copied: <code>{{ text || 'none' }}</code>\r",
      "    </p>\r",
      "  </div>\r",
      "  <p v-else>\r",
      "    Your browser does not support Clipboard API\r",
      "  </p>\r",
      "```\r",
      "\r",
      "Set `legacy: true` to keep the ability to copy if [Clipboard API](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API) is not available. It will handle copy with [execCommand](https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand) as fallback.\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */\r",
      "\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue, useTimeoutFn } from '@vueuse/shared'\r",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { computed, ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableNavigator } from '../_configurable'\r",
      "import { defaultNavigator } from '../_configurable'\r",
      "\r",
      "export interface UseClipboardOptions<Source> extends ConfigurableNavigator {\r",
      "  /**\r",
      "   * Enabled reading for clipboard\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  read?: boolean\r",
      "\r",
      "  /**\r",
      "   * Copy source\r",
      "   */\r",
      "  source?: Source\r",
      "\r",
      "  /**\r",
      "   * Milliseconds to reset state of `copied` ref\r",
      "   *\r",
      "   * @default 1500\r",
      "   */\r",
      "  copiedDuring?: number\r",
      "\r",
      "  /**\r",
      "   * Whether fallback to document.execCommand('copy') if clipboard is undefined.\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  legacy?: boolean\r",
      "}\r",
      "\r",
      "export interface UseClipboardReturn<Optional> {\r",
      "  isSupported: Ref<boolean>\r",
      "  text: ComputedRef<string>\r",
      "  copied: ComputedRef<boolean>\r",
      "  copy: Optional extends true ? (text?: string) => Promise<void> : (text: string) => Promise<void>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive Clipboard API.\r",
      " *\r",
      " * @see https://vueuse.org/useClipboard\r",
      " * @param options\r",
      " */\r",
      "export function useClipboard(options?: UseClipboardOptions<undefined>): UseClipboardReturn<false>\r",
      "export function useClipboard(options: UseClipboardOptions<MaybeRefOrGetter<string>>): UseClipboardReturn<true>\r",
      "export function useClipboard(options: UseClipboardOptions<MaybeRefOrGetter<string> | undefined> = {}): UseClipboardReturn<boolean> {\r",
      "  const {\r",
      "    navigator = defaultNavigator,\r",
      "    read = false,\r",
      "    source,\r",
      "    copiedDuring = 1500,\r",
      "    legacy = false,\r",
      "  } = options\r",
      "\r",
      "  const isClipboardApiSupported = useSupported(() => (navigator && 'clipboard' in navigator))\r",
      "  const isSupported = computed(() => isClipboardApiSupported.value || legacy)\r",
      "  const text = ref('')\r",
      "  const copied = ref(false)\r",
      "  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring)\r",
      "\r",
      "  function updateText() {\r",
      "    if (isClipboardApiSupported.value) {\r",
      "      navigator!.clipboard.readText().then((value) => {\r",
      "        text.value = value\r",
      "      })\r",
      "    }\r",
      "    else {\r",
      "      text.value = legacyRead()\r",
      "    }\r",
      "  }\r",
      "\r",
      "  if (isSupported.value && read)\r",
      "    useEventListener(['copy', 'cut'], updateText)\r",
      "\r",
      "  async function copy(value = toValue(source)) {\r",
      "    if (isSupported.value && value != null) {\r",
      "      if (isClipboardApiSupported.value)\r",
      "        await navigator!.clipboard.writeText(value)\r",
      "      else\r",
      "        legacyCopy(value)\r",
      "\r",
      "      text.value = value\r",
      "      copied.value = true\r",
      "      timeout.start()\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function legacyCopy(value: string) {\r",
      "    const ta = document.createElement('textarea')\r",
      "    ta.value = value ?? ''\r",
      "    ta.style.position = 'absolute'\r",
      "    ta.style.opacity = '0'\r",
      "    document.body.appendChild(ta)\r",
      "    ta.select()\r",
      "    document.execCommand('copy')\r",
      "    ta.remove()\r",
      "  }\r",
      "\r",
      "  function legacyRead() {\r",
      "    return document?.getSelection?.()?.toString() ?? ''\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    text: text as ComputedRef<string>,\r",
      "    copied: copied as ComputedRef<boolean>,\r",
      "    copy,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useClipboard, usePermission } from '@vueuse/core'\r",
      "\r",
      "const input = ref('')\r",
      "\r",
      "const { text, isSupported, copy } = useClipboard()\r",
      "const permissionRead = usePermission('clipboard-read')\r",
      "const permissionWrite = usePermission('clipboard-write')\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div v-if=\"isSupported\">\r",
      "    <note>\r",
      "      Clipboard Permission: read <b>{{ permissionRead }}</b> | write\r",
      "      <b>{{ permissionWrite }}</b>\r",
      "    </note>\r",
      "    <p>\r",
      "      Current copied: <code>{{ text || 'none' }}</code>\r",
      "    </p>\r",
      "    <input v-model=\"input\" type=\"text\">\r",
      "    <button @click=\"copy(input)\">\r",
      "      Copy\r",
      "    </button>\r",
      "  </div>\r",
      "  <p v-else>\r",
      "    Your browser does not support Clipboard API\r",
      "  </p>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useCloned - vueuse": {
    "prefix": "hvue useCloned - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useCloned\r",
      "\r",
      "Reactive clone of a ref. By default, it use `JSON.parse(JSON.stringify())` to do the clone.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useCloned } from '@vueuse/core'\r",
      "\r",
      "const original = ref({ key: 'value' })\r",
      "\r",
      "const { cloned } = useCloned(original)\r",
      "\r",
      "original.value.key = 'some new value'\r",
      "\r",
      "console.log(cloned.value.key) // 'some new value'\r",
      "```\r",
      "\r",
      "## Manual cloning\r",
      "\r",
      "```ts\r",
      "import { useCloned } from '@vueuse/core'\r",
      "\r",
      "const original = ref({ key: 'value' })\r",
      "\r",
      "const { cloned, sync } = useCloned(original, { manual: true })\r",
      "\r",
      "original.value.key = 'manual'\r",
      "\r",
      "console.log(cloned.value.key) // 'value'\r",
      "\r",
      "sync()\r",
      "\r",
      "console.log(cloned.value.key)// 'manual'\r",
      "```\r",
      "\r",
      "## Custom Clone Function\r",
      "\r",
      "Using [`klona`](https://www.npmjs.com/package/klona) for example:\r",
      "\r",
      "```ts\r",
      "import { useCloned } from '@vueuse/core'\r",
      "import { klona } from 'klona'\r",
      "\r",
      "const original = ref({ key: 'value' })\r",
      "\r",
      "const { cloned, sync } = useCloned(original, { clone: klona })\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import type { ComputedRef, WatchOptions } from 'vue-demi'\r",
      "import { isRef, ref, watch } from 'vue-demi'\r",
      "\r",
      "export interface UseClonedOptions<T = any> extends WatchOptions {\r",
      "  /**\r",
      "   * Custom clone function.\r",
      "   *\r",
      "   * By default, it use `JSON.parse(JSON.stringify(value))` to clone.\r",
      "   */\r",
      "  clone?: (source: T) => T\r",
      "\r",
      "  /**\r",
      "   * Manually sync the ref\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  manual?: boolean\r",
      "}\r",
      "\r",
      "export interface UseClonedReturn<T> {\r",
      "  /**\r",
      "   * Cloned ref\r",
      "   */\r",
      "  cloned: ComputedRef<T>\r",
      "  /**\r",
      "   * Sync cloned data with source manually\r",
      "   */\r",
      "  sync: () => void\r",
      "}\r",
      "\r",
      "export type CloneFn<F, T = F> = (x: F) => T\r",
      "\r",
      "export function cloneFnJSON<T>(source: T): T {\r",
      "  return JSON.parse(JSON.stringify(source))\r",
      "}\r",
      "\r",
      "export function useCloned<T>(\r",
      "  source: MaybeRefOrGetter<T>,\r",
      "  options: UseClonedOptions = {},\r",
      ") {\r",
      "  const cloned = ref<T>({} as T)\r",
      "  const {\r",
      "    manual,\r",
      "    clone = cloneFnJSON,\r",
      "    // watch options\r",
      "    deep = true,\r",
      "    immediate = true,\r",
      "  } = options\r",
      "\r",
      "  function sync() {\r",
      "    cloned.value = clone(toValue(source))\r",
      "  }\r",
      "\r",
      "  if (!manual && (isRef(source) || typeof source === 'function')) {\r",
      "    watch(source, sync, {\r",
      "      ...options,\r",
      "      deep,\r",
      "      immediate,\r",
      "    })\r",
      "  }\r",
      "  else {\r",
      "    sync()\r",
      "  }\r",
      "\r",
      "  return { cloned, sync }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useCloned } from '@vueuse/core'\r",
      "\r",
      "const template = { fruit: 'banana', drink: 'water' }\r",
      "\r",
      "const { cloned, sync } = useCloned(template)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <input v-model=\"cloned.fruit\" type=\"text\">\r",
      "  <input v-model=\"cloned.drink\" type=\"text\">\r",
      "\r",
      "  <button @click=\"sync()\">\r",
      "    reset\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useColorMode - vueuse": {
    "prefix": "hvue useColorMode - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "related:\r",
      "  - useDark\r",
      "  - usePreferredDark\r",
      "  - useStorage\r",
      "---\r",
      "\r",
      "# useColorMode\r",
      "\r",
      "Reactive color mode (dark / light / customs) with auto data persistence.\r",
      "\r",
      "## Basic Usage\r",
      "\r",
      "```js\r",
      "import { useColorMode } from '@vueuse/core'\r",
      "\r",
      "const mode = useColorMode() // Ref<'dark' | 'light'>\r",
      "```\r",
      "\r",
      "By default, it will match with users' browser preference using `usePreferredDark` (a.k.a `auto` mode). When reading the ref, it will by default return the current color mode (`dark`, `light` or your custom modes). The `auto` mode can be included in the returned modes by enabling the `emitAuto` option. When writing to the ref, it will trigger DOM updates and persist the color mode to local storage (or your custom storage). You can pass `auto` to set back to auto mode.\r",
      "\r",
      "```ts\r",
      "mode.value // 'dark' | 'light'\r",
      "\r",
      "mode.value = 'dark' // change to dark mode and persist\r",
      "\r",
      "mode.value = 'auto' // change to auto mode\r",
      "```\r",
      "\r",
      "## Config\r",
      "\r",
      "```js\r",
      "import { useColorMode } from '@vueuse/core'\r",
      "\r",
      "const mode = useColorMode({\r",
      "  attribute: 'theme',\r",
      "  modes: {\r",
      "    // custom colors\r",
      "    dim: 'dim',\r",
      "    cafe: 'cafe',\r",
      "  },\r",
      "}) // Ref<'dark' | 'light' | 'dim' | 'cafe'>\r",
      "```\r",
      "\r",
      "## Advanced Usage\r",
      "\r",
      "You can also explicit access to the system preference and storaged user override mode.\r",
      "\r",
      "```js\r",
      "import { useColorMode } from '@vueuse/core'\r",
      "\r",
      "const { system, store } = useColorMode()\r",
      "\r",
      "system.value // 'dark' | 'light'\r",
      "store.value // 'dark' | 'light' | 'auto'\r",
      "\r",
      "const myColorMode = computed(() => store.value === 'auto' ? system.value : store.value)\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseColorMode v-slot=\"{ mode }\">\r",
      "  <button @click=\"mode = mode === 'dark' ? 'light' : 'dark'\">\r",
      "    Mode {{ mode }}\r",
      "  </button>\r",
      "</UseColorMode>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { computed, watch } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toRef, tryOnMounted } from '@vueuse/shared'\r",
      "import type { StorageLike } from '../ssr-handlers'\r",
      "import { getSSRHandler } from '../ssr-handlers'\r",
      "import type { UseStorageOptions } from '../useStorage'\r",
      "import { useStorage } from '../useStorage'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import { usePreferredDark } from '../usePreferredDark'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "\r",
      "export type BasicColorMode = 'light' | 'dark'\r",
      "export type BasicColorSchema = BasicColorMode | 'auto'\r",
      "\r",
      "export interface UseColorModeOptions<T extends string = BasicColorMode> extends UseStorageOptions<T | BasicColorMode> {\r",
      "  /**\r",
      "   * CSS Selector for the target element applying to\r",
      "   *\r",
      "   * @default 'html'\r",
      "   */\r",
      "  selector?: string | MaybeElementRef\r",
      "\r",
      "  /**\r",
      "   * HTML attribute applying the target element\r",
      "   *\r",
      "   * @default 'class'\r",
      "   */\r",
      "  attribute?: string\r",
      "\r",
      "  /**\r",
      "   * The initial color mode\r",
      "   *\r",
      "   * @default 'auto'\r",
      "   */\r",
      "  initialValue?: MaybeRefOrGetter<T | BasicColorSchema>\r",
      "\r",
      "  /**\r",
      "   * Prefix when adding value to the attribute\r",
      "   */\r",
      "  modes?: Partial<Record<T | BasicColorSchema, string>>\r",
      "\r",
      "  /**\r",
      "   * A custom handler for handle the updates.\r",
      "   * When specified, the default behavior will be overridden.\r",
      "   *\r",
      "   * @default undefined\r",
      "   */\r",
      "  onChanged?: (mode: T | BasicColorMode, defaultHandler:((mode: T | BasicColorMode) => void)) => void\r",
      "\r",
      "  /**\r",
      "   * Custom storage ref\r",
      "   *\r",
      "   * When provided, `useStorage` will be skipped\r",
      "   */\r",
      "  storageRef?: Ref<T | BasicColorSchema>\r",
      "\r",
      "  /**\r",
      "   * Key to persist the data into localStorage/sessionStorage.\r",
      "   *\r",
      "   * Pass `null` to disable persistence\r",
      "   *\r",
      "   * @default 'vueuse-color-scheme'\r",
      "   */\r",
      "  storageKey?: string | null\r",
      "\r",
      "  /**\r",
      "   * Storage object, can be localStorage or sessionStorage\r",
      "   *\r",
      "   * @default localStorage\r",
      "   */\r",
      "  storage?: StorageLike\r",
      "\r",
      "  /**\r",
      "   * Emit `auto` mode from state\r",
      "   *\r",
      "   * When set to `true`, preferred mode won't be translated into `light` or `dark`.\r",
      "   * This is useful when the fact that `auto` mode was selected needs to be known.\r",
      "   *\r",
      "   * @default undefined\r",
      "   * @deprecated use `store.value` when `auto` mode needs to be known\r",
      "   * @see https://vueuse.org/core/useColorMode/#advanced-usage\r",
      "   */\r",
      "  emitAuto?: boolean\r",
      "\r",
      "  /**\r",
      "   * Disable transition on switch\r",
      "   *\r",
      "   * @see https://paco.me/writing/disable-theme-transitions\r",
      "   * @default true\r",
      "   */\r",
      "  disableTransition?: boolean\r",
      "}\r",
      "\r",
      "export type UseColorModeReturn<T extends string = BasicColorMode> =\r",
      "  Ref<T | BasicColorSchema> & {\r",
      "    store: Ref<T | BasicColorSchema>\r",
      "    system: ComputedRef<BasicColorMode>\r",
      "    state: ComputedRef<T | BasicColorMode>\r",
      "  }\r",
      "\r",
      "/**\r",
      " * Reactive color mode with auto data persistence.\r",
      " *\r",
      " * @see https://vueuse.org/useColorMode\r",
      " * @param options\r",
      " */\r",
      "export function useColorMode<T extends string = BasicColorMode>(\r",
      "  options: UseColorModeOptions<T> = {},\r",
      "): UseColorModeReturn<T> {\r",
      "  const {\r",
      "    selector = 'html',\r",
      "    attribute = 'class',\r",
      "    initialValue = 'auto',\r",
      "    window = defaultWindow,\r",
      "    storage,\r",
      "    storageKey = 'vueuse-color-scheme',\r",
      "    listenToStorageChanges = true,\r",
      "    storageRef,\r",
      "    emitAuto,\r",
      "    disableTransition = true,\r",
      "  } = options\r",
      "\r",
      "  const modes = {\r",
      "    auto: '',\r",
      "    light: 'light',\r",
      "    dark: 'dark',\r",
      "    ...options.modes || {},\r",
      "  } as Record<BasicColorSchema | T, string>\r",
      "\r",
      "  const preferredDark = usePreferredDark({ window })\r",
      "  const system = computed(() => preferredDark.value ? 'dark' : 'light')\r",
      "\r",
      "  const store = storageRef || (\r",
      "    storageKey == null\r",
      "      ? toRef(initialValue) as Ref<T | BasicColorSchema>\r",
      "      : useStorage<T | BasicColorSchema>(storageKey, initialValue, storage, { window, listenToStorageChanges })\r",
      "  )\r",
      "\r",
      "  const state = computed<T | BasicColorMode>(() =>\r",
      "    store.value === 'auto'\r",
      "      ? system.value\r",
      "      : store.value,\r",
      "  )\r",
      "\r",
      "  const updateHTMLAttrs = getSSRHandler(\r",
      "    'updateHTMLAttrs',\r",
      "    (selector, attribute, value) => {\r",
      "      const el = typeof selector === 'string'\r",
      "        ? window?.document.querySelector(selector)\r",
      "        : unrefElement(selector)\r",
      "      if (!el)\r",
      "        return\r",
      "\r",
      "      let style: HTMLStyleElement | undefined\r",
      "      if (disableTransition) {\r",
      "        style = window!.document.createElement('style')\r",
      "        const styleString = '*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}'\r",
      "        style.appendChild(document.createTextNode(styleString))\r",
      "        window!.document.head.appendChild(style)\r",
      "      }\r",
      "\r",
      "      if (attribute === 'class') {\r",
      "        const current = value.split(/\\s/g)\r",
      "        Object.values(modes)\r",
      "          .flatMap(i => (i || '').split(/\\s/g))\r",
      "          .filter(Boolean)\r",
      "          .forEach((v) => {\r",
      "            if (current.includes(v))\r",
      "              el.classList.add(v)\r",
      "            else\r",
      "              el.classList.remove(v)\r",
      "          })\r",
      "      }\r",
      "      else {\r",
      "        el.setAttribute(attribute, value)\r",
      "      }\r",
      "\r",
      "      if (disableTransition) {\r",
      "        // Calling getComputedStyle forces the browser to redraw\r",
      "        // @ts-expect-error unused variable\r",
      "        const _ = window!.getComputedStyle(style!).opacity\r",
      "        document.head.removeChild(style!)\r",
      "      }\r",
      "    })\r",
      "\r",
      "  function defaultOnChanged(mode: T | BasicColorMode) {\r",
      "    updateHTMLAttrs(selector, attribute, modes[mode] ?? mode)\r",
      "  }\r",
      "\r",
      "  function onChanged(mode: T | BasicColorMode) {\r",
      "    if (options.onChanged)\r",
      "      options.onChanged(mode, defaultOnChanged)\r",
      "    else\r",
      "      defaultOnChanged(mode)\r",
      "  }\r",
      "\r",
      "  watch(state, onChanged, { flush: 'post', immediate: true })\r",
      "\r",
      "  tryOnMounted(() => onChanged(state.value))\r",
      "\r",
      "  const auto = computed({\r",
      "    get() {\r",
      "      return emitAuto ? store.value : state.value\r",
      "    },\r",
      "    set(v) {\r",
      "      store.value = v\r",
      "    },\r",
      "  })\r",
      "\r",
      "  try {\r",
      "    return Object.assign(auto, { store, system, state }) as UseColorModeReturn<T>\r",
      "  }\r",
      "  catch (e) {\r",
      "    // In Vue 2.6, ref might not be extensible\r",
      "    return auto as any as UseColorModeReturn<T>\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useColorMode, useCycleList } from '@vueuse/core'\r",
      "import { watchEffect } from 'vue-demi'\r",
      "\r",
      "const mode = useColorMode({\r",
      "  emitAuto: true,\r",
      "  modes: {\r",
      "    contrast: 'dark contrast',\r",
      "    cafe: 'cafe',\r",
      "  },\r",
      "})\r",
      "\r",
      "const { state, next } = useCycleList(['dark', 'light', 'cafe', 'contrast', 'auto'], { initialValue: mode })\r",
      "\r",
      "watchEffect(() => mode.value = state.value as any)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"next()\">\r",
      "    <i v-if=\"state === 'dark'\" i-carbon-moon inline-block align-middle class=\"align-middle\" />\r",
      "    <i v-if=\"state === 'light'\" i-carbon-sun inline-block align-middle class=\"align-middle\" />\r",
      "    <i v-if=\"state === 'cafe'\" i-carbon-cafe inline-block align-middle class=\"align-middle\" />\r",
      "    <i v-if=\"state === 'contrast'\" i-carbon-contrast inline-block align-middle class=\"align-middle\" />\r",
      "    <i v-if=\"state === 'auto'\" i-carbon-laptop inline-block align-middle class=\"align-middle\" />\r",
      "\r",
      "    <span class=\"ml-2 capitalize\">{{ state }}</span>\r",
      "  </button>\r",
      "\r",
      "  <span class=\"p-4 opacity-50\">‚Üê Click to change the color mode</span>\r",
      "</template>\r",
      "\r",
      "<style>\r",
      "html.cafe {\r",
      "  filter: sepia(0.9) hue-rotate(315deg) brightness(0.9);\r",
      "}\r",
      "\r",
      "html.contrast {\r",
      "  filter: contrast(2);\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useConfirmDialog - vueuse": {
    "prefix": "hvue useConfirmDialog - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useConfirmDialog\r",
      "\r",
      "Creates event hooks to support modals and confirmation dialog chains.\r",
      "\r",
      "Functions can be used on the template, and hooks are a handy skeleton for the business logic of modals dialog or other actions that require user confirmation.\r",
      "\r",
      "## Functions and hooks\r",
      "\r",
      "- `reveal()` - triggers `onReveal` hook and sets `revealed.value` to `true`. Returns promise that resolves by `confirm()` or `cancel()`.\r",
      "- `confirm()` - sets `isRevealed.value` to `false` and triggers `onConfirm` hook.\r",
      "- `cancel()` - sets `isRevealed.value` to `false` and triggers `onCancel` hook.\r",
      "\r",
      "## Basic Usage\r",
      "\r",
      "### Using hooks\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { useConfirmDialog } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isRevealed,\r",
      "  reveal,\r",
      "  confirm,\r",
      "  cancel,\r",
      "  onReveal,\r",
      "  onConfirm,\r",
      "  onCancel,\r",
      "} = useConfirmDialog()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"reveal\">Reveal Modal</button>\r",
      "\r",
      "  <teleport to=\"body\">\r",
      "    <div v-if=\"isRevealed\" class=\"modal-bg\">\r",
      "      <div class=\"modal\">\r",
      "        <h2>Confirm?</h2>\r",
      "        <button @click=\"confirm\">Yes</button>\r",
      "        <button @click=\"cancel\">Cancel</button>\r",
      "      </div>\r",
      "    </div>\r",
      "  </teleport>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Promise\r",
      "\r",
      "If you prefer working with promises:\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { useConfirmDialog } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isRevealed,\r",
      "  reveal,\r",
      "  confirm,\r",
      "  cancel,\r",
      "} = useConfirmDialog()\r",
      "\r",
      "const openDialog = async () => {\r",
      "  const { data, isCanceled } = await reveal()\r",
      "  if (!isCanceled) {\r",
      "    console.log(data)\r",
      "  }\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"openDialog\">Show Modal</button>\r",
      "\r",
      "  <teleport to=\"body\">\r",
      "    <div v-if=\"isRevealed\" class=\"modal-layout\">\r",
      "      <div class=\"modal\">\r",
      "        <h2>Confirm?</h2>\r",
      "        <button @click=\"confirm(true)\">Yes</button>\r",
      "        <button @click=\"confirm(false)\">No</button>\r",
      "      </div>\r",
      "    </div>\r",
      "  </teleport>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { computed, ref } from 'vue-demi'\r",
      "import type { EventHook, EventHookOn } from '@vueuse/shared'\r",
      "import { createEventHook, noop } from '@vueuse/shared'\r",
      "\r",
      "export type UseConfirmDialogRevealResult<C, D>\r",
      "  = {\r",
      "    data?: C\r",
      "    isCanceled: false\r",
      "  } | {\r",
      "    data?: D\r",
      "    isCanceled: true\r",
      "  }\r",
      "\r",
      "export interface UseConfirmDialogReturn<RevealData, ConfirmData, CancelData> {\r",
      "  /**\r",
      "   * Revealing state\r",
      "   */\r",
      "  isRevealed: ComputedRef<boolean>\r",
      "\r",
      "  /**\r",
      "   * Opens the dialog.\r",
      "   * Create promise and return it. Triggers `onReveal` hook.\r",
      "   */\r",
      "  reveal: (data?: RevealData) => Promise<UseConfirmDialogRevealResult<ConfirmData, CancelData>>\r",
      "\r",
      "  /**\r",
      "   * Confirms and closes the dialog. Triggers a callback inside `onConfirm` hook.\r",
      "   * Resolves promise from `reveal()` with `data` and `isCanceled` ref with `false` value.\r",
      "   * Can accept any data and to pass it to `onConfirm` hook.\r",
      "   */\r",
      "  confirm: (data?: ConfirmData) => void\r",
      "\r",
      "  /**\r",
      "   * Cancels and closes the dialog. Triggers a callback inside `onCancel` hook.\r",
      "   * Resolves promise from `reveal()` with `data` and `isCanceled` ref with `true` value.\r",
      "   * Can accept any data and to pass it to `onCancel` hook.\r",
      "   */\r",
      "  cancel: (data?: CancelData) => void\r",
      "\r",
      "  /**\r",
      "   * Event Hook to be triggered right before dialog creating.\r",
      "   */\r",
      "  onReveal: EventHookOn<RevealData>\r",
      "\r",
      "  /**\r",
      "   * Event Hook to be called on `confirm()`.\r",
      "   * Gets data object from `confirm` function.\r",
      "   */\r",
      "  onConfirm: EventHookOn<ConfirmData>\r",
      "\r",
      "  /**\r",
      "   * Event Hook to be called on `cancel()`.\r",
      "   * Gets data object from `cancel` function.\r",
      "   */\r",
      "  onCancel: EventHookOn<CancelData>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Hooks for creating confirm dialogs. Useful for modal windows, popups and logins.\r",
      " *\r",
      " * @see https://vueuse.org/useConfirmDialog/\r",
      " * @param revealed `boolean` `ref` that handles a modal window\r",
      " */\r",
      "export function useConfirmDialog<\r",
      "  RevealData = any,\r",
      "  ConfirmData = any,\r",
      "  CancelData = any,\r",
      ">(revealed: Ref<boolean> = ref(false)): UseConfirmDialogReturn<RevealData, ConfirmData, CancelData> {\r",
      "  const confirmHook: EventHook = createEventHook<ConfirmData>()\r",
      "  const cancelHook: EventHook = createEventHook<CancelData>()\r",
      "  const revealHook: EventHook = createEventHook<RevealData>()\r",
      "\r",
      "  let _resolve: (arg0: UseConfirmDialogRevealResult<ConfirmData, CancelData>) => void = noop\r",
      "\r",
      "  const reveal = (data?: RevealData) => {\r",
      "    revealHook.trigger(data)\r",
      "    revealed.value = true\r",
      "\r",
      "    return new Promise<UseConfirmDialogRevealResult<ConfirmData, CancelData>>((resolve) => {\r",
      "      _resolve = resolve\r",
      "    })\r",
      "  }\r",
      "\r",
      "  const confirm = (data?: ConfirmData) => {\r",
      "    revealed.value = false\r",
      "    confirmHook.trigger(data)\r",
      "\r",
      "    _resolve({ data, isCanceled: false })\r",
      "  }\r",
      "\r",
      "  const cancel = (data?: CancelData) => {\r",
      "    revealed.value = false\r",
      "    cancelHook.trigger(data)\r",
      "    _resolve({ data, isCanceled: true })\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    isRevealed: computed(() => revealed.value),\r",
      "    reveal,\r",
      "    confirm,\r",
      "    cancel,\r",
      "    onReveal: revealHook.on,\r",
      "    onConfirm: confirmHook.on,\r",
      "    onCancel: cancelHook.on,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useConfirmDialog } from '@vueuse/core'\r",
      "\r",
      "const message = ref('')\r",
      "const revaled1 = ref(false)\r",
      "const revaled2 = ref(false)\r",
      "\r",
      "const dialog1 = useConfirmDialog(revaled1)\r",
      "const dialog2 = useConfirmDialog(revaled2)\r",
      "\r",
      "dialog1.onReveal(() => {\r",
      "  message.value = 'Modal is shown!'\r",
      "})\r",
      "\r",
      "dialog1.onConfirm(() => {\r",
      "  dialog2.reveal()\r",
      "})\r",
      "\r",
      "dialog1.onCancel(() => {\r",
      "  message.value = 'Canceled!'\r",
      "})\r",
      "\r",
      "dialog2.onReveal(() => {\r",
      "  message.value = 'Second modal is shown!'\r",
      "})\r",
      "\r",
      "dialog2.onConfirm((result) => {\r",
      "  if (result)\r",
      "    message.value = 'Confirmed!'\r",
      "  else message.value = 'Rejected!'\r",
      "})\r",
      "\r",
      "dialog2.onCancel(() => {\r",
      "  dialog1.reveal()\r",
      "  message.value = 'Canceled!'\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <h2>\r",
      "    <span class=\"text-orange-400\">{{ message }}</span>\r",
      "  </h2>\r",
      "  <button\r",
      "    :disabled=\"revaled1 || revaled2\"\r",
      "    @click=\"dialog1.reveal\"\r",
      "  >\r",
      "    Click to Show Modal Dialog\r",
      "  </button>\r",
      "\r",
      "  <!-- First Dialog -->\r",
      "  <div v-if=\"revaled1\">\r",
      "    <div>\r",
      "      <div>\r",
      "        <p>Show Second Dialog?</p>\r",
      "      </div>\r",
      "      <footer>\r",
      "        <button @click=\"dialog1.confirm\">\r",
      "          OK\r",
      "        </button>\r",
      "        <button @click=\"dialog1.cancel\">\r",
      "          Cancel\r",
      "        </button>\r",
      "      </footer>\r",
      "    </div>\r",
      "  </div>\r",
      "\r",
      "  <!-- Second Dialog -->\r",
      "  <div v-if=\"revaled2\">\r",
      "    <div>\r",
      "      <div>\r",
      "        <p>Confirm or Reject</p>\r",
      "      </div>\r",
      "      <footer>\r",
      "        <button @click=\"dialog2.confirm(true)\">\r",
      "          Confirm\r",
      "        </button>\r",
      "        <button @click=\"dialog2.confirm(false)\">\r",
      "          Reject\r",
      "        </button>\r",
      "        <button @click=\"dialog2.cancel\">\r",
      "          Cancel\r",
      "        </button>\r",
      "      </footer>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      ".modal {\r",
      "  position: fixed;\r",
      "  left: 50%;\r",
      "  top: 50%;\r",
      "  transform: translate(-50%, -50%);\r",
      "  width: 420px;\r",
      "  max-width: 100%;\r",
      "  z-index: 10;\r",
      "}\r",
      ".modal-layout{\r",
      "  z-index: 20;\r",
      "  left: 0;\r",
      "  top: 0;\r",
      "  position: fixed;\r",
      "  background-color: #7c7c7c7a;\r",
      "  width: 100%;\r",
      "  height: 100%;\r",
      "}\r",
      ".inner {\r",
      "  background-color: var(--vp-c-bg);\r",
      "  padding: 0.4em 2em;\r",
      "  border-radius: 5px;\r",
      "  border: 1px solid var(--vp-c-divider);\r",
      "  box-shadow: 2px 2px 10px rgba(10, 10, 10, 0.1);\r",
      "}\r",
      ".small {\r",
      "  position: absolute;\r",
      "  top: -0.9rem;\r",
      "  right: -0.5rem;\r",
      "  font-weight: bold;\r",
      "}\r",
      ".button:focus {\r",
      "  outline: rgb(91, 91, 255) solid 3px;\r",
      "}\r",
      ".heading {\r",
      "  font-weight: bold;\r",
      "  font-size: 1.4rem;\r",
      "  margin-bottom: 2rem;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useCssVar - vueuse": {
    "prefix": "hvue useCssVar - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useCssVar\r",
      "\r",
      "Manipulate CSS variables\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useCssVar } from '@vueuse/core'\r",
      "\r",
      "const el = ref(null)\r",
      "const color = useCssVar('--color', el)\r",
      "\r",
      "const elv = ref(null)\r",
      "const key = ref('--color')\r",
      "const colorVal = useCssVar(key, elv)\r",
      "\r",
      "const someEl = ref(null)\r",
      "const color = useCssVar('--color', someEl, { initialValue: '#eee' })\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed, ref, watch } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import { useMutationObserver } from '../useMutationObserver'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "\r",
      "export interface UseCssVarOptions extends ConfigurableWindow {\r",
      "  initialValue?: string\r",
      "  /**\r",
      "   * Use MutationObserver to monitor variable changes\r",
      "   * @default false\r",
      "   */\r",
      "  observe?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Manipulate CSS variables.\r",
      " *\r",
      " * @see https://vueuse.org/useCssVar\r",
      " * @param prop\r",
      " * @param target\r",
      " * @param options\r",
      " */\r",
      "export function useCssVar(\r",
      "  prop: MaybeRefOrGetter<string>,\r",
      "  target?: MaybeElementRef,\r",
      "  options: UseCssVarOptions = {},\r",
      ") {\r",
      "  const { window = defaultWindow, initialValue = '', observe = false } = options\r",
      "  const variable = ref(initialValue)\r",
      "  const elRef = computed(() => unrefElement(target) || window?.document?.documentElement)\r",
      "\r",
      "  function updateCssVar() {\r",
      "    const key = toValue(prop)\r",
      "    const el = toValue(elRef)\r",
      "    if (el && window) {\r",
      "      const value = window.getComputedStyle(el).getPropertyValue(key)?.trim()\r",
      "      variable.value = value || initialValue\r",
      "    }\r",
      "  }\r",
      "\r",
      "  if (observe) {\r",
      "    useMutationObserver(elRef, updateCssVar, {\r",
      "      attributeFilter: ['style', 'class'],\r",
      "      window,\r",
      "    })\r",
      "  }\r",
      "\r",
      "  watch(\r",
      "    [elRef, () => toValue(prop)],\r",
      "    updateCssVar,\r",
      "    { immediate: true },\r",
      "  )\r",
      "\r",
      "  watch(\r",
      "    variable,\r",
      "    (val) => {\r",
      "      if (elRef.value?.style)\r",
      "        elRef.value.style.setProperty(toValue(prop), val)\r",
      "    },\r",
      "  )\r",
      "\r",
      "  return variable\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useCssVar } from '@vueuse/core'\r",
      "\r",
      "const el = ref(null)\r",
      "const color = useCssVar('--color', el)\r",
      "\r",
      "function switchColor() {\r",
      "  if (color.value === '#df8543')\r",
      "    color.value = '#7fa998'\r",
      "  else\r",
      "    color.value = '#df8543'\r",
      "}\r",
      "\r",
      "const elv = ref(null)\r",
      "const key = ref('--color')\r",
      "const colorVal = useCssVar(key, elv)\r",
      "function changeVar() {\r",
      "  if (key.value === '--color')\r",
      "    key.value = '--color-one'\r",
      "  else\r",
      "    key.value = '--color'\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\" style=\"--color: #7fa998; color: var(--color)\">\r",
      "    Sample text, {{ color }}\r",
      "  </div>\r",
      "  <button @click=\"switchColor\">\r",
      "    Change Color\r",
      "  </button>\r",
      "  <div ref=\"elv\" style=\"--color: #7fa998; --color-one: #df8543;\" :style=\"{ color: colorVal }\">\r",
      "    Sample text, {{ key }}: {{ colorVal }}\r",
      "  </div>\r",
      "  <button style=\"margin-left: 0;\" @click=\"changeVar\">\r",
      "    Change Color Variable\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useCurrentElement - vueuse": {
    "prefix": "hvue useCurrentElement - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Component\r",
      "---\r",
      "\r",
      "# useCurrentElement\r",
      "\r",
      "Get the DOM element of current component as a ref.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useCurrentElement } from '@vueuse/core'\r",
      "\r",
      "const el = useCurrentElement() // ComputedRef<Element>\r",
      "```\r",
      "\r",
      "## Caveats\r",
      "\r",
      "This functions uses [`$el` under the hood](https://vuejs.org/api/component-instance.html#el).\r",
      "\r",
      "Value of the ref will be `undefined` until the component is mounted.\r",
      "\r",
      "- For components with a single root element, it will point to that element.\r",
      "- For components with text root, it will point to the text node.\r",
      "- For components with multiple root nodes, it will be the placeholder DOM node that Vue uses to keep track of the component's position in the DOM.\r",
      "\r",
      "It's recommend to only use this function for components with **a single root element**.\r",
      "# Source TS",
      "```js",
      "// eslint-disable-next-line no-restricted-imports\r",
      "import { getCurrentInstance, onMounted, onUpdated } from 'vue-demi'\r",
      "import { computedWithControl } from '@vueuse/shared'\r",
      "\r",
      "export function useCurrentElement<T extends Element = Element>() {\r",
      "  const vm = getCurrentInstance()!\r",
      "  const currentElement = computedWithControl(\r",
      "    () => null,\r",
      "    () => vm.proxy!.$el as T,\r",
      "  )\r",
      "\r",
      "  onUpdated(currentElement.trigger)\r",
      "  onMounted(currentElement.trigger)\r",
      "\r",
      "  return currentElement\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useCurrentElement } from '@vueuse/core'\r",
      "import { watchEffect } from 'vue'\r",
      "\r",
      "const el = useCurrentElement()\r",
      "\r",
      "watchEffect(() => {\r",
      "  console.log('Current element:', el.value)\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Open your console.log to see the element</div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useCycleList - vueuse": {
    "prefix": "hvue useCycleList - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useCycleList\r",
      "\r",
      "Cycle through a list of items.\r",
      "\r",
      "<CourseLink href=\"https://vueschool.io/lessons/create-an-image-carousel-with-vueuse?friend=vueuse\">Learn how to use useCycleList to create an image carousel with this FREE video lesson from Vue School!</CourseLink>\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useCycleList } from '@vueuse/core'\r",
      "\r",
      "const { state, next, prev } = useCycleList([\r",
      "  'Dog',\r",
      "  'Cat',\r",
      "  'Lizard',\r",
      "  'Shark',\r",
      "  'Whale',\r",
      "  'Dolphin',\r",
      "  'Octopus',\r",
      "  'Seal',\r",
      "])\r",
      "\r",
      "console.log(state.value) // 'Dog'\r",
      "\r",
      "prev()\r",
      "\r",
      "console.log(state.value) // 'Seal'\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { computed, shallowRef, watch } from 'vue-demi'\r",
      "import { toRef, toValue } from '@vueuse/shared'\r",
      "import type { MaybeRef, MaybeRefOrGetter } from '@vueuse/shared'\r",
      "\r",
      "export interface UseCycleListOptions<T> {\r",
      "  /**\r",
      "   * The initial value of the state.\r",
      "   * A ref can be provided to reuse.\r",
      "   */\r",
      "  initialValue?: MaybeRef<T>\r",
      "\r",
      "  /**\r",
      "   * The default index when\r",
      "   */\r",
      "  fallbackIndex?: number\r",
      "\r",
      "  /**\r",
      "   * Custom function to get the index of the current value.\r",
      "   */\r",
      "  getIndexOf?: (value: T, list: T[]) => number\r",
      "}\r",
      "\r",
      "/**\r",
      " * Cycle through a list of items\r",
      " *\r",
      " * @see https://vueuse.org/useCycleList\r",
      " */\r",
      "export function useCycleList<T>(list: MaybeRefOrGetter<T[]>, options?: UseCycleListOptions<T>): UseCycleListReturn<T> {\r",
      "  const state = shallowRef(getInitialValue()) as Ref<T>\r",
      "  const listRef = toRef(list)\r",
      "\r",
      "  const index = computed<number>({\r",
      "    get() {\r",
      "      const targetList = listRef.value\r",
      "\r",
      "      let index = options?.getIndexOf\r",
      "        ? options.getIndexOf(state.value, targetList)\r",
      "        : targetList.indexOf(state.value)\r",
      "\r",
      "      if (index < 0)\r",
      "        index = options?.fallbackIndex ?? 0\r",
      "\r",
      "      return index\r",
      "    },\r",
      "    set(v) {\r",
      "      set(v)\r",
      "    },\r",
      "  })\r",
      "\r",
      "  function set(i: number) {\r",
      "    const targetList = listRef.value\r",
      "    const length = targetList.length\r",
      "    const index = (i % length + length) % length\r",
      "    const value = targetList[index]\r",
      "    state.value = value\r",
      "    return value\r",
      "  }\r",
      "\r",
      "  function shift(delta = 1) {\r",
      "    return set(index.value + delta)\r",
      "  }\r",
      "\r",
      "  function next(n = 1) {\r",
      "    return shift(n)\r",
      "  }\r",
      "\r",
      "  function prev(n = 1) {\r",
      "    return shift(-n)\r",
      "  }\r",
      "\r",
      "  function getInitialValue() {\r",
      "    return toValue(options?.initialValue ?? toValue<T[]>(list)[0]) ?? undefined\r",
      "  }\r",
      "\r",
      "  watch(listRef, () => set(index.value))\r",
      "\r",
      "  return {\r",
      "    state,\r",
      "    index,\r",
      "    next,\r",
      "    prev,\r",
      "  }\r",
      "}\r",
      "\r",
      "export interface UseCycleListReturn<T> {\r",
      "  state: Ref<T>\r",
      "  index: Ref<number>\r",
      "  next: (n?: number) => T\r",
      "  prev: (n?: number) => T\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useCycleList } from '@vueuse/core'\r",
      "import { ref } from 'vue'\r",
      "\r",
      "const list = ref([\r",
      "  'Dog',\r",
      "  'Cat',\r",
      "  'Lizard',\r",
      "  'Shark',\r",
      "  'Whale',\r",
      "  'Dolphin',\r",
      "  'Octopus',\r",
      "  'Seal',\r",
      "])\r",
      "\r",
      "const { state, next, prev } = useCycleList(list)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div class=\"text-primary text-lg font-bold\">\r",
      "      {{ state }}\r",
      "    </div>\r",
      "    <button @click=\"prev()\">\r",
      "      Prev\r",
      "    </button>\r",
      "    <button @click=\"next()\">\r",
      "      Next\r",
      "    </button>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDark - vueuse": {
    "prefix": "hvue useDark - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "related:\r",
      "  - useColorMode\r",
      "  - usePreferredDark\r",
      "  - useStorage\r",
      "---\r",
      "\r",
      "# useDark\r",
      "\r",
      "Reactive dark mode with auto data persistence.\r",
      "\r",
      "<CourseLink href=\"https://vueschool.io/lessons/theming-with-vueuse-usedark-and-usecolormode?friend=vueuse\">Learn useDark with this FREE video lesson from Vue School!</CourseLink>\r",
      "\r",
      "## Basic Usage\r",
      "\r",
      "```js\r",
      "import { useDark, useToggle } from '@vueuse/core'\r",
      "\r",
      "const isDark = useDark()\r",
      "const toggleDark = useToggle(isDark)\r",
      "```\r",
      "\r",
      "## Behavior\r",
      "\r",
      "`useDark` combines with `usePreferredDark` and `useStorage`. On start up, it reads the value from localStorage/sessionStorage (the key is configurable) to see if there is a user configured color scheme, if not, it will use users' system preferences. When you change the `isDark` ref, it will update the corresponding element's attribute and then store the preference to storage (default key: `vueuse-color-scheme`) for persistence.\r",
      "\r",
      "> Please note `useDark` only handles the DOM attribute changes for you to apply proper selector in your CSS. It does NOT handle the actual style, theme or CSS for you.\r",
      "\r",
      "## Configuration\r",
      "\r",
      "By default, it uses [Tailwind CSS favored dark mode](https://tailwindcss.com/docs/dark-mode#toggling-dark-mode-manually), which enables dark mode when class `dark` is applied to the `html` tag, for example:\r",
      "\r",
      "```html\r",
      "<!--light-->\r",
      "<html> ... </html>\r",
      "\r",
      "<!--dark-->\r",
      "<html class=\"dark\"> ... </html>\r",
      "```\r",
      "\r",
      "Still, you can also customize it to make it work with most CSS frameworks.\r",
      "\r",
      "For example:\r",
      "\r",
      "```ts\r",
      "const isDark = useDark({\r",
      "  selector: 'body',\r",
      "  attribute: 'color-scheme',\r",
      "  valueDark: 'dark',\r",
      "  valueLight: 'light',\r",
      "})\r",
      "```\r",
      "\r",
      "will work like\r",
      "\r",
      "```html\r",
      "<!--light-->\r",
      "<html>\r",
      "  <body color-scheme=\"light\"> ... </body>\r",
      "</html>\r",
      "\r",
      "<!--dark-->\r",
      "<html>\r",
      "  <body color-scheme=\"dark\"> ... </body>\r",
      "</html>\r",
      "```\r",
      "\r",
      "If the configuration above still does not fit your needs, you can use the`onChanged` option to take full control over how you handle updates.\r",
      "\r",
      "```ts\r",
      "const isDark = useDark({\r",
      "  onChanged(dark: boolean) {\r",
      "    // update the dom, call the API or something\r",
      "  },\r",
      "})\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseDark v-slot=\"{ isDark, toggleDark }\">\r",
      "  <button @click=\"toggleDark()\">\r",
      "    Is Dark: {{ isDark }}\r",
      "  </button>\r",
      "</UseDark>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed } from 'vue-demi'\r",
      "import { useColorMode } from '../useColorMode'\r",
      "import type { BasicColorSchema, UseColorModeOptions } from '../useColorMode'\r",
      "\r",
      "export interface UseDarkOptions extends Omit<UseColorModeOptions<BasicColorSchema>, 'modes' | 'onChanged'> {\r",
      "  /**\r",
      "   * Value applying to the target element when isDark=true\r",
      "   *\r",
      "   * @default 'dark'\r",
      "   */\r",
      "  valueDark?: string\r",
      "\r",
      "  /**\r",
      "   * Value applying to the target element when isDark=false\r",
      "   *\r",
      "   * @default ''\r",
      "   */\r",
      "  valueLight?: string\r",
      "\r",
      "  /**\r",
      "   * A custom handler for handle the updates.\r",
      "   * When specified, the default behavior will be overridden.\r",
      "   *\r",
      "   * @default undefined\r",
      "   */\r",
      "  onChanged?: (isDark: boolean, defaultHandler: ((mode: BasicColorSchema) => void), mode: BasicColorSchema) => void\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive dark mode with auto data persistence.\r",
      " *\r",
      " * @see https://vueuse.org/useDark\r",
      " * @param options\r",
      " */\r",
      "export function useDark(options: UseDarkOptions = {}) {\r",
      "  const {\r",
      "    valueDark = 'dark',\r",
      "    valueLight = '',\r",
      "  } = options\r",
      "\r",
      "  const mode = useColorMode({\r",
      "    ...options,\r",
      "    onChanged: (mode, defaultHandler) => {\r",
      "      if (options.onChanged)\r",
      "        options.onChanged?.(mode === 'dark', defaultHandler, mode)\r",
      "      else\r",
      "        defaultHandler(mode)\r",
      "    },\r",
      "    modes: {\r",
      "      dark: valueDark,\r",
      "      light: valueLight,\r",
      "    },\r",
      "  })\r",
      "\r",
      "  const isDark = computed<boolean>({\r",
      "    get() {\r",
      "      return mode.value === 'dark'\r",
      "    },\r",
      "    set(v) {\r",
      "      const modeVal = v ? 'dark' : 'light'\r",
      "      if (mode.system.value === modeVal)\r",
      "        mode.value = 'auto'\r",
      "      else\r",
      "        mode.value = modeVal\r",
      "    },\r",
      "  })\r",
      "\r",
      "  return isDark\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useToggle } from '@vueuse/shared'\r",
      "import { isDark } from '../../.vitepress/theme/composables/dark'\r",
      "\r",
      "// const isDark = useDark()\r",
      "const toggleDark = useToggle(isDark)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"toggleDark()\">\r",
      "    <i inline-block align-middle i=\"dark:carbon-moon carbon-sun\" />\r",
      "\r",
      "    <span class=\"ml-2\">{{ isDark ? 'Dark' : 'Light' }}</span>\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDebouncedRefHistory - vueuse": {
    "prefix": "hvue useDebouncedRefHistory - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: State\r",
      "related:\r",
      "  - useRefHistory\r",
      "  - useThrottledRefHistory\r",
      "---\r",
      "\r",
      "# useDebouncedRefHistory\r",
      "\r",
      "Shorthand for `useRefHistory` with debounced filter.\r",
      "\r",
      "## Usage\r",
      "\r",
      "This function takes a snapshot of your counter after 1000ms when the value of it starts to change.\r",
      "\r",
      "```ts\r",
      "import { ref } from 'vue'\r",
      "import { useDebouncedRefHistory } from '@vueuse/core'\r",
      "\r",
      "const counter = ref(0)\r",
      "const { history, undo, redo } = useDebouncedRefHistory(counter, { deep: true, debounce: 1000 })\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { debounceFilter } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import type { UseRefHistoryOptions, UseRefHistoryReturn } from '../useRefHistory'\r",
      "import { useRefHistory } from '../useRefHistory'\r",
      "\r",
      "/**\r",
      " * Shorthand for [useRefHistory](https://vueuse.org/useRefHistory) with debounce filter.\r",
      " *\r",
      " * @see https://vueuse.org/useDebouncedRefHistory\r",
      " * @param source\r",
      " * @param options\r",
      " */\r",
      "export function useDebouncedRefHistory<Raw, Serialized = Raw>(\r",
      "  source: Ref<Raw>,\r",
      "  options: Omit<UseRefHistoryOptions<Raw, Serialized>, 'eventFilter'> & { debounce?: MaybeRefOrGetter<number> } = {},\r",
      "): UseRefHistoryReturn<Raw, Serialized> {\r",
      "  const filter = options.debounce ? debounceFilter(options.debounce) : undefined\r",
      "  const history = useRefHistory(source, { ...options, eventFilter: filter })\r",
      "\r",
      "  return {\r",
      "    ...history,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script lang=\"ts\" setup>\r",
      "import { ref } from 'vue'\r",
      "import { useCounter } from '@vueuse/shared'\r",
      "import { formatDate, useDebouncedRefHistory } from '@vueuse/core'\r",
      "\r",
      "import type { Ref } from 'vue'\r",
      "\r",
      "function format(ts: number) {\r",
      "  return formatDate(new Date(ts), 'YYYY-MM-DD HH:mm:ss')\r",
      "}\r",
      "const delay: Ref<number> = ref(1000)\r",
      "\r",
      "const { count, inc, dec } = useCounter()\r",
      "const { history, undo, redo, canUndo, canRedo } = useDebouncedRefHistory(\r",
      "  count, { capacity: 10, debounce: delay },\r",
      ")\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Count: {{ count }}</div>\r",
      "  <button @click=\"inc()\">\r",
      "    Increment\r",
      "  </button>\r",
      "  <button @click=\"dec()\">\r",
      "    Decrement\r",
      "  </button>\r",
      "  <span class=\"ml-2\">/</span>\r",
      "  <button :disabled=\"!canUndo\" @click=\"undo()\">\r",
      "    Undo\r",
      "  </button>\r",
      "  <button :disabled=\"!canRedo\" @click=\"redo()\">\r",
      "    Redo\r",
      "  </button>\r",
      "  <br>\r",
      "  <span>Delay (in ms):</span>\r",
      "  <input v-model=\"delay\" type=\"number\">\r",
      "  <br>\r",
      "  <br>\r",
      "  <note>History (limited to 10 records for demo)</note>\r",
      "  <div class=\"code-block mt-4\">\r",
      "    <div v-for=\"i in history\" :key=\"i.timestamp\">\r",
      "      <span class=\"opacity-50 mr-2 font-mono\">{{ format(i.timestamp) }}</span>\r",
      "      <span class=\"font-mono\">{ value: {{ i.snapshot }} }</span>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDeviceMotion - vueuse": {
    "prefix": "hvue useDeviceMotion - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useDeviceMotion\r",
      "\r",
      "Reactive [DeviceMotionEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent). Provide web developers with information about the speed of changes for the device's position and orientation.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useDeviceMotion } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  acceleration,\r",
      "  accelerationIncludingGravity,\r",
      "  rotationRate,\r",
      "  interval,\r",
      "} = useDeviceMotion()\r",
      "```\r",
      "\r",
      "| State                        | Type     | Description                                                                                                          |\r",
      "| ---------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------- |\r",
      "| acceleration                 | `object` | An object giving the acceleration of the device on the three axis X, Y and Z.                                        |\r",
      "| accelerationIncludingGravity | `object` | An object giving the acceleration of the device on the three axis X, Y and Z with the effect of gravity.             |\r",
      "| rotationRate                 | `object` | An object giving the rate of change of the device's orientation on the three orientation axis alpha, beta and gamma. |\r",
      "| interval                     | `Number` | A number representing the interval of time, in milliseconds, at which data is obtained from the device..             |\r",
      "\r",
      "You can find [more information about the state on the MDN](https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent#Properties).\r",
      "\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseDeviceMotion v-slot=\"{ acceleration }\">\r",
      "  Acceleration: {{ acceleration }}\r",
      "</UseDeviceMotion>\r",
      "```\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */\r",
      "\r",
      "import type { ConfigurableEventFilter } from '@vueuse/shared'\r",
      "import { bypassFilter, createFilterWrapper } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface DeviceMotionOptions extends ConfigurableWindow, ConfigurableEventFilter {}\r",
      "\r",
      "/**\r",
      " * Reactive DeviceMotionEvent.\r",
      " *\r",
      " * @see https://vueuse.org/useDeviceMotion\r",
      " * @param options\r",
      " */\r",
      "export function useDeviceMotion(options: DeviceMotionOptions = {}) {\r",
      "  const {\r",
      "    window = defaultWindow,\r",
      "    eventFilter = bypassFilter,\r",
      "  } = options\r",
      "\r",
      "  const acceleration: Ref<DeviceMotionEvent['acceleration']> = ref({ x: null, y: null, z: null })\r",
      "  const rotationRate: Ref<DeviceMotionEvent['rotationRate']> = ref({ alpha: null, beta: null, gamma: null })\r",
      "  const interval = ref(0)\r",
      "  const accelerationIncludingGravity: Ref<DeviceMotionEvent['accelerationIncludingGravity']> = ref({\r",
      "    x: null,\r",
      "    y: null,\r",
      "    z: null,\r",
      "  })\r",
      "\r",
      "  if (window) {\r",
      "    const onDeviceMotion = createFilterWrapper(\r",
      "      eventFilter,\r",
      "      (event: DeviceMotionEvent) => {\r",
      "        acceleration.value = event.acceleration\r",
      "        accelerationIncludingGravity.value = event.accelerationIncludingGravity\r",
      "        rotationRate.value = event.rotationRate\r",
      "        interval.value = event.interval\r",
      "      },\r",
      "    )\r",
      "\r",
      "    useEventListener(window, 'devicemotion', onDeviceMotion)\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    acceleration,\r",
      "    accelerationIncludingGravity,\r",
      "    rotationRate,\r",
      "    interval,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseDeviceMotionReturn = ReturnType<typeof useDeviceMotion>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, reactive } from 'vue'\r",
      "import { useDeviceMotion } from '@vueuse/core'\r",
      "\r",
      "const motion = reactive(useDeviceMotion())\r",
      "const text = computed(() => JSON.stringify(motion, null, 2))\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    Device Motion:\r",
      "  </note>\r",
      "  <pre lang=\"json\">{{ text }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDeviceOrientation - vueuse": {
    "prefix": "hvue useDeviceOrientation - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useDeviceOrientation\r",
      "\r",
      "Reactive [DeviceOrientationEvent](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent). Provide web developers with information from the physical orientation of the device running the web page.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useDeviceOrientation } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isAbsolute,\r",
      "  alpha,\r",
      "  beta,\r",
      "  gamma,\r",
      "} = useDeviceOrientation()\r",
      "```\r",
      "\r",
      "| State      | Type     | Description                                                                                                                |\r",
      "| ---------- | -------- | -------------------------------------------------------------------------------------------------------------------------- |\r",
      "| isAbsolute | `boolean` | A boolean that indicates whether or not the device is providing orientation data absolutely.                               |\r",
      "| alpha      | `number` | A number representing the motion of the device around the z axis, express in degrees with values ranging from 0 to 360.    |\r",
      "| beta       | `number` | A number representing the motion of the device around the x axis, express in degrees with values ranging from -180 to 180. |\r",
      "| gamma      | `number` | A number representing the motion of the device around the y axis, express in degrees with values ranging from -90 to 90.   |\r",
      "\r",
      "You can find [more information about the state on the MDN](https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent#Properties).\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseDeviceOrientation v-slot=\"{ alpha, beta, gamma }\">\r",
      "  Alpha: {{ alpha }}\r",
      "  Beta: {{ beta }}\r",
      "  Gamma: {{ gamma }}\r",
      "</UseDeviceOrientation>\r",
      "```\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */\r",
      "\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Reactive DeviceOrientationEvent.\r",
      " *\r",
      " * @see https://vueuse.org/useDeviceOrientation\r",
      " * @param options\r",
      " */\r",
      "export function useDeviceOrientation(options: ConfigurableWindow = {}) {\r",
      "  const { window = defaultWindow } = options\r",
      "  const isSupported = useSupported(() => window && 'DeviceOrientationEvent' in window)\r",
      "\r",
      "  const isAbsolute = ref(false)\r",
      "  const alpha: Ref<number | null> = ref(null)\r",
      "  const beta: Ref<number | null> = ref(null)\r",
      "  const gamma: Ref<number | null> = ref(null)\r",
      "\r",
      "  if (window && isSupported.value) {\r",
      "    useEventListener(window, 'deviceorientation', (event) => {\r",
      "      isAbsolute.value = event.absolute\r",
      "      alpha.value = event.alpha\r",
      "      beta.value = event.beta\r",
      "      gamma.value = event.gamma\r",
      "    })\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    isAbsolute,\r",
      "    alpha,\r",
      "    beta,\r",
      "    gamma,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseDeviceOrientationReturn = ReturnType<typeof useDeviceOrientation>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { reactive } from 'vue'\r",
      "import { useDeviceOrientation } from '@vueuse/core'\r",
      "\r",
      "const orientation = reactive(useDeviceOrientation())\r",
      "const text = stringify(orientation)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <pre lang=\"yaml\">{{ text }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDevicePixelRatio - vueuse": {
    "prefix": "hvue useDevicePixelRatio - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useDevicePixelRatio\r",
      "\r",
      "Reactively track [`window.devicePixelRatio`](https://developer.mozilla.org/ru/docs/Web/API/Window/devicePixelRatio)\r",
      ">\r",
      "> NOTE: there is no event listener for `window.devicePixelRatio` change. So this function uses [`Testing media queries programmatically (window.matchMedia)`](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Testing_media_queries) applying the same mechanism as described in [this example](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio#monitoring_screen_resolution_or_zoom_level_changes).\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useDevicePixelRatio } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const { pixelRatio } = useDevicePixelRatio()\r",
      "\r",
      "    return { pixelRatio }\r",
      "  },\r",
      "}\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseDevicePixelRatio v-slot=\"{ pixelRatio }\">\r",
      "  Pixel Ratio: {{ pixelRatio }}\r",
      "</UseDevicePixelRatio>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import { tryOnScopeDispose } from '@vueuse/shared'\r",
      "import { type ConfigurableWindow, defaultWindow } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Reactively track `window.devicePixelRatio`.\r",
      " *\r",
      " * @see https://vueuse.org/useDevicePixelRatio\r",
      " * @param options\r",
      " */\r",
      "export function useDevicePixelRatio({\r",
      "  window = defaultWindow,\r",
      "}: ConfigurableWindow = {}) {\r",
      "  const pixelRatio = ref(1)\r",
      "\r",
      "  if (window) {\r",
      "    let media: MediaQueryList\r",
      "    function observe() {\r",
      "      pixelRatio.value = window!.devicePixelRatio\r",
      "      cleanup()\r",
      "      media = window!.matchMedia(`(resolution: ${pixelRatio.value}dppx)`)\r",
      "      media.addEventListener('change', observe, { once: true })\r",
      "    }\r",
      "    function cleanup() {\r",
      "      media?.removeEventListener('change', observe)\r",
      "    }\r",
      "\r",
      "    observe()\r",
      "    tryOnScopeDispose(cleanup)\r",
      "  }\r",
      "\r",
      "  return { pixelRatio }\r",
      "}\r",
      "\r",
      "export type UseDevicePixelRatioReturn = ReturnType<typeof useDevicePixelRatio>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { reactive } from 'vue'\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useDevicePixelRatio } from '@vueuse/core'\r",
      "\r",
      "const pixelRatio = reactive(useDevicePixelRatio())\r",
      "const code = stringify(pixelRatio)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Device Pixel Ratio:</div>\r",
      "  <pre>{{ code }}</pre>\r",
      "  <span class=\"opacity-50\">Zoom in and out (or move the window to a screen with a different scaling factor) to see the value changes</span>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDevicesList - vueuse": {
    "prefix": "hvue useDevicesList - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useDevicesList\r",
      "\r",
      "Reactive [enumerateDevices](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices) listing available input/output devices.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useDevicesList } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  devices,\r",
      "  videoInputs: cameras,\r",
      "  audioInputs: microphones,\r",
      "  audioOutputs: speakers,\r",
      "} = useDevicesList()\r",
      "```\r",
      "\r",
      "# Component\r",
      "```html\r",
      "<UseDevicesList v-slot=\"{ videoInputs, audioInputs, audioOutputs }\">\r",
      "  Cameras: {{ videoInputs }}\r",
      "  Microphones: {{ audioInputs }}\r",
      "  Speakers: {{ audioOutputs }}\r",
      "</UseDevicesList>\r",
      "```\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */\r",
      "\r",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { computed, ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { usePermission } from '../usePermission'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableNavigator } from '../_configurable'\r",
      "import { defaultNavigator } from '../_configurable'\r",
      "\r",
      "export interface UseDevicesListOptions extends ConfigurableNavigator {\r",
      "  onUpdated?: (devices: MediaDeviceInfo[]) => void\r",
      "  /**\r",
      "   * Request for permissions immediately if it's not granted,\r",
      "   * otherwise label and deviceIds could be empty\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  requestPermissions?: boolean\r",
      "  /**\r",
      "   * Request for types of media permissions\r",
      "   *\r",
      "   * @default { audio: true, video: true }\r",
      "   */\r",
      "  constraints?: MediaStreamConstraints\r",
      "}\r",
      "\r",
      "export interface UseDevicesListReturn {\r",
      "  /**\r",
      "   * All devices\r",
      "   */\r",
      "  devices: Ref<MediaDeviceInfo[]>\r",
      "  videoInputs: ComputedRef<MediaDeviceInfo[]>\r",
      "  audioInputs: ComputedRef<MediaDeviceInfo[]>\r",
      "  audioOutputs: ComputedRef<MediaDeviceInfo[]>\r",
      "  permissionGranted: Ref<boolean>\r",
      "  ensurePermissions: () => Promise<boolean>\r",
      "  isSupported: Ref<boolean>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive `enumerateDevices` listing available input/output devices\r",
      " *\r",
      " * @see https://vueuse.org/useDevicesList\r",
      " * @param options\r",
      " */\r",
      "export function useDevicesList(options: UseDevicesListOptions = {}): UseDevicesListReturn {\r",
      "  const {\r",
      "    navigator = defaultNavigator,\r",
      "    requestPermissions = false,\r",
      "    constraints = { audio: true, video: true },\r",
      "    onUpdated,\r",
      "  } = options\r",
      "\r",
      "  const devices = ref([]) as Ref<MediaDeviceInfo[]>\r",
      "  const videoInputs = computed(() => devices.value.filter(i => i.kind === 'videoinput'))\r",
      "  const audioInputs = computed(() => devices.value.filter(i => i.kind === 'audioinput'))\r",
      "  const audioOutputs = computed(() => devices.value.filter(i => i.kind === 'audiooutput'))\r",
      "  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)\r",
      "  const permissionGranted = ref(false)\r",
      "  let stream: MediaStream | null\r",
      "\r",
      "  async function update() {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "\r",
      "    devices.value = await navigator!.mediaDevices.enumerateDevices()\r",
      "    onUpdated?.(devices.value)\r",
      "    if (stream) {\r",
      "      stream.getTracks().forEach(t => t.stop())\r",
      "      stream = null\r",
      "    }\r",
      "  }\r",
      "\r",
      "  async function ensurePermissions() {\r",
      "    if (!isSupported.value)\r",
      "      return false\r",
      "\r",
      "    if (permissionGranted.value)\r",
      "      return true\r",
      "\r",
      "    const { state, query } = usePermission('camera', { controls: true })\r",
      "    await query()\r",
      "    if (state.value !== 'granted') {\r",
      "      stream = await navigator!.mediaDevices.getUserMedia(constraints)\r",
      "      update()\r",
      "      permissionGranted.value = true\r",
      "    }\r",
      "    else {\r",
      "      permissionGranted.value = true\r",
      "    }\r",
      "\r",
      "    return permissionGranted.value\r",
      "  }\r",
      "\r",
      "  if (isSupported.value) {\r",
      "    if (requestPermissions)\r",
      "      ensurePermissions()\r",
      "\r",
      "    useEventListener(navigator!.mediaDevices, 'devicechange', update)\r",
      "    update()\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    devices,\r",
      "    ensurePermissions,\r",
      "    permissionGranted,\r",
      "    videoInputs,\r",
      "    audioInputs,\r",
      "    audioOutputs,\r",
      "    isSupported,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useDevicesList } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  videoInputs: cameras,\r",
      "  audioInputs: microphones,\r",
      "  audioOutputs: speakers,\r",
      "} = useDevicesList({\r",
      "  requestPermissions: true,\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"grid grid-cols-3 text-center\" gap=\"2\" p=\"y-4\">\r",
      "    <i i-carbon-camera />\r",
      "    <i i-carbon-microphone />\r",
      "    <i i-carbon-headphones />\r",
      "\r",
      "    <div class=\"title\">\r",
      "      Camera ({{ cameras.length }})\r",
      "    </div>\r",
      "    <div class=\"title\">\r",
      "      Microphones ({{ microphones.length }})\r",
      "    </div>\r",
      "    <div class=\"title\">\r",
      "      Speakers ({{ speakers.length }})\r",
      "    </div>\r",
      "\r",
      "    <div>\r",
      "      <div v-for=\"i of cameras\" :key=\"i.deviceId\" text=\"sm\">\r",
      "        {{ i.label }}\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <div>\r",
      "      <div v-for=\"i of microphones\" :key=\"i.deviceId\" text=\"sm\">\r",
      "        {{ i.label }}\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <div>\r",
      "      <div v-for=\"i of speakers\" :key=\"i.deviceId\" text=\"sm\">\r",
      "        {{ i.label }}\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style lang=\"postcss\" scoped>\r",
      "i {\r",
      "  @apply text-2xl opacity-50 m-auto;\r",
      "}\r",
      "\r",
      ".title {\r",
      "  @apply opacity-50 uppercase tracking-wide text-sm;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDisplayMedia - vueuse": {
    "prefix": "hvue useDisplayMedia - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "related: useUserMedia\r",
      "---\r",
      "\r",
      "# useDisplayMedia\r",
      "\r",
      "Reactive [`mediaDevices.getDisplayMedia`](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia) streaming.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useDisplayMedia } from '@vueuse/core'\r",
      "\r",
      "const { stream, start } = useDisplayMedia()\r",
      "\r",
      "// start streaming\r",
      "\r",
      "start()\r",
      "```\r",
      "\r",
      "```ts\r",
      "const video = document.getElementById('video')\r",
      "\r",
      "watchEffect(() => {\r",
      "  // preview on a video element\r",
      "  video.srcObject = stream.value\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRef } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref, shallowRef, watch } from 'vue-demi'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableNavigator } from '../_configurable'\r",
      "import { defaultNavigator } from '../_configurable'\r",
      "\r",
      "export interface UseDisplayMediaOptions extends ConfigurableNavigator {\r",
      "  /**\r",
      "   * If the stream is enabled\r",
      "   * @default false\r",
      "   */\r",
      "  enabled?: MaybeRef<boolean>\r",
      "\r",
      "  /**\r",
      "   * If the stream video media constraints\r",
      "   */\r",
      "  video?: boolean | MediaTrackConstraints | undefined\r",
      "  /**\r",
      "   * If the stream audio media constraints\r",
      "   */\r",
      "  audio?: boolean | MediaTrackConstraints | undefined\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive `mediaDevices.getDisplayMedia` streaming\r",
      " *\r",
      " * @see https://vueuse.org/useDisplayMedia\r",
      " * @param options\r",
      " */\r",
      "export function useDisplayMedia(options: UseDisplayMediaOptions = {}) {\r",
      "  const enabled = ref(options.enabled ?? false)\r",
      "  const video = options.video\r",
      "  const audio = options.audio\r",
      "  const { navigator = defaultNavigator } = options\r",
      "  const isSupported = useSupported(() => navigator?.mediaDevices?.getDisplayMedia)\r",
      "\r",
      "  // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\r",
      "  // @ts-ignore Type mismatch in different version of TS\r",
      "  const constraint: MediaStreamConstraints = { audio, video }\r",
      "\r",
      "  const stream: Ref<MediaStream | undefined> = shallowRef()\r",
      "\r",
      "  async function _start() {\r",
      "    if (!isSupported.value || stream.value)\r",
      "      return\r",
      "    stream.value = await navigator!.mediaDevices.getDisplayMedia(constraint)\r",
      "    return stream.value\r",
      "  }\r",
      "\r",
      "  async function _stop() {\r",
      "    stream.value?.getTracks().forEach(t => t.stop())\r",
      "    stream.value = undefined\r",
      "  }\r",
      "\r",
      "  function stop() {\r",
      "    _stop()\r",
      "    enabled.value = false\r",
      "  }\r",
      "\r",
      "  async function start() {\r",
      "    await _start()\r",
      "    if (stream.value)\r",
      "      enabled.value = true\r",
      "    return stream.value\r",
      "  }\r",
      "\r",
      "  watch(\r",
      "    enabled,\r",
      "    (v) => {\r",
      "      if (v)\r",
      "        _start()\r",
      "      else\r",
      "        _stop()\r",
      "    },\r",
      "    { immediate: true },\r",
      "  )\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    stream,\r",
      "    start,\r",
      "    stop,\r",
      "    enabled,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseDisplayMediaReturn = ReturnType<typeof useDisplayMedia>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref, watchEffect } from 'vue'\r",
      "import { useDisplayMedia } from '@vueuse/core'\r",
      "\r",
      "const video = ref<HTMLVideoElement>()\r",
      "const { stream, enabled } = useDisplayMedia()\r",
      "\r",
      "watchEffect(() => {\r",
      "  if (video.value)\r",
      "    video.value.srcObject = stream.value!\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"flex flex-col gap-4 text-center\">\r",
      "    <div>\r",
      "      <button @click=\"enabled = !enabled\">\r",
      "        {{ enabled ? 'Stop' : 'Start' }} sharing my screen\r",
      "      </button>\r",
      "    </div>\r",
      "\r",
      "    <div>\r",
      "      <video\r",
      "        ref=\"video\"\r",
      "        muted\r",
      "        autoplay\r",
      "        controls\r",
      "        class=\"h-100 w-auto\"\r",
      "      />\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDocumentVisibility - vueuse": {
    "prefix": "hvue useDocumentVisibility - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useDocumentVisibility\r",
      "\r",
      "Reactively track [`document.visibilityState`](https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState)\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useDocumentVisibility } from '@vueuse/core'\r",
      "\r",
      "const visibility = useDocumentVisibility()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "```html\r",
      "<UseDocumentVisibility v-slot=\"{ visibility }\">\r",
      "  Document Visibility: {{ visibility }}\r",
      "</UseDocumentVisibility>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Reactively track `document.visibilityState`.\r",
      " *\r",
      " * @see https://vueuse.org/useDocumentVisibility\r",
      " * @param options\r",
      " */\r",
      "export function useDocumentVisibility({ document = defaultDocument }: ConfigurableDocument = {}): Ref<DocumentVisibilityState> {\r",
      "  if (!document)\r",
      "    return ref('visible')\r",
      "\r",
      "  const visibility = ref(document.visibilityState)\r",
      "\r",
      "  useEventListener(document, 'visibilitychange', () => {\r",
      "    visibility.value = document.visibilityState\r",
      "  })\r",
      "\r",
      "  return visibility\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref, watch } from 'vue'\r",
      "import { useTimeoutFn } from '@vueuse/shared'\r",
      "import { useDocumentVisibility } from '@vueuse/core'\r",
      "\r",
      "const startMessage = 'üí° Minimize the page or switch tab then return'\r",
      "const message = ref(startMessage)\r",
      "const visibility = useDocumentVisibility()\r",
      "\r",
      "const timeout = useTimeoutFn(() => {\r",
      "  message.value = startMessage\r",
      "}, 3000)\r",
      "\r",
      "watch(visibility, (current, previous) => {\r",
      "  if (current === 'visible' && previous === 'hidden') {\r",
      "    message.value = 'üéâ Welcome back!'\r",
      "    timeout.start()\r",
      "  }\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>{{ message }}</div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDraggable - vueuse": {
    "prefix": "hvue useDraggable - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useDraggable\r",
      "\r",
      "Make elements draggable.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useDraggable } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "\r",
      "// `style` will be a helper computed for `left: ?px; top: ?px;`\r",
      "const { x, y, style } = useDraggable(el, {\r",
      "  initialValue: { x: 40, y: 40 },\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\" :style=\"style\" style=\"position: fixed\">\r",
      "    Drag me! I am at {{x}}, {{y}}\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseDraggable :initialValue=\"{ x: 10, y: 10 }\" v-slot=\"{ x, y }\">\r",
      "  Drag me! I am at {{x}}, {{y}}\r",
      "</UseDraggable>\r",
      "```\r",
      "\r",
      "For component usage, additional props `storageKey` and `storageType` can be passed to the component and enable the persistence of the element position.\r",
      "\r",
      "```html\r",
      "<UseDraggable storage-key=\"vueuse-draggable\" storage-type=\"session\">\r",
      "  Refresh the page and I am still in the same position!\r",
      "</UseDraggable>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed, ref } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { isClient, toRefs, toValue } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { PointerType, Position } from '../types'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface UseDraggableOptions {\r",
      "  /**\r",
      "   * Only start the dragging when click on the element directly\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  exact?: MaybeRefOrGetter<boolean>\r",
      "\r",
      "  /**\r",
      "   * Prevent events defaults\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  preventDefault?: MaybeRefOrGetter<boolean>\r",
      "\r",
      "  /**\r",
      "   * Prevent events propagation\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  stopPropagation?: MaybeRefOrGetter<boolean>\r",
      "\r",
      "  /**\r",
      "   * Whether dispatch events in capturing phase\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  capture?: boolean\r",
      "\r",
      "  /**\r",
      "   * Element to attach `pointermove` and `pointerup` events to.\r",
      "   *\r",
      "   * @default window\r",
      "   */\r",
      "  draggingElement?: MaybeRefOrGetter<HTMLElement | SVGElement | Window | Document | null | undefined>\r",
      "\r",
      "  /**\r",
      "   * Handle that triggers the drag event\r",
      "   *\r",
      "   * @default target\r",
      "   */\r",
      "  handle?: MaybeRefOrGetter<HTMLElement | SVGElement | null | undefined>\r",
      "\r",
      "  /**\r",
      "   * Pointer types that listen to.\r",
      "   *\r",
      "   * @default ['mouse', 'touch', 'pen']\r",
      "   */\r",
      "  pointerTypes?: PointerType[]\r",
      "\r",
      "  /**\r",
      "   * Initial position of the element.\r",
      "   *\r",
      "   * @default { x: 0, y: 0 }\r",
      "   */\r",
      "  initialValue?: MaybeRefOrGetter<Position>\r",
      "\r",
      "  /**\r",
      "   * Callback when the dragging starts. Return `false` to prevent dragging.\r",
      "   */\r",
      "  onStart?: (position: Position, event: PointerEvent) => void | false\r",
      "\r",
      "  /**\r",
      "   * Callback during dragging.\r",
      "   */\r",
      "  onMove?: (position: Position, event: PointerEvent) => void\r",
      "\r",
      "  /**\r",
      "   * Callback when dragging end.\r",
      "   */\r",
      "  onEnd?: (position: Position, event: PointerEvent) => void\r",
      "\r",
      "  /**\r",
      "   * Axis to drag on.\r",
      "   *\r",
      "   * @default 'both'\r",
      "   */\r",
      "  axis?: 'x' | 'y' | 'both'\r",
      "}\r",
      "\r",
      "/**\r",
      " * Make elements draggable.\r",
      " *\r",
      " * @see https://vueuse.org/useDraggable\r",
      " * @param target\r",
      " * @param options\r",
      " */\r",
      "export function useDraggable(\r",
      "  target: MaybeRefOrGetter<HTMLElement | SVGElement | null | undefined>,\r",
      "  options: UseDraggableOptions = {},\r",
      ") {\r",
      "  const {\r",
      "    pointerTypes,\r",
      "    preventDefault,\r",
      "    stopPropagation,\r",
      "    exact,\r",
      "    onMove,\r",
      "    onEnd,\r",
      "    onStart,\r",
      "    initialValue,\r",
      "    axis = 'both',\r",
      "    draggingElement = defaultWindow,\r",
      "    handle: draggingHandle = target,\r",
      "  } = options\r",
      "\r",
      "  const position = ref<Position>(\r",
      "    toValue(initialValue) ?? { x: 0, y: 0 },\r",
      "  )\r",
      "\r",
      "  const pressedDelta = ref<Position>()\r",
      "\r",
      "  const filterEvent = (e: PointerEvent) => {\r",
      "    if (pointerTypes)\r",
      "      return pointerTypes.includes(e.pointerType as PointerType)\r",
      "    return true\r",
      "  }\r",
      "\r",
      "  const handleEvent = (e: PointerEvent) => {\r",
      "    if (toValue(preventDefault))\r",
      "      e.preventDefault()\r",
      "    if (toValue(stopPropagation))\r",
      "      e.stopPropagation()\r",
      "  }\r",
      "\r",
      "  const start = (e: PointerEvent) => {\r",
      "    if (!filterEvent(e))\r",
      "      return\r",
      "    if (toValue(exact) && e.target !== toValue(target))\r",
      "      return\r",
      "    const rect = toValue(target)!.getBoundingClientRect()\r",
      "    const pos = {\r",
      "      x: e.clientX - rect.left,\r",
      "      y: e.clientY - rect.top,\r",
      "    }\r",
      "    if (onStart?.(pos, e) === false)\r",
      "      return\r",
      "    pressedDelta.value = pos\r",
      "    handleEvent(e)\r",
      "  }\r",
      "  const move = (e: PointerEvent) => {\r",
      "    if (!filterEvent(e))\r",
      "      return\r",
      "    if (!pressedDelta.value)\r",
      "      return\r",
      "\r",
      "    let { x, y } = position.value\r",
      "    if (axis === 'x' || axis === 'both')\r",
      "      x = e.clientX - pressedDelta.value.x\r",
      "    if (axis === 'y' || axis === 'both')\r",
      "      y = e.clientY - pressedDelta.value.y\r",
      "    position.value = {\r",
      "      x,\r",
      "      y,\r",
      "    }\r",
      "    onMove?.(position.value, e)\r",
      "    handleEvent(e)\r",
      "  }\r",
      "  const end = (e: PointerEvent) => {\r",
      "    if (!filterEvent(e))\r",
      "      return\r",
      "    if (!pressedDelta.value)\r",
      "      return\r",
      "    pressedDelta.value = undefined\r",
      "    onEnd?.(position.value, e)\r",
      "    handleEvent(e)\r",
      "  }\r",
      "\r",
      "  if (isClient) {\r",
      "    const config = { capture: options.capture ?? true }\r",
      "    useEventListener(draggingHandle, 'pointerdown', start, config)\r",
      "    useEventListener(draggingElement, 'pointermove', move, config)\r",
      "    useEventListener(draggingElement, 'pointerup', end, config)\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    ...toRefs(position),\r",
      "    position,\r",
      "    isDragging: computed(() => !!pressedDelta.value),\r",
      "    style: computed(\r",
      "      () => `left:${position.value.x}px;top:${position.value.y}px;`,\r",
      "    ),\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseDraggableReturn = ReturnType<typeof useDraggable>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { isClient } from '@vueuse/shared'\r",
      "import { useDraggable } from '@vueuse/core'\r",
      "import { UseDraggable as Draggable } from './component'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "const handle = ref<HTMLElement | null>(null)\r",
      "\r",
      "const innerWidth = isClient ? window.innerWidth : 200\r",
      "\r",
      "const { x, y, style } = useDraggable(el, {\r",
      "  initialValue: { x: innerWidth / 4.2, y: 80 },\r",
      "  preventDefault: true,\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <p italic op50 text-center>\r",
      "      Check the floating boxes\r",
      "    </p>\r",
      "    <div\r",
      "      ref=\"el\"\r",
      "      p=\"x-4 y-2\"\r",
      "      border=\"~ gray-400/30 rounded\"\r",
      "      shadow=\"~ hover:lg\"\r",
      "      class=\"fixed bg-$vp-c-bg select-none cursor-move z-24\"\r",
      "      style=\"touch-action:none;\"\r",
      "      :style=\"style\"\r",
      "    >\r",
      "      üëã Drag me!\r",
      "      <div class=\"text-sm opacity-50\">\r",
      "        I am at {{ Math.round(x) }}, {{ Math.round(y) }}\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <Draggable\r",
      "      v-slot=\"{ x, y }\"\r",
      "      p=\"x-4 y-2\"\r",
      "      border=\"~ gray-400/30 rounded\"\r",
      "      shadow=\"~ hover:lg\"\r",
      "      class=\"fixed bg-$vp-c-bg select-none cursor-move z-24\"\r",
      "      :initial-value=\"{ x: innerWidth / 3.9, y: 150 }\"\r",
      "      :prevent-default=\"true\"\r",
      "      storage-key=\"vueuse-draggable-pos\"\r",
      "      storage-type=\"session\"\r",
      "    >\r",
      "      Renderless component\r",
      "      <div class=\"text-xs opacity-50\">\r",
      "        Position persisted in sessionStorage\r",
      "      </div>\r",
      "      <div class=\"text-sm opacity-50\">\r",
      "        {{ Math.round(x) }}, {{ Math.round(y) }}\r",
      "      </div>\r",
      "    </Draggable>\r",
      "\r",
      "    <Draggable\r",
      "      v-slot=\"{ x, y }\"\r",
      "      p=\"x-4 y-2\"\r",
      "      border=\"~ gray-400/30 rounded\"\r",
      "      shadow=\"~ hover:lg\"\r",
      "      class=\"fixed bg-$vp-c-bg select-none z-24\"\r",
      "      :initial-value=\"{ x: innerWidth / 3.6, y: 240 }\"\r",
      "      :prevent-default=\"true\"\r",
      "      :handle=\"handle\"\r",
      "    >\r",
      "      <div ref=\"handle\" class=\"cursor-move\">\r",
      "        üëã Drag here!\r",
      "      </div>\r",
      "      <div class=\"text-xs opacity-50\">\r",
      "        Handle that triggers the drag event\r",
      "      </div>\r",
      "      <div class=\"text-sm opacity-50\">\r",
      "        I am at {{ Math.round(x) }}, {{ Math.round(y) }}\r",
      "      </div>\r",
      "    </Draggable>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDropZone - vueuse": {
    "prefix": "hvue useDropZone - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useDropZone\r",
      "\r",
      "Create a zone where files can be dropped.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { useDropZone } from '@vueuse/core'\r",
      "\r",
      "const dropZoneRef = ref<HTMLDivElement>()\r",
      "\r",
      "function onDrop(files: File[] | null) {\r",
      "  // called when files are dropped on zone\r",
      "}\r",
      "\r",
      "const { isOverDropZone } = useDropZone(dropZoneRef, onDrop)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"dropZoneRef\">\r",
      "    Drop files here\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref, shallowRef } from 'vue-demi'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { isClient } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "\r",
      "export interface UseDropZoneReturn {\r",
      "  files: Ref<File[] | null>\r",
      "  isOverDropZone: Ref<boolean>\r",
      "}\r",
      "\r",
      "export interface UseDropZoneOptions {\r",
      "  onDrop?: (files: File[] | null, event: DragEvent) => void\r",
      "  onEnter?: (files: File[] | null, event: DragEvent) => void\r",
      "  onLeave?: (files: File[] | null, event: DragEvent) => void\r",
      "  onOver?: (files: File[] | null, event: DragEvent) => void\r",
      "}\r",
      "\r",
      "export function useDropZone(\r",
      "  target: MaybeRefOrGetter<HTMLElement | null | undefined>,\r",
      "  options: UseDropZoneOptions | UseDropZoneOptions['onDrop'] = {},\r",
      "): UseDropZoneReturn {\r",
      "  const isOverDropZone = ref(false)\r",
      "  const files = shallowRef<File[] | null>(null)\r",
      "  let counter = 0\r",
      "\r",
      "  if (isClient) {\r",
      "    const _options = typeof options === 'function' ? { onDrop: options } : options\r",
      "    const getFiles = (event: DragEvent) => {\r",
      "      const list = Array.from(event.dataTransfer?.files ?? [])\r",
      "      return files.value = list.length === 0 ? null : list\r",
      "    }\r",
      "\r",
      "    useEventListener<DragEvent>(target, 'dragenter', (event) => {\r",
      "      event.preventDefault()\r",
      "      counter += 1\r",
      "      isOverDropZone.value = true\r",
      "      _options.onEnter?.(getFiles(event), event)\r",
      "    })\r",
      "    useEventListener<DragEvent>(target, 'dragover', (event) => {\r",
      "      event.preventDefault()\r",
      "      _options.onOver?.(getFiles(event), event)\r",
      "    })\r",
      "    useEventListener<DragEvent>(target, 'dragleave', (event) => {\r",
      "      event.preventDefault()\r",
      "      counter -= 1\r",
      "      if (counter === 0)\r",
      "        isOverDropZone.value = false\r",
      "      _options.onLeave?.(getFiles(event), event)\r",
      "    })\r",
      "    useEventListener<DragEvent>(target, 'drop', (event) => {\r",
      "      event.preventDefault()\r",
      "      counter = 0\r",
      "      isOverDropZone.value = false\r",
      "      _options.onDrop?.(getFiles(event), event)\r",
      "    })\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    files,\r",
      "    isOverDropZone,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useDropZone } from '@vueuse/core'\r",
      "\r",
      "const filesData = ref<{ name: string; size: number; type: string; lastModified: number }[]>([])\r",
      "function onDrop(files: File[] | null) {\r",
      "  filesData.value = []\r",
      "  if (files) {\r",
      "    filesData.value = files.map(file => ({\r",
      "      name: file.name,\r",
      "      size: file.size,\r",
      "      type: file.type,\r",
      "      lastModified: file.lastModified,\r",
      "    }))\r",
      "  }\r",
      "}\r",
      "\r",
      "const dropZoneRef = ref<HTMLElement>()\r",
      "\r",
      "const { isOverDropZone } = useDropZone(dropZoneRef, onDrop)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"flex\">\r",
      "    <div class=\"w-full h-auto relative\">\r",
      "      <p>Drop files into dropZone</p>\r",
      "      <img src=\"/favicon.ico\" alt=\"Drop me\">\r",
      "\r",
      "      <div ref=\"dropZoneRef\" class=\"flex flex-col w-full min-h-200px h-auto bg-gray-400/10 justify-center items-center mt-6\">\r",
      "        <div> isOverDropZone: <BooleanDisplay :value=\"isOverDropZone\" /></div>\r",
      "        <div class=\"flex flex-wrap justify-center items-center\">\r",
      "          <div v-for=\"(file, index) in filesData\" :key=\"index\" class=\"w-200px bg-black-200/10 ma-2 pa-6\">\r",
      "            <p>Name: {{ file.name }}</p>\r",
      "            <p>Size: {{ file.size }}</p>\r",
      "            <p>Type: {{ file.type }}</p>\r",
      "            <p>Last modified: {{ file.lastModified }}</p>\r",
      "          </div>\r",
      "        </div>\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useElementBounding - vueuse": {
    "prefix": "hvue useElementBounding - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useElementBounding\r",
      "\r",
      "Reactive [bounding box](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) of an HTML element\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <div ref=\"el\" />\r",
      "</template>\r",
      "\r",
      "<script>\r",
      "import { ref } from 'vue'\r",
      "import { useElementBounding } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const el = ref(null)\r",
      "    const { x, y, top, right, bottom, left, width, height } = useElementBounding(el)\r",
      "\r",
      "    return {\r",
      "      el,\r",
      "      /* ... */\r",
      "    }\r",
      "  }\r",
      "}\r",
      "</script>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseElementBounding v-slot=\"{ width, height }\">\r",
      "  Width: {{ width }}\r",
      "  Height: {{ height }}\r",
      "</UseElementBounding>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref, watch } from 'vue-demi'\r",
      "import { tryOnMounted } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { MaybeComputedElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { useResizeObserver } from '../useResizeObserver'\r",
      "\r",
      "export interface UseElementBoundingOptions {\r",
      "  /**\r",
      "   * Reset values to 0 on component unmounted\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  reset?: boolean\r",
      "\r",
      "  /**\r",
      "   * Listen to window resize event\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  windowResize?: boolean\r",
      "  /**\r",
      "   * Listen to window scroll event\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  windowScroll?: boolean\r",
      "\r",
      "  /**\r",
      "   * Immediately call update on component mounted\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive bounding box of an HTML element.\r",
      " *\r",
      " * @see https://vueuse.org/useElementBounding\r",
      " * @param target\r",
      " */\r",
      "export function useElementBounding(\r",
      "  target: MaybeComputedElementRef,\r",
      "  options: UseElementBoundingOptions = {},\r",
      ") {\r",
      "  const {\r",
      "    reset = true,\r",
      "    windowResize = true,\r",
      "    windowScroll = true,\r",
      "    immediate = true,\r",
      "  } = options\r",
      "\r",
      "  const height = ref(0)\r",
      "  const bottom = ref(0)\r",
      "  const left = ref(0)\r",
      "  const right = ref(0)\r",
      "  const top = ref(0)\r",
      "  const width = ref(0)\r",
      "  const x = ref(0)\r",
      "  const y = ref(0)\r",
      "\r",
      "  function update() {\r",
      "    const el = unrefElement(target)\r",
      "\r",
      "    if (!el) {\r",
      "      if (reset) {\r",
      "        height.value = 0\r",
      "        bottom.value = 0\r",
      "        left.value = 0\r",
      "        right.value = 0\r",
      "        top.value = 0\r",
      "        width.value = 0\r",
      "        x.value = 0\r",
      "        y.value = 0\r",
      "      }\r",
      "      return\r",
      "    }\r",
      "\r",
      "    const rect = el.getBoundingClientRect()\r",
      "\r",
      "    height.value = rect.height\r",
      "    bottom.value = rect.bottom\r",
      "    left.value = rect.left\r",
      "    right.value = rect.right\r",
      "    top.value = rect.top\r",
      "    width.value = rect.width\r",
      "    x.value = rect.x\r",
      "    y.value = rect.y\r",
      "  }\r",
      "\r",
      "  useResizeObserver(target, update)\r",
      "  watch(() => unrefElement(target), ele => !ele && update())\r",
      "\r",
      "  if (windowScroll)\r",
      "    useEventListener('scroll', update, { capture: true, passive: true })\r",
      "  if (windowResize)\r",
      "    useEventListener('resize', update, { passive: true })\r",
      "\r",
      "  tryOnMounted(() => {\r",
      "    if (immediate)\r",
      "      update()\r",
      "  })\r",
      "\r",
      "  return {\r",
      "    height,\r",
      "    bottom,\r",
      "    left,\r",
      "    right,\r",
      "    top,\r",
      "    width,\r",
      "    x,\r",
      "    y,\r",
      "    update,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseElementBoundingReturn = ReturnType<typeof useElementBounding>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { reactive, ref } from 'vue'\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useElementBounding } from '@vueuse/core'\r",
      "\r",
      "const el = ref(null)\r",
      "const rect = reactive(useElementBounding(el))\r",
      "const text = stringify(rect)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div style=\"min-height: 300px\">\r",
      "    <note class=\"mb-2\">\r",
      "      Resize the box to see changes\r",
      "    </note>\r",
      "    <textarea ref=\"el\" readonly class=\"resizer\" :value=\"text\" />\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useElementByPoint - vueuse": {
    "prefix": "hvue useElementByPoint - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useElementByPoint\r",
      "\r",
      "Reactive element by point.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useElementByPoint, useMouse } from '@vueuse/core'\r",
      "\r",
      "const { x, y } = useMouse({ type: 'client' })\r",
      "const { element } = useElementByPoint({ x, y })\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter, Pausable } from '@vueuse/shared'\r",
      "import { toValue, useIntervalFn } from '@vueuse/shared'\r",
      "import { useRafFn } from '../useRafFn'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "export interface UseElementByPointOptions<Multiple extends boolean = false> extends ConfigurableDocument {\r",
      "  x: MaybeRefOrGetter<number>\r",
      "  y: MaybeRefOrGetter<number>\r",
      "  multiple?: MaybeRefOrGetter<Multiple>\r",
      "  immediate?: boolean\r",
      "  interval?: 'requestAnimationFrame' | number\r",
      "}\r",
      "\r",
      "export interface UseElementByPointReturn<Multiple extends boolean = false> extends Pausable {\r",
      "  isSupported: Ref<boolean>\r",
      "  element: Ref<Multiple extends true ? HTMLElement[] : HTMLElement | null>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive element by point.\r",
      " *\r",
      " * @see https://vueuse.org/useElementByPoint\r",
      " * @param options - UseElementByPointOptions\r",
      " */\r",
      "export function useElementByPoint<M extends boolean = false>(options: UseElementByPointOptions<M>): UseElementByPointReturn<M> {\r",
      "  const {\r",
      "    x, y,\r",
      "    document = defaultDocument,\r",
      "    multiple,\r",
      "    interval = 'requestAnimationFrame',\r",
      "    immediate = true,\r",
      "  } = options\r",
      "\r",
      "  const isSupported = useSupported(() => {\r",
      "    if (toValue(multiple))\r",
      "      return document && 'elementsFromPoint' in document\r",
      "\r",
      "    return document && 'elementFromPoint' in document\r",
      "  })\r",
      "\r",
      "  const element = ref<any>(null)\r",
      "\r",
      "  const cb = () => {\r",
      "    element.value = toValue(multiple)\r",
      "      ? document?.elementsFromPoint(toValue(x), toValue(y)) ?? []\r",
      "      : document?.elementFromPoint(toValue(x), toValue(y)) ?? null\r",
      "  }\r",
      "\r",
      "  const controls: Pausable = interval === 'requestAnimationFrame'\r",
      "    ? useRafFn(cb, { immediate })\r",
      "    : useIntervalFn(cb, interval, { immediate })\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    element,\r",
      "    ...controls,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script lang=\"ts\" setup>\r",
      "import { computed, reactive } from 'vue'\r",
      "import { useElementBounding, useElementByPoint, useEventListener, useMouse } from '@vueuse/core'\r",
      "\r",
      "const { x, y } = useMouse({ type: 'client' })\r",
      "const { element } = useElementByPoint({ x, y })\r",
      "const bounding = reactive(useElementBounding(element))\r",
      "\r",
      "useEventListener('scroll', bounding.update, true)\r",
      "\r",
      "const boxStyles = computed(() => {\r",
      "  if (element.value) {\r",
      "    return {\r",
      "      display: 'block',\r",
      "      width: `${bounding.width}px`,\r",
      "      height: `${bounding.height}px`,\r",
      "      left: `${bounding.left}px`,\r",
      "      top: `${bounding.top}px`,\r",
      "      backgroundColor: '#3eaf7c44',\r",
      "      transition: 'all 0.05s linear',\r",
      "    } as Record<string, string | number>\r",
      "  }\r",
      "  return {\r",
      "    display: 'none',\r",
      "  }\r",
      "})\r",
      "\r",
      "const pointStyles = computed<Record<string, string | number>>(() => ({\r",
      "  transform: `translate(calc(${x.value}px - 50%), calc(${y.value}px - 50%))`,\r",
      "}))\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div\r",
      "    :style=\"boxStyles\"\r",
      "    fixed\r",
      "    pointer-events-none\r",
      "    z-9999\r",
      "    border=\"1 $vp-c-brand\"\r",
      "  />\r",
      "  <div\r",
      "    :style=\"pointStyles\"\r",
      "    fixed\r",
      "    top-0\r",
      "    left-0\r",
      "    pointer-events-none\r",
      "    w-2\r",
      "    h-2\r",
      "    rounded-full\r",
      "    bg-green-400\r",
      "    shadow\r",
      "    z-999\r",
      "  />\r",
      "  <div class=\"flex items-center\">\r",
      "    <span class=\"mr-4\">X</span>\r",
      "    <input v-model=\"x\" type=\"number\">\r",
      "  </div>\r",
      "  <div class=\"flex items-center\">\r",
      "    <span class=\"mr-4\">Y</span>\r",
      "    <input v-model=\"y\" type=\"number\">\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useElementHover - vueuse": {
    "prefix": "hvue useElementHover - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useElementHover\r",
      "\r",
      "Reactive element's hover state.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```vue\r",
      "<script setup>\r",
      "import { useElementHover } from '@vueuse/core'\r",
      "\r",
      "const myHoverableElement = ref()\r",
      "const isHovered = useElementHover(myHoverableElement)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button ref=\"myHoverableElement\">\r",
      "    {{ isHovered }}\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Directive Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { vElementHover } from '@vueuse/components'\r",
      "\r",
      "const isHovered = ref(false)\r",
      "function onHover(state: boolean) {\r",
      "  isHovered.value = state\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button v-element-hover=\"onHover\">\r",
      "    {{ isHovered ? 'Thank you!' : 'Hover me' }}\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface UseElementHoverOptions extends ConfigurableWindow {\r",
      "  delayEnter?: number\r",
      "  delayLeave?: number\r",
      "}\r",
      "\r",
      "export function useElementHover(el: MaybeRefOrGetter<EventTarget | null | undefined>, options: UseElementHoverOptions = {}): Ref<boolean> {\r",
      "  const {\r",
      "    delayEnter = 0,\r",
      "    delayLeave = 0,\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const isHovered = ref(false)\r",
      "  let timer: ReturnType<typeof setTimeout> | undefined\r",
      "\r",
      "  const toggle = (entering: boolean) => {\r",
      "    const delay = entering ? delayEnter : delayLeave\r",
      "    if (timer) {\r",
      "      clearTimeout(timer)\r",
      "      timer = undefined\r",
      "    }\r",
      "\r",
      "    if (delay)\r",
      "      timer = setTimeout(() => isHovered.value = entering, delay)\r",
      "    else\r",
      "      isHovered.value = entering\r",
      "  }\r",
      "\r",
      "  if (!window)\r",
      "    return isHovered\r",
      "\r",
      "  useEventListener(el, 'mouseenter', () => toggle(true), { passive: true })\r",
      "  useEventListener(el, 'mouseleave', () => toggle(false), { passive: true })\r",
      "\r",
      "  return isHovered\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useElementHover } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLButtonElement>()\r",
      "const isHovered = useElementHover(el, { delayEnter: 200, delayLeave: 600 })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button ref=\"el\">\r",
      "    <span>{{ isHovered ? 'Thank you!' : 'Hover me' }}</span>\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useElementSize - vueuse": {
    "prefix": "hvue useElementSize - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useElementSize\r",
      "\r",
      "Reactive size of an HTML element. [ResizeObserver MDN](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <div ref=\"el\">\r",
      "    Height: {{ height }}\r",
      "    Width: {{ width }}\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<script>\r",
      "import { ref } from 'vue'\r",
      "import { useElementSize } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const el = ref(null)\r",
      "    const { width, height } = useElementSize(el)\r",
      "\r",
      "    return {\r",
      "      el,\r",
      "      width,\r",
      "      height,\r",
      "    }\r",
      "  }\r",
      "}\r",
      "</script>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseElementSize v-slot=\"{ width, height }\">\r",
      "  Width: {{ width }}\r",
      "  Height: {{ height }}\r",
      "</UseElementSize>\r",
      "```\r",
      "## Directive Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { vElementSize } from '@vueuse/components'\r",
      "function onResize({ width, height }: { width: number; height: number }) {\r",
      "  console.log(width, height)\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <textarea v-element-size=\"onResize\" />\r",
      "  <!-- with options -->\r",
      "  <textarea v-element-size=\"[onResize, {width:100,height:100}, {'box':'content-box'} ]\" />\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed, ref, watch } from 'vue-demi'\r",
      "import type { MaybeComputedElementRef } from '../unrefElement'\r",
      "import type { UseResizeObserverOptions } from '../useResizeObserver'\r",
      "import { useResizeObserver } from '../useResizeObserver'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface ElementSize {\r",
      "  width: number\r",
      "  height: number\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive size of an HTML element.\r",
      " *\r",
      " * @see https://vueuse.org/useElementSize\r",
      " * @param target\r",
      " * @param callback\r",
      " * @param options\r",
      " */\r",
      "export function useElementSize(\r",
      "  target: MaybeComputedElementRef,\r",
      "  initialSize: ElementSize = { width: 0, height: 0 },\r",
      "  options: UseResizeObserverOptions = {},\r",
      ") {\r",
      "  const { window = defaultWindow, box = 'content-box' } = options\r",
      "  const isSVG = computed(() => unrefElement(target)?.namespaceURI?.includes('svg'))\r",
      "  const width = ref(initialSize.width)\r",
      "  const height = ref(initialSize.height)\r",
      "\r",
      "  useResizeObserver(\r",
      "    target,\r",
      "    ([entry]) => {\r",
      "      const boxSize = box === 'border-box'\r",
      "        ? entry.borderBoxSize\r",
      "        : box === 'content-box'\r",
      "          ? entry.contentBoxSize\r",
      "          : entry.devicePixelContentBoxSize\r",
      "\r",
      "      if (window && isSVG.value) {\r",
      "        const $elem = unrefElement(target)\r",
      "        if ($elem) {\r",
      "          const styles = window.getComputedStyle($elem)\r",
      "          width.value = Number.parseFloat(styles.width)\r",
      "          height.value = Number.parseFloat(styles.height)\r",
      "        }\r",
      "      }\r",
      "      else {\r",
      "        if (boxSize) {\r",
      "          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize]\r",
      "          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0)\r",
      "          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0)\r",
      "        }\r",
      "        else {\r",
      "          // fallback\r",
      "          width.value = entry.contentRect.width\r",
      "          height.value = entry.contentRect.height\r",
      "        }\r",
      "      }\r",
      "    },\r",
      "    options,\r",
      "  )\r",
      "\r",
      "  watch(\r",
      "    () => unrefElement(target),\r",
      "    (ele) => {\r",
      "      width.value = ele ? initialSize.width : 0\r",
      "      height.value = ele ? initialSize.height : 0\r",
      "    },\r",
      "  )\r",
      "\r",
      "  return {\r",
      "    width,\r",
      "    height,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseElementSizeReturn = ReturnType<typeof useElementSize>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { reactive, ref } from 'vue'\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useElementSize } from '@vueuse/core'\r",
      "\r",
      "const el = ref(null)\r",
      "const size = reactive(\r",
      "  useElementSize(\r",
      "    el,\r",
      "    { width: 0, height: 0 },\r",
      "    { box: 'border-box' },\r",
      "  ),\r",
      ")\r",
      "const text = stringify(size)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    Resize the box to see changes\r",
      "  </note>\r",
      "  <textarea ref=\"el\" class=\"resizer\" v-text=\"text\" />\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useElementVisibility - vueuse": {
    "prefix": "hvue useElementVisibility - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useElementVisibility\r",
      "\r",
      "Tracks the visibility of an element within the viewport.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <div ref=\"target\">\r",
      "    <h1>Hello world</h1>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<script>\r",
      "import { ref } from 'vue'\r",
      "import { useElementVisibility } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const target = ref(null)\r",
      "    const targetIsVisible = useElementVisibility(target)\r",
      "\r",
      "    return {\r",
      "      target,\r",
      "      targetIsVisible,\r",
      "    }\r",
      "  }\r",
      "}\r",
      "</script>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseElementVisibility v-slot=\"{ isVisible }\">\r",
      "  Is Visible: {{ isVisible }}\r",
      "</UseElementVisibility>\r",
      "```\r",
      "\r",
      "## Directive Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { vElementVisibility } from '@vueuse/components'\r",
      "\r",
      "const target = ref(null)\r",
      "const isVisible = ref(false)\r",
      "\r",
      "function onElementVisibility(state) {\r",
      "  isVisible.value = state\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div v-element-visibility=\"onElementVisibility\">\r",
      "    {{ isVisible ? 'inside' : 'outside' }}\r",
      "  </div>\r",
      "\r",
      "  <!-- with options -->\r",
      "  <div ref=\"target\">\r",
      "    <div v-element-visibility=\"[onElementVisibility, { scrollTarget: target }]\">\r",
      "      {{ isVisible ? 'inside' : 'outside' }}\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { ref } from 'vue-demi'\r",
      "import type { MaybeComputedElementRef } from '../unrefElement'\r",
      "import { useIntersectionObserver } from '../useIntersectionObserver'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface UseElementVisibilityOptions extends ConfigurableWindow {\r",
      "  scrollTarget?: MaybeRefOrGetter<HTMLElement | undefined | null>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Tracks the visibility of an element within the viewport.\r",
      " *\r",
      " * @see https://vueuse.org/useElementVisibility\r",
      " * @param element\r",
      " * @param options\r",
      " */\r",
      "export function useElementVisibility(\r",
      "  element: MaybeComputedElementRef,\r",
      "  { window = defaultWindow, scrollTarget }: UseElementVisibilityOptions = {},\r",
      ") {\r",
      "  const elementIsVisible = ref(false)\r",
      "\r",
      "  useIntersectionObserver(\r",
      "    element,\r",
      "    ([{ isIntersecting }]) => {\r",
      "      elementIsVisible.value = isIntersecting\r",
      "    },\r",
      "    {\r",
      "      root: scrollTarget,\r",
      "      window,\r",
      "    },\r",
      "  )\r",
      "\r",
      "  return elementIsVisible\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useElementVisibility } from '@vueuse/core'\r",
      "\r",
      "const el = ref(null)\r",
      "const isVisible = useElementVisibility(el)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <note class=\"mb-2\">\r",
      "      Info on the right bottom corner\r",
      "    </note>\r",
      "    <div ref=\"el\" class=\"max-w-100 relative area bg-white dark:bg-gray-800 shadow-lg z-60\">\r",
      "      Target Element (scroll down)\r",
      "    </div>\r",
      "  </div>\r",
      "  <div class=\"float m-3 area shadow-lg\">\r",
      "    Element\r",
      "    <BooleanDisplay\r",
      "      :value=\"isVisible\"\r",
      "      true=\"inside\"\r",
      "      false=\"outside\"\r",
      "      class=\"font-bold\"\r",
      "    />\r",
      "    the viewport\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useEventBus - vueuse": {
    "prefix": "hvue useEventBus - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useEventBus\r",
      "\r",
      "A basic event bus.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useEventBus } from '@vueuse/core'\r",
      "\r",
      "const bus = useEventBus<string>('news')\r",
      "\r",
      "function listener(event: string) {\r",
      "  console.log(`news: ${event}`)\r",
      "}\r",
      "\r",
      "// listen to an event\r",
      "const unsubscribe = bus.on(listener)\r",
      "\r",
      "// fire an event\r",
      "bus.emit('The Tokyo Olympics has begun')\r",
      "\r",
      "// unregister the listener\r",
      "unsubscribe()\r",
      "// or\r",
      "bus.off(listener)\r",
      "\r",
      "// clearing all listeners\r",
      "bus.reset()\r",
      "```\r",
      "\r",
      "Listeners registered inside of components `setup` will be unregistered automatically when the component gets unmounted.\r",
      "\r",
      "## TypeScript\r",
      "\r",
      "Using `EventBusKey` is the key to bind the event type to the key, similar to Vue's [`InjectionKey`](https://antfu.me/posts/typed-provide-and-inject-in-vue) util.\r",
      "\r",
      "```ts\r",
      "// fooKey.ts\r",
      "import type { EventBusKey } from '@vueuse/core'\r",
      "\r",
      "export const fooKey: EventBusKey<{ name: foo }> = Symbol('symbol-key')\r",
      "```\r",
      "\r",
      "```ts\r",
      "import { useEventBus } from '@vueuse/core'\r",
      "\r",
      "import { fooKey } from './fooKey'\r",
      "\r",
      "const bus = useEventBus(fooKey)\r",
      "\r",
      "bus.on((e) => {\r",
      "  // `e` will be `{ name: foo }`\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Fn } from '@vueuse/shared'\r",
      "import { getCurrentScope } from 'vue-demi'\r",
      "import { events } from './internal'\r",
      "\r",
      "export type EventBusListener<T = unknown, P = any> = (event: T, payload?: P) => void\r",
      "export type EventBusEvents<T, P = any> = Set<EventBusListener<T, P>>\r",
      "\r",
      "// eslint-disable-next-line unused-imports/no-unused-vars\r",
      "export interface EventBusKey<T> extends Symbol { }\r",
      "\r",
      "export type EventBusIdentifier<T = unknown> = EventBusKey<T> | string | number\r",
      "\r",
      "export interface UseEventBusReturn<T, P> {\r",
      "  /**\r",
      "   * Subscribe to an event. When calling emit, the listeners will execute.\r",
      "   * @param listener watch listener.\r",
      "   * @returns a stop function to remove the current callback.\r",
      "   */\r",
      "  on: (listener: EventBusListener<T, P>) => Fn\r",
      "  /**\r",
      "   * Similar to `on`, but only fires once\r",
      "   * @param listener watch listener.\r",
      "   * @returns a stop function to remove the current callback.\r",
      "   */\r",
      "  once: (listener: EventBusListener<T, P>) => Fn\r",
      "  /**\r",
      "   * Emit an event, the corresponding event listeners will execute.\r",
      "   * @param event data sent.\r",
      "   */\r",
      "  emit: (event?: T, payload?: P) => void\r",
      "  /**\r",
      "   * Remove the corresponding listener.\r",
      "   * @param listener watch listener.\r",
      "   */\r",
      "  off: (listener: EventBusListener<T>) => void\r",
      "  /**\r",
      "   * Clear all events\r",
      "   */\r",
      "  reset: () => void\r",
      "}\r",
      "\r",
      "export function useEventBus<T = unknown, P = any>(key: EventBusIdentifier<T>): UseEventBusReturn<T, P> {\r",
      "  const scope = getCurrentScope()\r",
      "  function on(listener: EventBusListener<T, P>) {\r",
      "    const listeners = (events.get(key) || new Set())\r",
      "    listeners.add(listener)\r",
      "    events.set(key, listeners)\r",
      "\r",
      "    const _off = () => off(listener)\r",
      "    // auto unsubscribe when scope get disposed\r",
      "    // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\r",
      "    // @ts-ignore vue3 and vue2 mis-align\r",
      "    scope?.cleanups?.push(_off)\r",
      "    return _off\r",
      "  }\r",
      "\r",
      "  function once(listener: EventBusListener<T, P>) {\r",
      "    function _listener(...args: any[]) {\r",
      "      off(_listener)\r",
      "      // @ts-expect-error cast\r",
      "      listener(...args)\r",
      "    }\r",
      "    return on(_listener)\r",
      "  }\r",
      "\r",
      "  function off(listener: EventBusListener<T>): void {\r",
      "    const listeners = events.get(key)\r",
      "    if (!listeners)\r",
      "      return\r",
      "\r",
      "    listeners.delete(listener)\r",
      "\r",
      "    if (!listeners.size)\r",
      "      reset()\r",
      "  }\r",
      "\r",
      "  function reset() {\r",
      "    events.delete(key)\r",
      "  }\r",
      "\r",
      "  function emit(event?: T, payload?: P) {\r",
      "    events.get(key)?.forEach(v => v(event, payload))\r",
      "  }\r",
      "\r",
      "  return { on, once, off, emit, reset }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useEventBus } from '@vueuse/core'\r",
      "\r",
      "const { on, emit } = useEventBus<string>('vue-use-event-bus')\r",
      "const message = ref('')\r",
      "const news = [\r",
      "  'Su Bingtian broke the Asian record and entered the Olympic 100-meter race finals as the first person in China-RTHK',\r",
      "  'Comprehensive investigation in Zhengzhou to avoid further spread of the epidemic-RTHK',\r",
      "  '130 stroke experts after vaccination: nothing to do with the vaccine',\r",
      "  'China adds two gold medals in Olympic diving and weightlifting',\r",
      "  'Tokyo Olympic service provokes athletes sleeping in cardboard suitcases and eating canned food, reviewing the Beijing Olympics god-level arrangements',\r",
      "]\r",
      "on(_message => message.value = news[Math.floor(Math.random() * news.length)])\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div style=\"display: flex; gap: 100px;\">\r",
      "    <div>\r",
      "      <div class=\"whitespace-nowrap\">\r",
      "        News channel:\r",
      "      </div>\r",
      "      <button class=\"whitespace-nowrap\" @click=\"emit('The Tokyo Olympics has begun')\">\r",
      "        Broadcast\r",
      "      </button>\r",
      "    </div>\r",
      "    <div>\r",
      "      <div style=\"margin-bottom: 13px;\">\r",
      "        Television:\r",
      "      </div>\r",
      "      <div>{{ message || '--- no signal ---' }}</div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useEyeDropper - vueuse": {
    "prefix": "hvue useEyeDropper - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useEyeDropper\r",
      "\r",
      "Reactive [EyeDropper API](https://developer.mozilla.org/en-US/docs/Web/API/EyeDropper_API)\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useEyeDropper } from '@vueuse/core'\r",
      "\r",
      "const { isSupported, open, sRGBHex } = useEyeDropper()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseEyeDropper v-slot=\"{ isSupported, sRGBHex, open }\">\r",
      "  <button :disabled=\"!isSupported\" @click=\"open\">\r",
      "    sRGBHex: {{ sRGBHex }}\r",
      "  </button>\r",
      "</UseEyeDropper>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "export interface EyeDropperOpenOptions {\r",
      "  /**\r",
      "   * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\r",
      "   */\r",
      "  signal?: AbortSignal\r",
      "}\r",
      "\r",
      "export interface EyeDropper {\r",
      "  // eslint-disable-next-line @typescript-eslint/no-misused-new\r",
      "  new(): EyeDropper\r",
      "  open: (options?: EyeDropperOpenOptions) => Promise<{ sRGBHex: string }>\r",
      "  [Symbol.toStringTag]: 'EyeDropper'\r",
      "}\r",
      "\r",
      "export interface UseEyeDropperOptions {\r",
      "  /**\r",
      "   * Initial sRGBHex.\r",
      "   *\r",
      "   * @default ''\r",
      "   */\r",
      "  initialValue?: string\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive [EyeDropper API](https://developer.mozilla.org/en-US/docs/Web/API/EyeDropper_API)\r",
      " *\r",
      " * @see https://vueuse.org/useEyeDropper\r",
      " * @param initialValue string\r",
      " */\r",
      "export function useEyeDropper(options: UseEyeDropperOptions = {}) {\r",
      "  const { initialValue = '' } = options\r",
      "  const isSupported = useSupported(() => typeof window !== 'undefined' && 'EyeDropper' in window)\r",
      "  const sRGBHex = ref(initialValue)\r",
      "\r",
      "  async function open(openOptions?: EyeDropperOpenOptions) {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "    const eyeDropper: EyeDropper = new (window as any).EyeDropper()\r",
      "    const result = await eyeDropper.open(openOptions)\r",
      "    sRGBHex.value = result.sRGBHex\r",
      "    return result\r",
      "  }\r",
      "\r",
      "  return { isSupported, sRGBHex, open }\r",
      "}\r",
      "\r",
      "export type UseEyeDropperReturn = ReturnType<typeof useEyeDropper>\r",
      "```",
      "# Demo",
      "```vue",
      "<script lang=\"ts\" setup>\r",
      "import { useEyeDropper } from '@vueuse/core'\r",
      "\r",
      "const { isSupported, open, sRGBHex } = useEyeDropper()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <template v-if=\"isSupported\">\r",
      "    <div>isSupported: {{ isSupported }}</div>\r",
      "    <div>sRGBHex: <span :style=\"{ color: sRGBHex }\">{{ sRGBHex }}</span></div>\r",
      "    <button\r",
      "      :disabled=\"!isSupported\"\r",
      "      @click=\"() => open()\"\r",
      "    >\r",
      "      Open Eye Dropper\r",
      "    </button>\r",
      "  </template>\r",
      "  <div v-else>\r",
      "    <span>Not Supported by Your Browser</span>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useFavicon - vueuse": {
    "prefix": "hvue useFavicon - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useFavicon\r",
      "\r",
      "Reactive favicon\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js {3}\r",
      "import { useFavicon } from '@vueuse/core'\r",
      "\r",
      "const icon = useFavicon()\r",
      "\r",
      "icon.value = 'dark.png' // change current icon\r",
      "```\r",
      "\r",
      "### Passing a source ref\r",
      "\r",
      "You can pass a `ref` to it, changes from of the source ref will be reflected to your favicon automatically.\r",
      "\r",
      "```js {7}\r",
      "import { computed } from 'vue'\r",
      "import { useFavicon, usePreferredDark } from '@vueuse/core'\r",
      "\r",
      "const isDark = usePreferredDark()\r",
      "const favicon = computed(() => isDark.value ? 'dark.png' : 'light.png')\r",
      "\r",
      "useFavicon(favicon)\r",
      "```\r",
      "\r",
      "When a source ref is passed, the return ref will be identical to the source ref\r",
      "\r",
      "```ts\r",
      "const source = ref('icon.png')\r",
      "const icon = useFavicon(source)\r",
      "\r",
      "console.log(icon === source) // true\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRef, MaybeRefOrGetter, ReadonlyRefOrGetter } from '@vueuse/shared'\r",
      "import { toRef } from '@vueuse/shared'\r",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { watch } from 'vue-demi'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "\r",
      "export interface UseFaviconOptions extends ConfigurableDocument {\r",
      "  baseUrl?: string\r",
      "  rel?: string\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive favicon.\r",
      " *\r",
      " * @see https://vueuse.org/useFavicon\r",
      " * @param newIcon\r",
      " * @param options\r",
      " */\r",
      "export function useFavicon(\r",
      "  newIcon: ReadonlyRefOrGetter<string | null | undefined>,\r",
      "  options?: UseFaviconOptions\r",
      "): ComputedRef<string | null | undefined>\r",
      "export function useFavicon(\r",
      "  newIcon?: MaybeRef<string | null | undefined>,\r",
      "  options?: UseFaviconOptions\r",
      "): Ref<string | null | undefined>\r",
      "export function useFavicon(\r",
      "  newIcon: MaybeRefOrGetter<string | null | undefined> = null,\r",
      "  options: UseFaviconOptions = {},\r",
      ") {\r",
      "  const {\r",
      "    baseUrl = '',\r",
      "    rel = 'icon',\r",
      "    document = defaultDocument,\r",
      "  } = options\r",
      "\r",
      "  const favicon = toRef(newIcon)\r",
      "\r",
      "  const applyIcon = (icon: string) => {\r",
      "    document?.head\r",
      "      .querySelectorAll<HTMLLinkElement>(`link[rel*=\"${rel}\"]`)\r",
      "      .forEach(el => el.href = `${baseUrl}${icon}`)\r",
      "  }\r",
      "\r",
      "  watch(\r",
      "    favicon,\r",
      "    (i, o) => {\r",
      "      if (typeof i === 'string' && i !== o)\r",
      "        applyIcon(i)\r",
      "    },\r",
      "    { immediate: true },\r",
      "  )\r",
      "\r",
      "  return favicon\r",
      "}\r",
      "\r",
      "export type UseFaviconReturn = ReturnType<typeof useFavicon>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, ref } from 'vue'\r",
      "import { useFavicon } from '@vueuse/core'\r",
      "\r",
      "const type = ref('vueuse')\r",
      "\r",
      "const favicon = computed(() =>\r",
      "  type.value === 'vue' ? 'vue.png' : 'favicon-32x32.png',\r",
      ")\r",
      "\r",
      "useFavicon(favicon, {\r",
      "  baseUrl: '/',\r",
      "  rel: 'icon',\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    Change favicon to\r",
      "  </div>\r",
      "  <button @click=\"type = 'vue'\">\r",
      "    Vue\r",
      "  </button>\r",
      "  <button @click=\"type = 'vueuse'\">\r",
      "    VueUse\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useFetch - vueuse": {
    "prefix": "hvue useFetch - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Network\r",
      "---\r",
      "\r",
      "# useFetch\r",
      "\r",
      "Reactive [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) provides the ability to abort requests, intercept requests before\r",
      "they are fired, automatically refetch requests when the url changes, and create your own `useFetch` with predefined options. \r",
      "\r",
      "<CourseLink href=\"https://vueschool.io/lessons/vueuse-utilities-usefetch-and-reactify?friend=vueuse\">Learn useFetch with this FREE video lesson from Vue School!</CourseLink>\r",
      "\r",
      "::: tip\r",
      "When using with Nuxt 3, this functions will **NOT** be auto imported in favor of Nuxt's built-in [`useFetch()`](https://v3.nuxtjs.org/api/composables/use-fetch). Use explicit import if you want to use the function from VueUse.\r",
      ":::\r",
      "\r",
      "## Usage\r",
      "\r",
      "### Basic Usage\r",
      "\r",
      "The `useFetch` function can be used by simply providing a url. The url can be either a string or a `ref`. The `data` object will contain the result of the request, the `error` object will contain any errors, and the `isFetching` object will indicate if the request is loading.\r",
      "\r",
      "```ts\r",
      "import { useFetch } from '@vueuse/core'\r",
      "\r",
      "const { isFetching, error, data } = useFetch(url)\r",
      "```\r",
      "\r",
      "### Asynchronous Usage\r",
      "`useFetch` can also be awaited just like a normal fetch. Note that whenever a component is asynchronous, whatever component that uses\r",
      "it must wrap the component in a `<Suspense>` tag. You can read more about the suspense api in the [Offical Vue 3 Docs](https://vuejs.org/guide/built-ins/suspense.html)\r",
      "\r",
      "```ts\r",
      "import { useFetch } from '@vueuse/core'\r",
      "\r",
      "const { isFetching, error, data } = await useFetch(url)\r",
      "```\r",
      "\r",
      "### Refetching on URL change\r",
      "\r",
      "Using a `ref` for the url parameter will allow the `useFetch` function to automatically trigger another request when the url is changed.\r",
      "\r",
      "```ts\r",
      "const url = ref('https://my-api.com/user/1')\r",
      "\r",
      "const { data } = useFetch(url, { refetch: true })\r",
      "\r",
      "url.value = 'https://my-api.com/user/2' // Will trigger another request\r",
      "```\r",
      "\r",
      "### Prevent request from firing immediately\r",
      "\r",
      "Setting the `immediate` option to false will prevent the request from firing until the `execute` function is called.\r",
      "\r",
      "```ts\r",
      "const { execute } = useFetch(url, { immediate: false })\r",
      "\r",
      "execute()\r",
      "```\r",
      "\r",
      "### Aborting a request\r",
      "\r",
      "A request can be aborted by using the `abort` function from the `useFetch` function. The `canAbort` property indicates if the request can be aborted.\r",
      "\r",
      "```ts\r",
      "const { abort, canAbort } = useFetch(url)\r",
      "\r",
      "setTimeout(() => {\r",
      "  if (canAbort.value)\r",
      "    abort()\r",
      "}, 100)\r",
      "```\r",
      "\r",
      "A request can also be aborted automatically by using `timeout` property. It will call `abort` function when the given timeout is reached.\r",
      "\r",
      "```ts\r",
      "const { data } = useFetch(url, { timeout: 100 })\r",
      "```\r",
      "\r",
      "### Intercepting a request\r",
      "\r",
      "The `beforeFetch` option can intercept a request before it is sent and modify the request options and url.\r",
      "\r",
      "```ts\r",
      "const { data } = useFetch(url, {\r",
      "  async beforeFetch({ url, options, cancel }) {\r",
      "    const myToken = await getMyToken()\r",
      "\r",
      "    if (!myToken)\r",
      "      cancel()\r",
      "\r",
      "    options.headers = {\r",
      "      ...options.headers,\r",
      "      Authorization: `Bearer ${myToken}`,\r",
      "    }\r",
      "\r",
      "    return {\r",
      "      options,\r",
      "    }\r",
      "  },\r",
      "})\r",
      "```\r",
      "\r",
      "The `afterFetch` option can intercept the response data before it is updated.\r",
      "\r",
      "```ts\r",
      "const { data } = useFetch(url, {\r",
      "  afterFetch(ctx) {\r",
      "    if (ctx.data.title === 'HxH')\r",
      "      ctx.data.title = 'Hunter x Hunter' // Modifies the response data\r",
      "\r",
      "    return ctx\r",
      "  },\r",
      "})\r",
      "```\r",
      "\r",
      "The `onFetchError` option can intercept the response data and error before it is updated.\r",
      "```ts\r",
      "const { data } = useFetch(url, {\r",
      "  onFetchError(ctx) {\r",
      "    // ctx.data can be null when 5xx response\r",
      "    if (ctx.data === null)\r",
      "      ctx.data = { title: 'Hunter x Hunter' } // Modifies the response data\r",
      "\r",
      "    ctx.error = new Error('Custom Error') // Modifies the error\r",
      "\r",
      "    return ctx\r",
      "  },\r",
      "})\r",
      "```\r",
      "\r",
      "### Setting the request method and return type\r",
      "\r",
      "The request method and return type can be set by adding the appropriate methods to the end of `useFetch`\r",
      "\r",
      "```ts\r",
      "// Request will be sent with GET method and data will be parsed as JSON\r",
      "const { data } = useFetch(url).get().json()\r",
      "\r",
      "// Request will be sent with POST method and data will be parsed as text\r",
      "const { data } = useFetch(url).post().text()\r",
      "\r",
      "// Or set the method using the options\r",
      "\r",
      "// Request will be sent with GET method and data will be parsed as blob\r",
      "const { data } = useFetch(url, { method: 'GET' }, { refetch: true }).blob()\r",
      "```\r",
      "\r",
      "### Creating a Custom Instance\r",
      "\r",
      "The `createFetch` function will return a useFetch function with whatever pre-configured options that are provided to it. This is useful for interacting with API's throughout an application that uses the same base URL or needs Authorization headers.\r",
      "\r",
      "```ts\r",
      "const useMyFetch = createFetch({\r",
      "  baseUrl: 'https://my-api.com',\r",
      "  options: {\r",
      "    async beforeFetch({ options }) {\r",
      "      const myToken = await getMyToken()\r",
      "      options.headers.Authorization = `Bearer ${myToken}`\r",
      "\r",
      "      return { options }\r",
      "    },\r",
      "  },\r",
      "  fetchOptions: {\r",
      "    mode: 'cors',\r",
      "  },\r",
      "})\r",
      "\r",
      "const { isFetching, error, data } = useMyFetch('users')\r",
      "```\r",
      "\r",
      "If you want to control the behavior of `beforeFetch`, `afterFetch`, `onFetchError` between the pre-configured instance and newly spawned instance. You can provide a `combination` option to toggle between `overwrite` or `chaining`.\r",
      "\r",
      "```ts\r",
      "const useMyFetch = createFetch({\r",
      "  baseUrl: 'https://my-api.com',\r",
      "  combination: 'overwrite',\r",
      "  options: {\r",
      "    // beforeFetch in pre-configured instance will only run when the newly spawned instance do not pass beforeFetch\r",
      "    async beforeFetch({ options }) {\r",
      "      const myToken = await getMyToken()\r",
      "      options.headers.Authorization = `Bearer ${myToken}`\r",
      "\r",
      "      return { options }\r",
      "    },\r",
      "  },\r",
      "})\r",
      "\r",
      "// use useMyFetch beforeFetch\r",
      "const { isFetching, error, data } = useMyFetch('users')\r",
      "\r",
      "// use custom beforeFetch\r",
      "const { isFetching, error, data } = useMyFetch('users', {\r",
      "  async beforeFetch({ url, options, cancel }) {\r",
      "    const myToken = await getMyToken()\r",
      "\r",
      "    if (!myToken)\r",
      "      cancel()\r",
      "\r",
      "    options.headers = {\r",
      "      ...options.headers,\r",
      "      Authorization: `Bearer ${myToken}`,\r",
      "    }\r",
      "\r",
      "    return {\r",
      "      options,\r",
      "    }\r",
      "  },\r",
      "})\r",
      "```\r",
      "\r",
      "### Events\r",
      "\r",
      "The `onFetchResponse` and `onFetchError` will fire on fetch request responses and errors respectively.\r",
      "\r",
      "```ts\r",
      "const { onFetchResponse, onFetchError } = useFetch(url)\r",
      "\r",
      "onFetchResponse((response) => {\r",
      "  console.log(response.status)\r",
      "})\r",
      "\r",
      "onFetchError((error) => {\r",
      "  console.error(error.message)\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { EventHookOn, Fn, MaybeRefOrGetter, Stoppable } from '@vueuse/shared'\r",
      "import { containsProp, createEventHook, toRef, toValue, until, useTimeoutFn } from '@vueuse/shared'\r",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { computed, isRef, ref, shallowRef, watch } from 'vue-demi'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface UseFetchReturn<T> {\r",
      "  /**\r",
      "   * Indicates if the fetch request has finished\r",
      "   */\r",
      "  isFinished: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * The statusCode of the HTTP fetch response\r",
      "   */\r",
      "  statusCode: Ref<number | null>\r",
      "\r",
      "  /**\r",
      "   * The raw response of the fetch response\r",
      "   */\r",
      "  response: Ref<Response | null>\r",
      "\r",
      "  /**\r",
      "   * Any fetch errors that may have occurred\r",
      "   */\r",
      "  error: Ref<any>\r",
      "\r",
      "  /**\r",
      "   * The fetch response body on success, may either be JSON or text\r",
      "   */\r",
      "  data: Ref<T | null>\r",
      "\r",
      "  /**\r",
      "   * Indicates if the request is currently being fetched.\r",
      "   */\r",
      "  isFetching: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * Indicates if the fetch request is able to be aborted\r",
      "   */\r",
      "  canAbort: ComputedRef<boolean>\r",
      "\r",
      "  /**\r",
      "   * Indicates if the fetch request was aborted\r",
      "   */\r",
      "  aborted: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * Abort the fetch request\r",
      "   */\r",
      "  abort: Fn\r",
      "\r",
      "  /**\r",
      "   * Manually call the fetch\r",
      "   * (default not throwing error)\r",
      "   */\r",
      "  execute: (throwOnFailed?: boolean) => Promise<any>\r",
      "\r",
      "  /**\r",
      "   * Fires after the fetch request has finished\r",
      "   */\r",
      "  onFetchResponse: EventHookOn<Response>\r",
      "\r",
      "  /**\r",
      "   * Fires after a fetch request error\r",
      "   */\r",
      "  onFetchError: EventHookOn\r",
      "\r",
      "  /**\r",
      "   * Fires after a fetch has completed\r",
      "   */\r",
      "  onFetchFinally: EventHookOn\r",
      "\r",
      "  // methods\r",
      "  get(): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>>\r",
      "  post(payload?: MaybeRefOrGetter<unknown>, type?: string): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>>\r",
      "  put(payload?: MaybeRefOrGetter<unknown>, type?: string): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>>\r",
      "  delete(payload?: MaybeRefOrGetter<unknown>, type?: string): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>>\r",
      "  patch(payload?: MaybeRefOrGetter<unknown>, type?: string): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>>\r",
      "  head(payload?: MaybeRefOrGetter<unknown>, type?: string): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>>\r",
      "  options(payload?: MaybeRefOrGetter<unknown>, type?: string): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>>\r",
      "\r",
      "  // type\r",
      "  json<JSON = any>(): UseFetchReturn<JSON> & PromiseLike<UseFetchReturn<JSON>>\r",
      "  text(): UseFetchReturn<string> & PromiseLike<UseFetchReturn<string>>\r",
      "  blob(): UseFetchReturn<Blob> & PromiseLike<UseFetchReturn<Blob>>\r",
      "  arrayBuffer(): UseFetchReturn<ArrayBuffer> & PromiseLike<UseFetchReturn<ArrayBuffer>>\r",
      "  formData(): UseFetchReturn<FormData> & PromiseLike<UseFetchReturn<FormData>>\r",
      "}\r",
      "\r",
      "type DataType = 'text' | 'json' | 'blob' | 'arrayBuffer' | 'formData'\r",
      "type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS'\r",
      "type Combination = 'overwrite' | 'chain'\r",
      "\r",
      "const payloadMapping: Record<string, string> = {\r",
      "  json: 'application/json',\r",
      "  text: 'text/plain',\r",
      "}\r",
      "\r",
      "export interface BeforeFetchContext {\r",
      "  /**\r",
      "   * The computed url of the current request\r",
      "   */\r",
      "  url: string\r",
      "\r",
      "  /**\r",
      "   * The request options of the current request\r",
      "   */\r",
      "  options: RequestInit\r",
      "\r",
      "  /**\r",
      "   * Cancels the current request\r",
      "   */\r",
      "  cancel: Fn\r",
      "}\r",
      "\r",
      "export interface AfterFetchContext<T = any> {\r",
      "  response: Response\r",
      "\r",
      "  data: T | null\r",
      "}\r",
      "\r",
      "export interface OnFetchErrorContext<T = any, E = any> {\r",
      "  error: E\r",
      "\r",
      "  data: T | null\r",
      "}\r",
      "\r",
      "export interface UseFetchOptions {\r",
      "  /**\r",
      "   * Fetch function\r",
      "   */\r",
      "  fetch?: typeof window.fetch\r",
      "\r",
      "  /**\r",
      "   * Will automatically run fetch when `useFetch` is used\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "\r",
      "  /**\r",
      "   * Will automatically refetch when:\r",
      "   * - the URL is changed if the URL is a ref\r",
      "   * - the payload is changed if the payload is a ref\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  refetch?: MaybeRefOrGetter<boolean>\r",
      "\r",
      "  /**\r",
      "   * Initial data before the request finished\r",
      "   *\r",
      "   * @default null\r",
      "   */\r",
      "  initialData?: any\r",
      "\r",
      "  /**\r",
      "   * Timeout for abort request after number of millisecond\r",
      "   * `0` means use browser default\r",
      "   *\r",
      "   * @default 0\r",
      "   */\r",
      "  timeout?: number\r",
      "\r",
      "  /**\r",
      "   * Will run immediately before the fetch request is dispatched\r",
      "   */\r",
      "  beforeFetch?: (ctx: BeforeFetchContext) => Promise<Partial<BeforeFetchContext> | void> | Partial<BeforeFetchContext> | void\r",
      "\r",
      "  /**\r",
      "   * Will run immediately after the fetch request is returned.\r",
      "   * Runs after any 2xx response\r",
      "   */\r",
      "  afterFetch?: (ctx: AfterFetchContext) => Promise<Partial<AfterFetchContext>> | Partial<AfterFetchContext>\r",
      "\r",
      "  /**\r",
      "   * Will run immediately after the fetch request is returned.\r",
      "   * Runs after any 4xx and 5xx response\r",
      "   */\r",
      "  onFetchError?: (ctx: { data: any; response: Response | null; error: any }) => Promise<Partial<OnFetchErrorContext>> | Partial<OnFetchErrorContext>\r",
      "}\r",
      "\r",
      "export interface CreateFetchOptions {\r",
      "  /**\r",
      "   * The base URL that will be prefixed to all urls unless urls are absolute\r",
      "   */\r",
      "  baseUrl?: MaybeRefOrGetter<string>\r",
      "\r",
      "  /**\r",
      "   * Determine the inherit behavior for beforeFetch, afterFetch, onFetchError\r",
      "   * @default 'chain'\r",
      "   */\r",
      "  combination?: Combination\r",
      "\r",
      "  /**\r",
      "   * Default Options for the useFetch function\r",
      "   */\r",
      "  options?: UseFetchOptions\r",
      "\r",
      "  /**\r",
      "   * Options for the fetch request\r",
      "   */\r",
      "  fetchOptions?: RequestInit\r",
      "}\r",
      "\r",
      "/**\r",
      " * !!!IMPORTANT!!!\r",
      " *\r",
      " * If you update the UseFetchOptions interface, be sure to update this object\r",
      " * to include the new options\r",
      " */\r",
      "function isFetchOptions(obj: object): obj is UseFetchOptions {\r",
      "  return obj && containsProp(obj, 'immediate', 'refetch', 'initialData', 'timeout', 'beforeFetch', 'afterFetch', 'onFetchError', 'fetch')\r",
      "}\r",
      "\r",
      "// A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\r",
      "function isAbsoluteURL(url: string) {\r",
      "  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url)\r",
      "}\r",
      "\r",
      "function headersToObject(headers: HeadersInit | undefined) {\r",
      "  if (typeof Headers !== 'undefined' && headers instanceof Headers)\r",
      "    return Object.fromEntries([...headers.entries()])\r",
      "  return headers\r",
      "}\r",
      "\r",
      "function combineCallbacks<T = any>(combination: Combination, ...callbacks: (((ctx: T) => void | Partial<T> | Promise<void | Partial<T>>) | undefined)[]) {\r",
      "  if (combination === 'overwrite') {\r",
      "    // use last callback\r",
      "    return async (ctx: T) => {\r",
      "      const callback = callbacks[callbacks.length - 1]\r",
      "      if (callback)\r",
      "        return { ...ctx, ...(await callback(ctx)) }\r",
      "\r",
      "      return ctx\r",
      "    }\r",
      "  }\r",
      "  else {\r",
      "    // chaining and combine result\r",
      "    return async (ctx: T) => {\r",
      "      for (const callback of callbacks) {\r",
      "        if (callback)\r",
      "          ctx = { ...ctx, ...(await callback(ctx)) }\r",
      "      }\r",
      "\r",
      "      return ctx\r",
      "    }\r",
      "  }\r",
      "}\r",
      "\r",
      "export function createFetch(config: CreateFetchOptions = {}) {\r",
      "  const _combination = config.combination || 'chain' as Combination\r",
      "  const _options = config.options || {}\r",
      "  const _fetchOptions = config.fetchOptions || {}\r",
      "\r",
      "  function useFactoryFetch(url: MaybeRefOrGetter<string>, ...args: any[]) {\r",
      "    const computedUrl = computed(() => {\r",
      "      const baseUrl = toValue(config.baseUrl)\r",
      "      const targetUrl = toValue(url)\r",
      "\r",
      "      return (baseUrl && !isAbsoluteURL(targetUrl))\r",
      "        ? joinPaths(baseUrl, targetUrl)\r",
      "        : targetUrl\r",
      "    })\r",
      "\r",
      "    let options = _options\r",
      "    let fetchOptions = _fetchOptions\r",
      "\r",
      "    // Merge properties into a single object\r",
      "    if (args.length > 0) {\r",
      "      if (isFetchOptions(args[0])) {\r",
      "        options = {\r",
      "          ...options,\r",
      "          ...args[0],\r",
      "          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\r",
      "          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\r",
      "          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError),\r",
      "        }\r",
      "      }\r",
      "      else {\r",
      "        fetchOptions = {\r",
      "          ...fetchOptions,\r",
      "          ...args[0],\r",
      "          headers: {\r",
      "            ...(headersToObject(fetchOptions.headers) || {}),\r",
      "            ...(headersToObject(args[0].headers) || {}),\r",
      "          },\r",
      "        }\r",
      "      }\r",
      "    }\r",
      "\r",
      "    if (args.length > 1 && isFetchOptions(args[1])) {\r",
      "      options = {\r",
      "        ...options,\r",
      "        ...args[1],\r",
      "        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\r",
      "        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\r",
      "        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError),\r",
      "      }\r",
      "    }\r",
      "\r",
      "    return useFetch(computedUrl, fetchOptions, options)\r",
      "  }\r",
      "\r",
      "  return useFactoryFetch as typeof useFetch\r",
      "}\r",
      "\r",
      "export function useFetch<T>(url: MaybeRefOrGetter<string>): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>>\r",
      "export function useFetch<T>(url: MaybeRefOrGetter<string>, useFetchOptions: UseFetchOptions): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>>\r",
      "export function useFetch<T>(url: MaybeRefOrGetter<string>, options: RequestInit, useFetchOptions?: UseFetchOptions): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>>\r",
      "\r",
      "export function useFetch<T>(url: MaybeRefOrGetter<string>, ...args: any[]): UseFetchReturn<T> & PromiseLike<UseFetchReturn<T>> {\r",
      "  const supportsAbort = typeof AbortController === 'function'\r",
      "\r",
      "  let fetchOptions: RequestInit = {}\r",
      "  let options: UseFetchOptions = { immediate: true, refetch: false, timeout: 0 }\r",
      "  interface InternalConfig { method: HttpMethod; type: DataType; payload: unknown; payloadType?: string }\r",
      "  const config: InternalConfig = {\r",
      "    method: 'GET',\r",
      "    type: 'text' as DataType,\r",
      "    payload: undefined as unknown,\r",
      "  }\r",
      "\r",
      "  if (args.length > 0) {\r",
      "    if (isFetchOptions(args[0]))\r",
      "      options = { ...options, ...args[0] }\r",
      "    else\r",
      "      fetchOptions = args[0]\r",
      "  }\r",
      "\r",
      "  if (args.length > 1) {\r",
      "    if (isFetchOptions(args[1]))\r",
      "      options = { ...options, ...args[1] }\r",
      "  }\r",
      "\r",
      "  const {\r",
      "    fetch = defaultWindow?.fetch,\r",
      "    initialData,\r",
      "    timeout,\r",
      "  } = options\r",
      "\r",
      "  // Event Hooks\r",
      "  const responseEvent = createEventHook<Response>()\r",
      "  const errorEvent = createEventHook<any>()\r",
      "  const finallyEvent = createEventHook<any>()\r",
      "\r",
      "  const isFinished = ref(false)\r",
      "  const isFetching = ref(false)\r",
      "  const aborted = ref(false)\r",
      "  const statusCode = ref<number | null>(null)\r",
      "  const response = shallowRef<Response | null>(null)\r",
      "  const error = shallowRef<any>(null)\r",
      "  const data = shallowRef<T | null>(initialData || null)\r",
      "\r",
      "  const canAbort = computed(() => supportsAbort && isFetching.value)\r",
      "\r",
      "  let controller: AbortController | undefined\r",
      "  let timer: Stoppable | undefined\r",
      "\r",
      "  const abort = () => {\r",
      "    if (supportsAbort) {\r",
      "      controller?.abort()\r",
      "      controller = new AbortController()\r",
      "      controller.signal.onabort = () => aborted.value = true\r",
      "      fetchOptions = {\r",
      "        ...fetchOptions,\r",
      "        signal: controller.signal,\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const loading = (isLoading: boolean) => {\r",
      "    isFetching.value = isLoading\r",
      "    isFinished.value = !isLoading\r",
      "  }\r",
      "\r",
      "  if (timeout)\r",
      "    timer = useTimeoutFn(abort, timeout, { immediate: false })\r",
      "\r",
      "  const execute = async (throwOnFailed = false) => {\r",
      "    abort()\r",
      "\r",
      "    loading(true)\r",
      "    error.value = null\r",
      "    statusCode.value = null\r",
      "    aborted.value = false\r",
      "\r",
      "    const defaultFetchOptions: RequestInit = {\r",
      "      method: config.method,\r",
      "      headers: {},\r",
      "    }\r",
      "\r",
      "    if (config.payload) {\r",
      "      const headers = headersToObject(defaultFetchOptions.headers) as Record<string, string>\r",
      "      const payload = toValue(config.payload)\r",
      "      // Set the payload to json type only if it's not provided and a literal object is provided and the object is not `formData`\r",
      "      // The only case we can deduce the content type and `fetch` can't\r",
      "      if (!config.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData))\r",
      "        config.payloadType = 'json'\r",
      "\r",
      "      if (config.payloadType)\r",
      "        headers['Content-Type'] = payloadMapping[config.payloadType] ?? config.payloadType\r",
      "\r",
      "      defaultFetchOptions.body = config.payloadType === 'json'\r",
      "        ? JSON.stringify(payload)\r",
      "        : payload as BodyInit\r",
      "    }\r",
      "\r",
      "    let isCanceled = false\r",
      "    const context: BeforeFetchContext = {\r",
      "      url: toValue(url),\r",
      "      options: {\r",
      "        ...defaultFetchOptions,\r",
      "        ...fetchOptions,\r",
      "      },\r",
      "      cancel: () => { isCanceled = true },\r",
      "    }\r",
      "\r",
      "    if (options.beforeFetch)\r",
      "      Object.assign(context, await options.beforeFetch(context))\r",
      "\r",
      "    if (isCanceled || !fetch) {\r",
      "      loading(false)\r",
      "      return Promise.resolve(null)\r",
      "    }\r",
      "\r",
      "    let responseData: any = null\r",
      "\r",
      "    if (timer)\r",
      "      timer.start()\r",
      "\r",
      "    return new Promise<Response | null>((resolve, reject) => {\r",
      "      fetch(\r",
      "        context.url,\r",
      "        {\r",
      "          ...defaultFetchOptions,\r",
      "          ...context.options,\r",
      "          headers: {\r",
      "            ...headersToObject(defaultFetchOptions.headers),\r",
      "            ...headersToObject(context.options?.headers),\r",
      "          },\r",
      "        },\r",
      "      )\r",
      "        .then(async (fetchResponse) => {\r",
      "          response.value = fetchResponse\r",
      "          statusCode.value = fetchResponse.status\r",
      "\r",
      "          responseData = await fetchResponse[config.type]()\r",
      "\r",
      "          // see: https://www.tjvantoll.com/2015/09/13/fetch-and-errors/\r",
      "          if (!fetchResponse.ok) {\r",
      "            data.value = initialData || null\r",
      "            throw new Error(fetchResponse.statusText)\r",
      "          }\r",
      "\r",
      "          if (options.afterFetch)\r",
      "            ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }))\r",
      "          data.value = responseData\r",
      "\r",
      "          responseEvent.trigger(fetchResponse)\r",
      "          return resolve(fetchResponse)\r",
      "        })\r",
      "        .catch(async (fetchError) => {\r",
      "          let errorData = fetchError.message || fetchError.name\r",
      "\r",
      "          if (options.onFetchError)\r",
      "            ({ error: errorData } = await options.onFetchError({ data: responseData, error: fetchError, response: response.value }))\r",
      "          error.value = errorData\r",
      "\r",
      "          errorEvent.trigger(fetchError)\r",
      "          if (throwOnFailed)\r",
      "            return reject(fetchError)\r",
      "\r",
      "          return resolve(null)\r",
      "        })\r",
      "        .finally(() => {\r",
      "          loading(false)\r",
      "          if (timer)\r",
      "            timer.stop()\r",
      "          finallyEvent.trigger(null)\r",
      "        })\r",
      "    })\r",
      "  }\r",
      "\r",
      "  const refetch = toRef(options.refetch)\r",
      "  watch(\r",
      "    [\r",
      "      refetch,\r",
      "      toRef(url),\r",
      "    ],\r",
      "    ([refetch]) => refetch && execute(),\r",
      "    { deep: true },\r",
      "  )\r",
      "\r",
      "  const shell: UseFetchReturn<T> = {\r",
      "    isFinished,\r",
      "    statusCode,\r",
      "    response,\r",
      "    error,\r",
      "    data,\r",
      "    isFetching,\r",
      "    canAbort,\r",
      "    aborted,\r",
      "    abort,\r",
      "    execute,\r",
      "\r",
      "    onFetchResponse: responseEvent.on,\r",
      "    onFetchError: errorEvent.on,\r",
      "    onFetchFinally: finallyEvent.on,\r",
      "    // method\r",
      "    get: setMethod('GET'),\r",
      "    put: setMethod('PUT'),\r",
      "    post: setMethod('POST'),\r",
      "    delete: setMethod('DELETE'),\r",
      "    patch: setMethod('PATCH'),\r",
      "    head: setMethod('HEAD'),\r",
      "    options: setMethod('OPTIONS'),\r",
      "    // type\r",
      "    json: setType('json'),\r",
      "    text: setType('text'),\r",
      "    blob: setType('blob'),\r",
      "    arrayBuffer: setType('arrayBuffer'),\r",
      "    formData: setType('formData'),\r",
      "  }\r",
      "\r",
      "  function setMethod(method: HttpMethod) {\r",
      "    return (payload?: unknown, payloadType?: string) => {\r",
      "      if (!isFetching.value) {\r",
      "        config.method = method\r",
      "        config.payload = payload\r",
      "        config.payloadType = payloadType\r",
      "\r",
      "        // watch for payload changes\r",
      "        if (isRef(config.payload)) {\r",
      "          watch(\r",
      "            [\r",
      "              refetch,\r",
      "              toRef(config.payload),\r",
      "            ],\r",
      "            ([refetch]) => refetch && execute(),\r",
      "            { deep: true },\r",
      "          )\r",
      "        }\r",
      "\r",
      "        return {\r",
      "          ...shell,\r",
      "          then(onFulfilled: any, onRejected: any) {\r",
      "            return waitUntilFinished()\r",
      "              .then(onFulfilled, onRejected)\r",
      "          },\r",
      "        } as any\r",
      "      }\r",
      "      return undefined\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function waitUntilFinished() {\r",
      "    return new Promise<UseFetchReturn<T>>((resolve, reject) => {\r",
      "      until(isFinished).toBe(true)\r",
      "        .then(() => resolve(shell))\r",
      "        .catch(error => reject(error))\r",
      "    })\r",
      "  }\r",
      "\r",
      "  function setType(type: DataType) {\r",
      "    return () => {\r",
      "      if (!isFetching.value) {\r",
      "        config.type = type\r",
      "        return {\r",
      "          ...shell,\r",
      "          then(onFulfilled: any, onRejected: any) {\r",
      "            return waitUntilFinished()\r",
      "              .then(onFulfilled, onRejected)\r",
      "          },\r",
      "        } as any\r",
      "      }\r",
      "      return undefined\r",
      "    }\r",
      "  }\r",
      "\r",
      "  if (options.immediate)\r",
      "    Promise.resolve().then(() => execute())\r",
      "\r",
      "  return {\r",
      "    ...shell,\r",
      "    then(onFulfilled, onRejected) {\r",
      "      return waitUntilFinished()\r",
      "        .then(onFulfilled, onRejected)\r",
      "    },\r",
      "  }\r",
      "}\r",
      "\r",
      "function joinPaths(start: string, end: string): string {\r",
      "  if (!start.endsWith('/') && !end.startsWith('/'))\r",
      "    return `${start}/${end}`\r",
      "\r",
      "  return `${start}${end}`\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, reactive, ref } from 'vue'\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useToggle } from '@vueuse/shared'\r",
      "import { useFetch } from '@vueuse/core'\r",
      "\r",
      "const url = ref('https://httpbin.org/get')\r",
      "const refetch = ref(false)\r",
      "\r",
      "const toggleRefetch = useToggle(refetch)\r",
      "\r",
      "const {\r",
      "  data,\r",
      "  error,\r",
      "  abort,\r",
      "  statusCode,\r",
      "  isFetching,\r",
      "  isFinished,\r",
      "  canAbort,\r",
      "  execute,\r",
      "} = useFetch(url, { refetch }).get()\r",
      "\r",
      "const text = stringify(reactive({\r",
      "  isFinished,\r",
      "  isFetching,\r",
      "  canAbort,\r",
      "  statusCode,\r",
      "  error,\r",
      "  data: computed(() => {\r",
      "    try {\r",
      "      return JSON.parse(data.value as string)\r",
      "    }\r",
      "    catch (e) {\r",
      "      return null\r",
      "    }\r",
      "  }),\r",
      "}))\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div>\r",
      "      <note>The following URLs can be used to test different features of useFetch</note>\r",
      "      <div class=\"mt-2\">\r",
      "        Normal Request:\r",
      "        <code>\r",
      "          https://httpbin.org/get\r",
      "        </code>\r",
      "      </div>\r",
      "      <div>\r",
      "        Abort Request:\r",
      "        <code>\r",
      "          https://httpbin.org/delay/10\r",
      "        </code>\r",
      "      </div>\r",
      "      <div>\r",
      "        Response Error:\r",
      "        <code>\r",
      "          http://httpbin.org/status/500\r",
      "        </code>\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <input v-model=\"url\" type=\"text\">\r",
      "    <button @click=\"execute\">\r",
      "      Execute\r",
      "    </button>\r",
      "    <button @click=\"toggleRefetch\">\r",
      "      <i v-if=\"refetch\" inline-block align-middle i-carbon-checkmark />\r",
      "      <i v-else inline-block align-middle i-carbon-error />\r",
      "\r",
      "      <span class=\"ml-2\">{{ refetch ? 'Refetch On' : 'Refetch Off' }}</span>\r",
      "    </button>\r",
      "    <button v-if=\"canAbort\" class=\"orange\" @click=\"abort\">\r",
      "      Abort\r",
      "    </button>\r",
      "    <pre class=\"code-block\">{{ text }}</pre>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useFileDialog - vueuse": {
    "prefix": "hvue useFileDialog - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useFileDialog\r",
      "\r",
      "Open file dialog with ease.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useFileDialog } from '@vueuse/core'\r",
      "\r",
      "const { files, open, reset, onChange } = useFileDialog()\r",
      "\r",
      "onChange((files) => {\r",
      "  /** do something with files */\r",
      "})\r",
      "```\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <button type=\"button\" @click=\"open\">Choose file</button>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { EventHookOn } from '@vueuse/shared'\r",
      "import { createEventHook, hasOwn } from '@vueuse/shared'\r",
      "import { type Ref, readonly, ref } from 'vue-demi'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "\r",
      "export interface UseFileDialogOptions extends ConfigurableDocument {\r",
      "  /**\r",
      "   * @default true\r",
      "   */\r",
      "  multiple?: boolean\r",
      "  /**\r",
      "   * @default '*'\r",
      "   */\r",
      "  accept?: string\r",
      "  /**\r",
      "   * Select the input source for the capture file.\r",
      "   * @see [HTMLInputElement Capture](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/capture)\r",
      "   */\r",
      "  capture?: string\r",
      "  /**\r",
      "   * Reset when open file dialog.\r",
      "   * @default false\r",
      "   */\r",
      "  reset?: boolean\r",
      "}\r",
      "\r",
      "const DEFAULT_OPTIONS: UseFileDialogOptions = {\r",
      "  multiple: true,\r",
      "  accept: '*',\r",
      "  reset: false,\r",
      "}\r",
      "\r",
      "export interface UseFileDialogReturn {\r",
      "  files: Ref<FileList | null>\r",
      "  open: (localOptions?: Partial<UseFileDialogOptions>) => void\r",
      "  reset: () => void\r",
      "  onChange: EventHookOn<FileList | null>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Open file dialog with ease.\r",
      " *\r",
      " * @see https://vueuse.org/useFileDialog\r",
      " * @param options\r",
      " */\r",
      "export function useFileDialog(options: UseFileDialogOptions = {}): UseFileDialogReturn {\r",
      "  const {\r",
      "    document = defaultDocument,\r",
      "  } = options\r",
      "\r",
      "  const files = ref<FileList | null>(null)\r",
      "  const { on: onChange, trigger } = createEventHook()\r",
      "  let input: HTMLInputElement | undefined\r",
      "  if (document) {\r",
      "    input = document.createElement('input')\r",
      "    input.type = 'file'\r",
      "\r",
      "    input.onchange = (event: Event) => {\r",
      "      const result = event.target as HTMLInputElement\r",
      "      files.value = result.files\r",
      "      trigger(files.value)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const reset = () => {\r",
      "    files.value = null\r",
      "    if (input)\r",
      "      input.value = ''\r",
      "  }\r",
      "\r",
      "  const open = (localOptions?: Partial<UseFileDialogOptions>) => {\r",
      "    if (!input)\r",
      "      return\r",
      "    const _options = {\r",
      "      ...DEFAULT_OPTIONS,\r",
      "      ...options,\r",
      "      ...localOptions,\r",
      "    }\r",
      "    input.multiple = _options.multiple!\r",
      "    input.accept = _options.accept!\r",
      "    if (hasOwn(_options, 'capture'))\r",
      "      input.capture = _options.capture!\r",
      "    if (_options.reset)\r",
      "      reset()\r",
      "    input.click()\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    files: readonly(files),\r",
      "    open,\r",
      "    reset,\r",
      "    onChange,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useFileDialog } from '.'\r",
      "\r",
      "const { files, open, reset, onChange } = useFileDialog()\r",
      "onChange((files) => {\r",
      "  /** do something with files */\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button type=\"button\" @click=\"open()\">\r",
      "    Choose files\r",
      "  </button>\r",
      "  <button type=\"button\" :disabled=\"!files\" @click=\"reset()\">\r",
      "    Reset\r",
      "  </button>\r",
      "  <template v-if=\"files\">\r",
      "    <p>You have selected: <b>{{ `${files.length} ${files.length === 1 ? 'file' : 'files'}` }}</b></p>\r",
      "    <li v-for=\"file of files\" :key=\"file.name\">\r",
      "      {{ file.name }}\r",
      "    </li>\r",
      "  </template>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useFileSystemAccess - vueuse": {
    "prefix": "hvue useFileSystemAccess - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useFileSystemAccess\r",
      "\r",
      "Create and read and write local files with [FileSystemAccessAPI](https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API)\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useFileSystemAccess } from '@vueuse/core'\r",
      "\r",
      "const { isSupported, data, file, fileName, fileMIME, fileSize, fileLastModified, create, open, save, saveAs, updateData } = useFileSystemAccess()\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { computed, ref, watch } from 'vue-demi'\r",
      "import type { Awaitable, MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "/**\r",
      " * window.showOpenFilePicker parameters\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker#parameters\r",
      " */\r",
      "export interface FileSystemAccessShowOpenFileOptions {\r",
      "  multiple?: boolean\r",
      "  types?: Array<{\r",
      "    description?: string\r",
      "    accept: Record<string, string[]>\r",
      "  }>\r",
      "  excludeAcceptAllOption?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * window.showSaveFilePicker parameters\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/window/showSaveFilePicker#parameters\r",
      " */\r",
      "export interface FileSystemAccessShowSaveFileOptions {\r",
      "  suggestedName?: string\r",
      "  types?: Array<{\r",
      "    description?: string\r",
      "    accept: Record<string, string[]>\r",
      "  }>\r",
      "  excludeAcceptAllOption?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * FileHandle\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle\r",
      " */\r",
      "export interface FileSystemFileHandle {\r",
      "  getFile: () => Promise<File>\r",
      "  createWritable: () => FileSystemWritableFileStream\r",
      "}\r",
      "\r",
      "/**\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream\r",
      " */\r",
      "interface FileSystemWritableFileStream extends WritableStream {\r",
      "  /**\r",
      "   * @see https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream/write\r",
      "   */\r",
      "  write: FileSystemWritableFileStreamWrite\r",
      "  /**\r",
      "   * @see https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream/seek\r",
      "   */\r",
      "  seek: (position: number) => Promise<void>\r",
      "  /**\r",
      "   * @see https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream/truncate\r",
      "   */\r",
      "  truncate: (size: number) => Promise<void>\r",
      "}\r",
      "\r",
      "/**\r",
      " * FileStream.write\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream/write\r",
      " */\r",
      "interface FileSystemWritableFileStreamWrite {\r",
      "  (data: string | BufferSource | Blob): Promise<void>\r",
      "  (options: { type: 'write'; position: number; data: string | BufferSource | Blob }): Promise<void>\r",
      "  (options: { type: 'seek'; position: number }): Promise<void>\r",
      "  (options: { type: 'truncate'; size: number }): Promise<void>\r",
      "}\r",
      "\r",
      "/**\r",
      " * FileStream.write\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream/write\r",
      " */\r",
      "export type FileSystemAccessWindow = Window & {\r",
      "  showSaveFilePicker: (options: FileSystemAccessShowSaveFileOptions) => Promise<FileSystemFileHandle>\r",
      "  showOpenFilePicker: (options: FileSystemAccessShowOpenFileOptions) => Promise<FileSystemFileHandle[]>\r",
      "}\r",
      "\r",
      "export type UseFileSystemAccessCommonOptions = Pick<FileSystemAccessShowOpenFileOptions, 'types' | 'excludeAcceptAllOption'>\r",
      "export type UseFileSystemAccessShowSaveFileOptions = Pick<FileSystemAccessShowSaveFileOptions, 'suggestedName'>\r",
      "\r",
      "export type UseFileSystemAccessOptions = ConfigurableWindow & UseFileSystemAccessCommonOptions & {\r",
      "  /**\r",
      "   * file data type\r",
      "   */\r",
      "  dataType?: MaybeRefOrGetter<'Text' | 'ArrayBuffer' | 'Blob'>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Create and read and write local files.\r",
      " * @see https://vueuse.org/useFileSystemAccess\r",
      " * @param options\r",
      " */\r",
      "export function useFileSystemAccess(options: UseFileSystemAccessOptions & { dataType: 'Text' }): UseFileSystemAccessReturn<string>\r",
      "export function useFileSystemAccess(options: UseFileSystemAccessOptions & { dataType: 'ArrayBuffer' }): UseFileSystemAccessReturn<ArrayBuffer>\r",
      "export function useFileSystemAccess(options: UseFileSystemAccessOptions & { dataType: 'Blob' }): UseFileSystemAccessReturn<Blob>\r",
      "export function useFileSystemAccess(options: UseFileSystemAccessOptions): UseFileSystemAccessReturn<string | ArrayBuffer | Blob>\r",
      "export function useFileSystemAccess(options: UseFileSystemAccessOptions = {}): UseFileSystemAccessReturn<string | ArrayBuffer | Blob> {\r",
      "  const {\r",
      "    window: _window = defaultWindow,\r",
      "    dataType = 'Text',\r",
      "  } = options\r",
      "\r",
      "  const window = _window as FileSystemAccessWindow\r",
      "  const isSupported = useSupported(() => window && 'showSaveFilePicker' in window && 'showOpenFilePicker' in window)\r",
      "\r",
      "  const fileHandle = ref<FileSystemFileHandle>()\r",
      "  const data = ref<string | ArrayBuffer | Blob>()\r",
      "\r",
      "  const file = ref<File>()\r",
      "  const fileName = computed(() => file.value?.name ?? '')\r",
      "  const fileMIME = computed(() => file.value?.type ?? '')\r",
      "  const fileSize = computed(() => file.value?.size ?? 0)\r",
      "  const fileLastModified = computed(() => file.value?.lastModified ?? 0)\r",
      "\r",
      "  async function open(_options: UseFileSystemAccessCommonOptions = {}) {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "    const [handle] = await window.showOpenFilePicker({ ...toValue(options), ..._options })\r",
      "    fileHandle.value = handle\r",
      "    await updateFile()\r",
      "    await updateData()\r",
      "  }\r",
      "\r",
      "  async function create(_options: UseFileSystemAccessShowSaveFileOptions = {}) {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "    fileHandle.value = await (window as FileSystemAccessWindow).showSaveFilePicker({ ...options, ..._options })\r",
      "    data.value = undefined\r",
      "    await updateFile()\r",
      "    await updateData()\r",
      "  }\r",
      "\r",
      "  async function save(_options: UseFileSystemAccessShowSaveFileOptions = {}) {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "\r",
      "    if (!fileHandle.value)\r",
      "    // save as\r",
      "      return saveAs(_options)\r",
      "\r",
      "    if (data.value) {\r",
      "      const writableStream = await fileHandle.value.createWritable()\r",
      "      await writableStream.write(data.value)\r",
      "      await writableStream.close()\r",
      "    }\r",
      "    await updateFile()\r",
      "  }\r",
      "\r",
      "  async function saveAs(_options: UseFileSystemAccessShowSaveFileOptions = {}) {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "\r",
      "    fileHandle.value = await (window as FileSystemAccessWindow).showSaveFilePicker({ ...options, ..._options })\r",
      "\r",
      "    if (data.value) {\r",
      "      const writableStream = await fileHandle.value.createWritable()\r",
      "      await writableStream.write(data.value)\r",
      "      await writableStream.close()\r",
      "    }\r",
      "\r",
      "    await updateFile()\r",
      "  }\r",
      "\r",
      "  async function updateFile() {\r",
      "    file.value = await fileHandle.value?.getFile()\r",
      "  }\r",
      "\r",
      "  async function updateData() {\r",
      "    const type = toValue(dataType)\r",
      "    if (type === 'Text')\r",
      "      data.value = await file.value?.text()\r",
      "    else if (type === 'ArrayBuffer')\r",
      "      data.value = await file.value?.arrayBuffer()\r",
      "    else if (type === 'Blob')\r",
      "      data.value = file.value\r",
      "  }\r",
      "\r",
      "  watch(() => toValue(dataType), updateData)\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    data,\r",
      "    file,\r",
      "    fileName,\r",
      "    fileMIME,\r",
      "    fileSize,\r",
      "    fileLastModified,\r",
      "    open,\r",
      "    create,\r",
      "    save,\r",
      "    saveAs,\r",
      "    updateData,\r",
      "  }\r",
      "}\r",
      "\r",
      "export interface UseFileSystemAccessReturn<T = string> {\r",
      "  isSupported: Ref<boolean>\r",
      "  data: Ref<T | undefined>\r",
      "  file: Ref<File | undefined>\r",
      "  fileName: Ref<string>\r",
      "  fileMIME: Ref<string>\r",
      "  fileSize: Ref<number>\r",
      "  fileLastModified: Ref<number>\r",
      "  open: (_options?: UseFileSystemAccessCommonOptions) => Awaitable<void>\r",
      "  create: (_options?: UseFileSystemAccessShowSaveFileOptions) => Awaitable<void>\r",
      "  save: (_options?: UseFileSystemAccessShowSaveFileOptions) => Awaitable<void>\r",
      "  saveAs: (_options?: UseFileSystemAccessShowSaveFileOptions) => Awaitable<void>\r",
      "  updateData: () => Awaitable<void>\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import type { Ref } from 'vue'\r",
      "import { reactive, ref } from 'vue'\r",
      "import { useFileSystemAccess } from '@vueuse/core'\r",
      "\r",
      "const dataType = ref('Text') as Ref<'Text' | 'ArrayBuffer' | 'Blob'>\r",
      "const res = useFileSystemAccess({\r",
      "  dataType,\r",
      "  types: [{\r",
      "    description: 'text',\r",
      "    accept: {\r",
      "      'text/plain': ['.txt', '.html'],\r",
      "    },\r",
      "  }],\r",
      "  excludeAcceptAllOption: true,\r",
      "})\r",
      "\r",
      "const content = res.data\r",
      "const str = stringify(reactive({\r",
      "  isSupported: res.isSupported,\r",
      "  file: res.file,\r",
      "  fileName: res.fileName,\r",
      "  fileMIME: res.fileMIME,\r",
      "  fileSize: res.fileSize,\r",
      "  fileLastModified: res.fileLastModified,\r",
      "}))\r",
      "\r",
      "async function onSave() {\r",
      "  await res.save()\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div flex=\"~ gap-1\" items-center>\r",
      "      <button @click=\"res.open()\">\r",
      "        Open\r",
      "      </button>\r",
      "      <button @click=\"res.create()\">\r",
      "        New file\r",
      "      </button>\r",
      "      <button :disabled=\"!res.file.value\" @click=\"onSave\">\r",
      "        Save\r",
      "      </button>\r",
      "      <button :disabled=\"!res.file.value\" @click=\"res.saveAs()\">\r",
      "        Save as\r",
      "      </button>\r",
      "\r",
      "      <div ml5>\r",
      "        <div text-xs op50>\r",
      "          DataType\r",
      "        </div>\r",
      "        <select v-model=\"dataType\" class=\"outline-none w-30 px2 py1 text-sm\" border=\"~ main rounded\">\r",
      "          <option value=\"Text\">\r",
      "            Text\r",
      "          </option>\r",
      "          <option value=\"ArrayBuffer\">\r",
      "            ArrayBuffer\r",
      "          </option>\r",
      "          <option value=\"Blob\">\r",
      "            Blob\r",
      "          </option>\r",
      "        </select>\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <pre class=\"code-block\" lang=\"yaml\">{{ str }}</pre>\r",
      "\r",
      "    <div v-if=\"content\">\r",
      "      Content\r",
      "      <textarea\r",
      "        v-if=\"typeof content === 'string'\"\r",
      "        v-model=\"content\" rows=\"20\" cols=\"40\" w-full\r",
      "      />\r",
      "      <span v-else>{{ content }}</span>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useFocus - vueuse": {
    "prefix": "hvue useFocus - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useFocus\r",
      "\r",
      "Reactive utility to track or set the focus state of a DOM element. State changes to reflect whether the target element is the focused element. Setting reactive value from the outside will trigger `focus` and `blur` events for `true` and `false` values respectively.\r",
      "\r",
      "## Basic Usage\r",
      "\r",
      "```ts\r",
      "import { useFocus } from '@vueuse/core'\r",
      "\r",
      "const target = ref()\r",
      "const { focused } = useFocus(target)\r",
      "\r",
      "watch(focused, (focused) => {\r",
      "  if (focused)\r",
      "    console.log('input element has been focused')\r",
      "  else console.log('input element has lost focus')\r",
      "})\r",
      "```\r",
      "\r",
      "## Setting initial focus\r",
      "\r",
      "To focus the element on its first render one can provide the `initialValue` option as `true`. This will trigger a `focus` event on the target element.\r",
      "\r",
      "```ts\r",
      "import { useFocus } from '@vueuse/core'\r",
      "\r",
      "const target = ref()\r",
      "const { focused } = useFocus(target, { initialValue: true })\r",
      "```\r",
      "\r",
      "## Change focus state\r",
      "\r",
      "Changes of the `focused` reactive ref will automatically trigger `focus` and `blur` events for `true` and `false` values respectively. You can utilize this behavior to focus the target element as a result of another action (e.g. when a button click as shown below).\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <div>\r",
      "    <button type=\"button\" @click=\"focused = true\">Click me to focus input below</button>\r",
      "    <input ref=\"input\" type=\"text\">\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<script>\r",
      "import { ref } from 'vue'\r",
      "import { useFocus } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const input = ref()\r",
      "    const { focused } = useFocus(input)\r",
      "\r",
      "    return {\r",
      "      input,\r",
      "      focused,\r",
      "    }\r",
      "  }\r",
      "}\r",
      "</script>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { computed, ref, watch } from 'vue-demi'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "\r",
      "export interface UseFocusOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Initial value. If set true, then focus will be set on the target\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  initialValue?: boolean\r",
      "\r",
      "  /**\r",
      "   * Replicate the :focus-visible behavior of CSS\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  focusVisible?: boolean\r",
      "}\r",
      "\r",
      "export interface UseFocusReturn {\r",
      "  /**\r",
      "   * If read as true, then the element has focus. If read as false, then the element does not have focus\r",
      "   * If set to true, then the element will be focused. If set to false, the element will be blurred.\r",
      "   */\r",
      "  focused: Ref<boolean>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Track or set the focus state of a DOM element.\r",
      " *\r",
      " * @see https://vueuse.org/useFocus\r",
      " * @param target The target element for the focus and blur events.\r",
      " * @param options\r",
      " */\r",
      "export function useFocus(target: MaybeElementRef, options: UseFocusOptions = {}): UseFocusReturn {\r",
      "  const { initialValue = false, focusVisible = false } = options\r",
      "\r",
      "  const innerFocused = ref(false)\r",
      "  const targetElement = computed(() => unrefElement(target))\r",
      "\r",
      "  useEventListener(targetElement, 'focus', (event) => {\r",
      "    if (!focusVisible || (event.target as HTMLElement).matches?.(':focus-visible'))\r",
      "      innerFocused.value = true\r",
      "  })\r",
      "  useEventListener(targetElement, 'blur', () => innerFocused.value = false)\r",
      "\r",
      "  const focused = computed({\r",
      "    get: () => innerFocused.value,\r",
      "    set(value: boolean) {\r",
      "      if (!value && innerFocused.value)\r",
      "        targetElement.value?.blur()\r",
      "      else if (value && !innerFocused.value)\r",
      "        targetElement.value?.focus()\r",
      "    },\r",
      "  })\r",
      "\r",
      "  watch(\r",
      "    targetElement,\r",
      "    () => {\r",
      "      focused.value = initialValue\r",
      "    },\r",
      "    { immediate: true, flush: 'post' },\r",
      "  )\r",
      "\r",
      "  return { focused }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">",
      "import { ref } from 'vue'",
      "import { useFocus } from '@vueuse/core'",
      "",
      "const text = ref()",
      "const input = ref()",
      "const button = ref()",
      "",
      "const { focused: paragraphFocus } = useFocus(text)",
      "const { focused: inputFocus } = useFocus(input, { initialValue: true })",
      "const { focused: buttonFocus } = useFocus(button)",
      "</script>",
      "",
      "<template>",
      "  <div>",
      "    <p ref=\"text\" class=\"demo-el px-2 rounded\" tabindex=\"0\">",
      "      Paragraph that can be focused",
      "    </p>",
      "    <input ref=\"input\" class=\"demo-el\" type=\"text\" placeholder=\"Input that can be focused\">",
      "    <button ref=\"button\" class=\"demo-el button\">",
      "      Button that can be focused",
      "    </button>",
      "    <hr>",
      "    <note class=\"mb-2\">",
      "      <template v-if=\"paragraphFocus\">",
      "        The paragraph has focus",
      "      </template>",
      "      <template v-else-if=\"inputFocus\">",
      "        The input control has focus",
      "      </template>",
      "      <template v-else-if=\"buttonFocus\">",
      "        The button has focus",
      "      </template>",
      "      <template v-else>",
      "        &nbsp;<!-- prevents paragraph from collapsing when empty otherwise -->",
      "      </template>",
      "    </note>",
      "    <button class=\"button small !ml-0\" :class=\"{ orange: paragraphFocus }\" @click=\"paragraphFocus = !paragraphFocus\">",
      "      Focus text",
      "    </button>",
      "    <button class=\"button small\" :class=\"{ orange: inputFocus }\" @click=\"inputFocus = !inputFocus\">",
      "      Focus input",
      "    </button>",
      "    <button class=\"button small\" :class=\"{ orange: buttonFocus }\" @click=\"buttonFocus = !buttonFocus\">",
      "      Focus button",
      "    </button>",
      "  </div>",
      "</template>",
      "",
      "<style scoped>",
      ".demo-el:focus {",
      "  opacity: .7;",
      "  box-shadow: 0 0 2px 1px var(--vp-c-brand);\r",
      "}",
      "</style>",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useFocusWithin - vueuse": {
    "prefix": "hvue useFocusWithin - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useFocusWithin\r",
      "\r",
      "Reactive utility to track if an element or one of its decendants has focus. It is meant to match the behavior of the `:focus-within` CSS pseudo-class. A common use case would be on a form element to see if any of its inputs currently have focus.\r",
      "\r",
      "## Basic Usage\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <form ref=\"target\">\r",
      "    <input type=\"text\" placeholder=\"First Name\">\r",
      "    <input type=\"text\" placeholder=\"Last Name\">\r",
      "    <input type=\"text\" placeholder=\"Email\">\r",
      "    <input type=\"text\" placeholder=\"Password\">\r",
      "  </form>\r",
      "</template>\r",
      "\r",
      "<script>\r",
      "import { useFocusWithin } from '@vueuse/core'\r",
      "\r",
      "const target = ref();\r",
      "const { focused } = useFocusWithin(target)\r",
      "\r",
      "watch(focused, focused => {\r",
      "  if (focused) console.log('Target contains the focused element')\r",
      "  else console.log('Target does NOT contain the focused element')\r",
      "})\r",
      "</script>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef } from 'vue-demi'\r",
      "import { computed } from 'vue-demi'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { useActiveElement } from '../useActiveElement'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "\r",
      "export interface UseFocusWithinReturn {\r",
      "  /**\r",
      "   * True if the element or any of its descendants are focused\r",
      "   */\r",
      "  focused: ComputedRef<boolean>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Track if focus is contained within the target element\r",
      " *\r",
      " * @see https://vueuse.org/useFocusWithin\r",
      " * @param target The target element to track\r",
      " * @param options Focus within options\r",
      " */\r",
      "export function useFocusWithin(target: MaybeElementRef, options: ConfigurableWindow = {}): UseFocusWithinReturn {\r",
      "  const activeElement = useActiveElement(options)\r",
      "  const targetElement = computed(() => unrefElement(target))\r",
      "  const focused = computed(() => (targetElement.value && activeElement.value) ? targetElement.value.contains(activeElement.value) : false)\r",
      "\r",
      "  return { focused }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useFocusWithin } from '@vueuse/core'\r",
      "\r",
      "const target = ref()\r",
      "\r",
      "const { focused } = useFocusWithin(target)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"flex flex-col items-center\">\r",
      "    <form\r",
      "      ref=\"target\"\r",
      "      class=\"shadow bg-base border-main rounded max-w-96 mx-auto p-8\"\r",
      "    >\r",
      "      <input type=\"text\" placeholder=\"First Name\">\r",
      "      <input type=\"text\" placeholder=\"Last Name\">\r",
      "      <input type=\"text\" placeholder=\"Email\">\r",
      "      <input type=\"text\" placeholder=\"Password\">\r",
      "    </form>\r",
      "    <div mt2>\r",
      "      Focus in form: <BooleanDisplay :value=\"focused\" />\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useFps - vueuse": {
    "prefix": "hvue useFps - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useFps\r",
      "\r",
      "Reactive FPS (frames per second).\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useFps } from '@vueuse/core'\r",
      "\r",
      "const fps = useFps()\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { useRafFn } from '../useRafFn'\r",
      "\r",
      "export interface UseFpsOptions {\r",
      "  /**\r",
      "   * Calculate the FPS on every x frames.\r",
      "   * @default 10\r",
      "   */\r",
      "  every?: number\r",
      "}\r",
      "\r",
      "export function useFps(options?: UseFpsOptions): Ref<number> {\r",
      "  const fps = ref(0)\r",
      "  if (typeof performance === 'undefined')\r",
      "    return fps\r",
      "  const every = options?.every ?? 10\r",
      "\r",
      "  let last = performance.now()\r",
      "  let ticks = 0\r",
      "\r",
      "  useRafFn(() => {\r",
      "    ticks += 1\r",
      "    if (ticks >= every) {\r",
      "      const now = performance.now()\r",
      "      const diff = now - last\r",
      "      fps.value = Math.round(1000 / (diff / ticks))\r",
      "      last = now\r",
      "      ticks = 0\r",
      "    }\r",
      "  })\r",
      "\r",
      "  return fps\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useFps } from '@vueuse/core'\r",
      "\r",
      "const fps = useFps()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  FPS: {{ fps }}\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useFullscreen - vueuse": {
    "prefix": "hvue useFullscreen - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useFullscreen\r",
      "\r",
      "Reactive [Fullscreen API](https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API). It adds methods to present a specific Element (and its descendants) in full-screen mode, and to exit full-screen mode once it is no longer needed. This makes it possible to present desired content‚Äîsuch as an online game‚Äîusing the user's entire screen, removing all browser user interface elements and other applications from the screen until full-screen mode is shut off.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useFullscreen } from '@vueuse/core'\r",
      "\r",
      "const { isFullscreen, enter, exit, toggle } = useFullscreen()\r",
      "```\r",
      "\r",
      "Fullscreen specified element. Some platforms (like iOS's Safari) only allow fullscreen on video elements.\r",
      "\r",
      "```ts\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "\r",
      "const { isFullscreen, enter, exit, toggle } = useFullscreen(el)\r",
      "```\r",
      "\r",
      "```html\r",
      "<video ref='el'>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseFullscreen v-slot=\"{ toggle }\">\r",
      "  <video />\r",
      "  <button @click=\"toggle\">\r",
      "    Go Fullscreen\r",
      "  </button>\r",
      "</UseFullscreen>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed, ref } from 'vue-demi'\r",
      "import { tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "export interface UseFullscreenOptions extends ConfigurableDocument {\r",
      "  /**\r",
      "   * Automatically exit fullscreen when component is unmounted\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  autoExit?: boolean\r",
      "}\r",
      "\r",
      "const eventHandlers = [\r",
      "  'fullscreenchange',\r",
      "  'webkitfullscreenchange',\r",
      "  'webkitendfullscreen',\r",
      "  'mozfullscreenchange',\r",
      "  'MSFullscreenChange',\r",
      "] as any as 'fullscreenchange'[]\r",
      "\r",
      "/**\r",
      " * Reactive Fullscreen API.\r",
      " *\r",
      " * @see https://vueuse.org/useFullscreen\r",
      " * @param target\r",
      " * @param options\r",
      " */\r",
      "export function useFullscreen(\r",
      "  target?: MaybeElementRef,\r",
      "  options: UseFullscreenOptions = {},\r",
      ") {\r",
      "  const {\r",
      "    document = defaultDocument,\r",
      "    autoExit = false,\r",
      "  } = options\r",
      "\r",
      "  const targetRef = computed(() => unrefElement(target) ?? document?.querySelector('html'))\r",
      "  const isFullscreen = ref(false)\r",
      "\r",
      "  const requestMethod = computed<'requestFullscreen' | undefined>(() => {\r",
      "    return [\r",
      "      'requestFullscreen',\r",
      "      'webkitRequestFullscreen',\r",
      "      'webkitEnterFullscreen',\r",
      "      'webkitEnterFullScreen',\r",
      "      'webkitRequestFullScreen',\r",
      "      'mozRequestFullScreen',\r",
      "      'msRequestFullscreen',\r",
      "    ].find(m => (document && m in document) || (targetRef.value && m in targetRef.value)) as any\r",
      "  })\r",
      "\r",
      "  const exitMethod = computed<'exitFullscreen' | undefined>(() => {\r",
      "    return [\r",
      "      'exitFullscreen',\r",
      "      'webkitExitFullscreen',\r",
      "      'webkitExitFullScreen',\r",
      "      'webkitCancelFullScreen',\r",
      "      'mozCancelFullScreen',\r",
      "      'msExitFullscreen',\r",
      "    ].find(m => (document && m in document) || (targetRef.value && m in targetRef.value)) as any\r",
      "  })\r",
      "\r",
      "  const fullscreenEnabled = computed<'fullscreenEnabled' | undefined>(() => {\r",
      "    return [\r",
      "      'fullScreen',\r",
      "      'webkitIsFullScreen',\r",
      "      'webkitDisplayingFullscreen',\r",
      "      'mozFullScreen',\r",
      "      'msFullscreenElement',\r",
      "    ].find(m => (document && m in document) || (targetRef.value && m in targetRef.value)) as any\r",
      "  })\r",
      "\r",
      "  const fullscreenElementMethod = [\r",
      "    'fullscreenElement',\r",
      "    'webkitFullscreenElement',\r",
      "    'mozFullScreenElement',\r",
      "    'msFullscreenElement',\r",
      "  ].find(m => (document && m in document)) as 'fullscreenElement' | undefined\r",
      "\r",
      "  const isSupported = useSupported(() =>\r",
      "    targetRef.value\r",
      "    && document\r",
      "    && requestMethod.value !== undefined\r",
      "    && exitMethod.value !== undefined\r",
      "    && fullscreenEnabled.value !== undefined,\r",
      "  )\r",
      "\r",
      "  const isCurrentElementFullScreen = (): boolean => {\r",
      "    if (fullscreenElementMethod)\r",
      "      return document?.[fullscreenElementMethod] === targetRef.value\r",
      "    return false\r",
      "  }\r",
      "\r",
      "  const isElementFullScreen = (): boolean => {\r",
      "    if (fullscreenEnabled.value) {\r",
      "      if (document && document[fullscreenEnabled.value] != null) {\r",
      "        return document[fullscreenEnabled.value]\r",
      "      }\r",
      "      else {\r",
      "        const target = targetRef.value\r",
      "        // @ts-expect-error - Fallback for WebKit and iOS Safari browsers\r",
      "        if (target?.[fullscreenEnabled.value] != null) {\r",
      "          // @ts-expect-error - Fallback for WebKit and iOS Safari browsers\r",
      "          return Boolean(target[fullscreenEnabled.value])\r",
      "        }\r",
      "      }\r",
      "    }\r",
      "    return false\r",
      "  }\r",
      "\r",
      "  async function exit() {\r",
      "    if (!isSupported.value || !isFullscreen.value)\r",
      "      return\r",
      "    if (exitMethod.value) {\r",
      "      if (document?.[exitMethod.value] != null) {\r",
      "        await document[exitMethod.value]()\r",
      "      }\r",
      "      else {\r",
      "        const target = targetRef.value\r",
      "        // @ts-expect-error - Fallback for Safari iOS\r",
      "        if (target?.[exitMethod.value] != null)\r",
      "          // @ts-expect-error - Fallback for Safari iOS\r",
      "          await target[exitMethod.value]()\r",
      "      }\r",
      "    }\r",
      "\r",
      "    isFullscreen.value = false\r",
      "  }\r",
      "\r",
      "  async function enter() {\r",
      "    if (!isSupported.value || isFullscreen.value)\r",
      "      return\r",
      "\r",
      "    if (isElementFullScreen())\r",
      "      await exit()\r",
      "\r",
      "    const target = targetRef.value\r",
      "    if (requestMethod.value && target?.[requestMethod.value] != null) {\r",
      "      await target[requestMethod.value]()\r",
      "      isFullscreen.value = true\r",
      "    }\r",
      "  }\r",
      "\r",
      "  async function toggle() {\r",
      "    await (isFullscreen.value ? exit() : enter())\r",
      "  }\r",
      "\r",
      "  const handlerCallback = () => {\r",
      "    const isElementFullScreenValue = isElementFullScreen()\r",
      "    if (!isElementFullScreenValue || (isElementFullScreenValue && isCurrentElementFullScreen()))\r",
      "      isFullscreen.value = isElementFullScreenValue\r",
      "  }\r",
      "\r",
      "  useEventListener(document, eventHandlers, handlerCallback, false)\r",
      "  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false)\r",
      "\r",
      "  if (autoExit)\r",
      "    tryOnScopeDispose(exit)\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    isFullscreen,\r",
      "    enter,\r",
      "    exit,\r",
      "    toggle,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseFullscreenReturn = ReturnType<typeof useFullscreen>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useFullscreen } from '@vueuse/core'\r",
      "\r",
      "const el = ref(null)\r",
      "const { toggle } = useFullscreen(el)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"text-center\">\r",
      "    <div class=\"flex\" p=\"y-4\">\r",
      "      <video\r",
      "        ref=\"el\"\r",
      "        class=\"m-auto rounded\"\r",
      "        src=\"https://vjs.zencdn.net/v/oceans.mp4\"\r",
      "        width=\"600\"\r",
      "        controls\r",
      "      />\r",
      "    </div>\r",
      "    <button @click=\"toggle\">\r",
      "      Go Fullscreen\r",
      "    </button>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useGamepad - vueuse": {
    "prefix": "hvue useGamepad - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useGamepad\r",
      "\r",
      "Provides reactive bindings for the [Gamepad API](https://developer.mozilla.org/en-US/docs/Web/API/Gamepad_API).\r",
      "\r",
      "## Usage\r",
      "\r",
      "> Due to how the Gamepad API works, you must interact with the page using the gamepad before it will be detected.\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { computed } from 'vue'\r",
      "import { useGamepad } from '@vueuse/core'\r",
      "\r",
      "const { isSupported, gamepads } = useGamepad()\r",
      "const gamepad = computed(() => gamepads.find(g => g.mapping === 'standard'))\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <span>\r",
      "    {{ gamepad.id }}\r",
      "  <span>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Gamepad Updates\r",
      "\r",
      "Currently the Gamepad API does not have event support to update the state of the gamepad. To update the gamepad state, `requestAnimationFrame` is used to poll for gamepad changes. You can control this polling by using the `pause` and `resume` functions provided by `useGamepad`\r",
      "\r",
      "```ts\r",
      "import { useGamepad } from '@vueuse/core'\r",
      "\r",
      "const { pause, resume, gamepads } = useGamepad()\r",
      "\r",
      "pause()\r",
      "\r",
      "// gamepads object will not update\r",
      "\r",
      "resume()\r",
      "\r",
      "// gamepads object will update on user input\r",
      "```\r",
      "\r",
      "### Gamepad Connect & Disconnect Events\r",
      "\r",
      "The `onConnected` and `onDisconnected` events will trigger when a gamepad is connected or disconnected.\r",
      "\r",
      "```ts\r",
      "const { gamepads, onConnected, onDisconnected } = useGamepad()\r",
      "\r",
      "onConnected((index) => {\r",
      "  console.log(`${gamepads.value[index].id} connected`)\r",
      "})\r",
      "\r",
      "onDisconnected((index) => {\r",
      "  console.log(`${index} disconnected`)\r",
      "})\r",
      "```\r",
      "\r",
      "### Vibration\r",
      "\r",
      "> The Gamepad Haptics API is sparse, so check the [compatibility table](https://developer.mozilla.org/en-US/docs/Web/API/GamepadHapticActuator#browser_compatibility) before using.\r",
      "\r",
      "```ts\r",
      "import { computed } from 'vue'\r",
      "\r",
      "const supportsVibration = computed(() => gamepad.hapticActuators.length > 0)\r",
      "function vibrate() {\r",
      "  if (supportsVibration.value) {\r",
      "    const actuator = gamepad.hapticActuators[0]\r",
      "    actuator.playEffect('dual-rumble', {\r",
      "      startDelay: 0,\r",
      "      duration: 1000,\r",
      "      weakMagnitude: 1,\r",
      "      strongMagnitude: 1,\r",
      "    })\r",
      "  }\r",
      "}\r",
      "```\r",
      "\r",
      "### Mappings\r",
      "\r",
      "To make the Gamepad API easier to use, we provide mappings to map a controller to a controllers button layout.\r",
      "\r",
      "#### Xbox360 Controller\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { mapGamepadToXbox360Controller } from '@vueuse/core'\r",
      "\r",
      "const controller = mapGamepadToXbox360Controller(gamepad)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <span>{{ controller.buttons.a.pressed }}</span>\r",
      "  <span>{{ controller.buttons.b.pressed }}</span>\r",
      "  <span>{{ controller.buttons.x.pressed }}</span>\r",
      "  <span>{{ controller.buttons.y.pressed }}</span>\r",
      "</template>\r",
      "```\r",
      "\r",
      "Currently there are only mappings for the Xbox 360 controller. If you have controller you want to add mappings for, feel free to open a PR for more controller mappings!\r",
      "# Source TS",
      "```js",
      "import { createEventHook, tryOnMounted } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { computed, ref } from 'vue-demi'\r",
      "import { useRafFn } from '../useRafFn'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableNavigator, ConfigurableWindow } from '../_configurable'\r",
      "import { defaultNavigator } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "export interface UseGamepadOptions extends ConfigurableWindow, ConfigurableNavigator {\r",
      "\r",
      "}\r",
      "\r",
      "/**\r",
      " * Maps a standard standard gamepad to an Xbox 360 Controller.\r",
      " */\r",
      "export function mapGamepadToXbox360Controller(gamepad: Ref<Gamepad | undefined>) {\r",
      "  return computed(() => {\r",
      "    if (gamepad.value) {\r",
      "      return {\r",
      "        buttons: {\r",
      "          a: gamepad.value.buttons[0],\r",
      "          b: gamepad.value.buttons[1],\r",
      "          x: gamepad.value.buttons[2],\r",
      "          y: gamepad.value.buttons[3],\r",
      "        },\r",
      "        bumper: {\r",
      "          left: gamepad.value.buttons[4],\r",
      "          right: gamepad.value.buttons[5],\r",
      "        },\r",
      "        triggers: {\r",
      "          left: gamepad.value.buttons[6],\r",
      "          right: gamepad.value.buttons[7],\r",
      "        },\r",
      "        stick: {\r",
      "          left: {\r",
      "            horizontal: gamepad.value.axes[0],\r",
      "            vertical: gamepad.value.axes[1],\r",
      "            button: gamepad.value.buttons[10],\r",
      "          },\r",
      "          right: {\r",
      "            horizontal: gamepad.value.axes[2],\r",
      "            vertical: gamepad.value.axes[3],\r",
      "            button: gamepad.value.buttons[11],\r",
      "          },\r",
      "        },\r",
      "        dpad: {\r",
      "          up: gamepad.value.buttons[12],\r",
      "          down: gamepad.value.buttons[13],\r",
      "          left: gamepad.value.buttons[14],\r",
      "          right: gamepad.value.buttons[15],\r",
      "        },\r",
      "        back: gamepad.value.buttons[8],\r",
      "        start: gamepad.value.buttons[9],\r",
      "      }\r",
      "    }\r",
      "\r",
      "    return null\r",
      "  })\r",
      "}\r",
      "\r",
      "export function useGamepad(options: UseGamepadOptions = {}) {\r",
      "  const {\r",
      "    navigator = defaultNavigator,\r",
      "  } = options\r",
      "  const isSupported = useSupported(() => navigator && 'getGamepads' in navigator)\r",
      "  const gamepads = ref<Gamepad[]>([])\r",
      "\r",
      "  const onConnectedHook = createEventHook<number>()\r",
      "  const onDisconnectedHook = createEventHook<number>()\r",
      "\r",
      "  const stateFromGamepad = (gamepad: Gamepad) => {\r",
      "    const hapticActuators = []\r",
      "    const vibrationActuator = 'vibrationActuator' in gamepad ? (gamepad as any).vibrationActuator : null\r",
      "\r",
      "    if (vibrationActuator)\r",
      "      hapticActuators.push(vibrationActuator)\r",
      "\r",
      "    if (gamepad.hapticActuators)\r",
      "      hapticActuators.push(...gamepad.hapticActuators)\r",
      "\r",
      "    return {\r",
      "      ...gamepad,\r",
      "      id: gamepad.id,\r",
      "      hapticActuators,\r",
      "      axes: gamepad.axes.map(axes => axes),\r",
      "      buttons: gamepad.buttons.map(button => ({ pressed: button.pressed, touched: button.touched, value: button.value })),\r",
      "    } as Gamepad\r",
      "  }\r",
      "\r",
      "  const updateGamepadState = () => {\r",
      "    const _gamepads = navigator?.getGamepads() || []\r",
      "\r",
      "    for (let i = 0; i < _gamepads.length; ++i) {\r",
      "      const gamepad = _gamepads[i]\r",
      "      if (gamepad) {\r",
      "        const index = gamepads.value.findIndex(({ index }) => index === gamepad.index)\r",
      "\r",
      "        if (index > -1)\r",
      "          gamepads.value[index] = stateFromGamepad(gamepad)\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const { isActive, pause, resume } = useRafFn(updateGamepadState)\r",
      "\r",
      "  const onGamepadConnected = (gamepad: Gamepad) => {\r",
      "    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\r",
      "      gamepads.value.push(stateFromGamepad(gamepad))\r",
      "      onConnectedHook.trigger(gamepad.index)\r",
      "    }\r",
      "\r",
      "    resume()\r",
      "  }\r",
      "\r",
      "  const onGamepadDisconnected = (gamepad: Gamepad) => {\r",
      "    gamepads.value = gamepads.value.filter(x => x.index !== gamepad.index)\r",
      "    onDisconnectedHook.trigger(gamepad.index)\r",
      "  }\r",
      "\r",
      "  useEventListener('gamepadconnected', e => onGamepadConnected(e.gamepad))\r",
      "  useEventListener('gamepaddisconnected', e => onGamepadDisconnected(e.gamepad))\r",
      "\r",
      "  tryOnMounted(() => {\r",
      "    const _gamepads = navigator?.getGamepads() || []\r",
      "\r",
      "    if (_gamepads) {\r",
      "      for (let i = 0; i < _gamepads.length; ++i) {\r",
      "        const gamepad = _gamepads[i]\r",
      "\r",
      "        if (gamepad)\r",
      "          onGamepadConnected(gamepad)\r",
      "      }\r",
      "    }\r",
      "  })\r",
      "\r",
      "  pause()\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    onConnected: onConnectedHook.on,\r",
      "    onDisconnected: onDisconnectedHook.on,\r",
      "    gamepads,\r",
      "    pause,\r",
      "    resume,\r",
      "    isActive,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseGamepadReturn = ReturnType<typeof useGamepad>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useGamepad } from '@vueuse/core'\r",
      "import Gamepad from './components/Gamepad.vue'\r",
      "\r",
      "const { isSupported, gamepads } = useGamepad()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div v-if=\"!isSupported\" flex=\"~ row\" place=\"items-center content-center\" items=\"center\" space=\"x-4\">\r",
      "      <i i-carbon-error text=\"5xl\" opacity=\"50\" />\r",
      "      <div flex=\"~ col\">\r",
      "        <span text=\"2xl\">Gamepad is not supported on this device.</span>\r",
      "        <span opacity=\"70\">It seems your device does not support the Gamepad API. Check <a href=\"https://caniuse.com/gamepad\">here</a> for a list supported devices.</span>\r",
      "      </div>\r",
      "    </div>\r",
      "    <div v-else-if=\"gamepads.length === 0\" flex=\"~ row\" place=\"items-center content-center\" items=\"center\" space=\"x-4\">\r",
      "      <i i-carbon-game-console text=\"5xl\" opacity=\"50\" />\r",
      "      <div flex=\"~ col\">\r",
      "        <span text=\"2xl\">No Gamepad Detected</span>\r",
      "        <span opacity=\"50\">Ensure your gamepad is connected and press a button to wake it up.</span>\r",
      "      </div>\r",
      "    </div>\r",
      "    <div v-else space=\"y-4\">\r",
      "      <Gamepad v-for=\"gamepad in gamepads\" :key=\"gamepad.id\" :gamepad=\"gamepad\" />\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useGeolocation - vueuse": {
    "prefix": "hvue useGeolocation - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useGeolocation\r",
      "\r",
      "Reactive [Geolocation API](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API). It allows the user to provide their location to web applications if they so desire. For privacy reasons, the user is asked for permission to report location information.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useGeolocation } from '@vueuse/core'\r",
      "\r",
      "const { coords, locatedAt, error, resume, pause } = useGeolocation()\r",
      "```\r",
      "\r",
      "| State     | Type                                                                          | Description                                                              |\r",
      "| --------- | ----------------------------------------------------------------------------- | ------------------------------------------------------------------------ |\r",
      "| coords    | [`Coordinates`](https://developer.mozilla.org/en-US/docs/Web/API/Coordinates) | information about the position retrieved like the latitude and longitude |\r",
      "| locatedAt | `Date`                                                                        | The time of the last geolocation call                                    |\r",
      "| error     | `string`                                                                      | An error message in case geolocation API fails.                          |\r",
      "| resume     | `function`                                                                      | Control function to resume updating geolocation |\r",
      "| pause      | `function`                                                                        | Control function to pause updating geolocation |\r",
      "\r",
      "## Config\r",
      "\r",
      "`useGeolocation` function takes [PositionOptions](https://developer.mozilla.org/en-US/docs/Web/API/PositionOptions) object as an optional parameter.\r",
      "\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseGeolocation v-slot=\"{ coords: { latitude, longitude } }\">\r",
      "  Latitude: {{ latitude }}\r",
      "  Longitude: {{ longitude }}\r",
      "</UseGeolocation>\r",
      "```\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */\r",
      "\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref, shallowRef } from 'vue-demi'\r",
      "import { tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { ConfigurableNavigator } from '../_configurable'\r",
      "import { defaultNavigator } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "export interface UseGeolocationOptions extends Partial<PositionOptions>, ConfigurableNavigator {\r",
      "  immediate?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive Geolocation API.\r",
      " *\r",
      " * @see https://vueuse.org/useGeolocation\r",
      " * @param options\r",
      " */\r",
      "export function useGeolocation(options: UseGeolocationOptions = {}) {\r",
      "  const {\r",
      "    enableHighAccuracy = true,\r",
      "    maximumAge = 30000,\r",
      "    timeout = 27000,\r",
      "    navigator = defaultNavigator,\r",
      "    immediate = true,\r",
      "  } = options\r",
      "\r",
      "  const isSupported = useSupported(() => navigator && 'geolocation' in navigator)\r",
      "\r",
      "  const locatedAt: Ref<number | null> = ref(null)\r",
      "  const error = shallowRef<GeolocationPositionError | null>(null)\r",
      "  const coords: Ref<GeolocationPosition['coords']> = ref({\r",
      "    accuracy: 0,\r",
      "    latitude: Number.POSITIVE_INFINITY,\r",
      "    longitude: Number.POSITIVE_INFINITY,\r",
      "    altitude: null,\r",
      "    altitudeAccuracy: null,\r",
      "    heading: null,\r",
      "    speed: null,\r",
      "  })\r",
      "\r",
      "  function updatePosition(position: GeolocationPosition) {\r",
      "    locatedAt.value = position.timestamp\r",
      "    coords.value = position.coords\r",
      "    error.value = null\r",
      "  }\r",
      "\r",
      "  let watcher: number\r",
      "\r",
      "  function resume() {\r",
      "    if (isSupported.value) {\r",
      "      watcher = navigator!.geolocation.watchPosition(\r",
      "        updatePosition,\r",
      "        err => error.value = err,\r",
      "        {\r",
      "          enableHighAccuracy,\r",
      "          maximumAge,\r",
      "          timeout,\r",
      "        },\r",
      "      )\r",
      "    }\r",
      "  }\r",
      "\r",
      "  if (immediate)\r",
      "    resume()\r",
      "\r",
      "  function pause() {\r",
      "    if (watcher && navigator)\r",
      "      navigator.geolocation.clearWatch(watcher)\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(() => {\r",
      "    pause()\r",
      "  })\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    coords,\r",
      "    locatedAt,\r",
      "    error,\r",
      "    resume,\r",
      "    pause,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseGeolocationReturn = ReturnType<typeof useGeolocation>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useGeolocation } from '@vueuse/core'\r",
      "\r",
      "const { coords, locatedAt, error, resume, pause } = useGeolocation()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <pre lang=\"json\">{{\r",
      "    JSON.stringify(\r",
      "      {\r",
      "        coords: {\r",
      "          accuracy: coords.accuracy,\r",
      "          latitude: coords.latitude,\r",
      "          longitude: coords.longitude,\r",
      "          altitude: coords.altitude,\r",
      "          altitudeAccuracy: coords.altitudeAccuracy,\r",
      "          heading: coords.heading,\r",
      "          speed: coords.speed,\r",
      "        },\r",
      "        locatedAt,\r",
      "        error: error ? error.message : error,\r",
      "      },\r",
      "      null,\r",
      "      2,\r",
      "    )\r",
      "  }}</pre>\r",
      "    <button @click=\"pause\">\r",
      "      Pause watch\r",
      "    </button>\r",
      "    <button @click=\"resume\">\r",
      "      Start watch\r",
      "    </button>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useIdle - vueuse": {
    "prefix": "hvue useIdle - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useIdle\r",
      "\r",
      "Tracks whether the user is being inactive.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useIdle } from '@vueuse/core'\r",
      "\r",
      "const { idle, lastActive } = useIdle(5 * 60 * 1000) // 5 min\r",
      "\r",
      "console.log(idle.value) // true or false\r",
      "```\r",
      "\r",
      "Programatically resetting:\r",
      "\r",
      "\r",
      "```js\r",
      "import { watch } from 'vue'\r",
      "import { useCounter, useIdle } from '@vueuse/core'\r",
      "\r",
      "const { inc, count } = useCounter()\r",
      "\r",
      "const { idle, lastActive, reset } = useIdle(5 * 60 * 1000) // 5 min\r",
      "\r",
      "watch(idle, (idleValue) => {\r",
      "  if (idleValue) {\r",
      "    inc()\r",
      "    console.log(`Triggered ${count.value} times`)\r",
      "    reset() // restarts the idle timer. Does not change lastActive value\r",
      "  }\r",
      "})\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseIdle v-slot=\"{ idle }\" :timeout=\"5 * 60 * 1000\">\r",
      "  Is Idle: {{ idle }}\r",
      "</UseIdle>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ConfigurableEventFilter } from '@vueuse/shared'\r",
      "import { createFilterWrapper, throttleFilter, timestamp } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import type { WindowEventName } from '../useEventListener'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "const defaultEvents: WindowEventName[] = ['mousemove', 'mousedown', 'resize', 'keydown', 'touchstart', 'wheel']\r",
      "const oneMinute = 60_000\r",
      "\r",
      "export interface UseIdleOptions extends ConfigurableWindow, ConfigurableEventFilter {\r",
      "  /**\r",
      "   * Event names that listen to for detected user activity\r",
      "   *\r",
      "   * @default ['mousemove', 'mousedown', 'resize', 'keydown', 'touchstart', 'wheel']\r",
      "   */\r",
      "  events?: WindowEventName[]\r",
      "  /**\r",
      "   * Listen for document visibility change\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  listenForVisibilityChange?: boolean\r",
      "  /**\r",
      "   * Initial state of the ref idle\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  initialState?: boolean\r",
      "}\r",
      "\r",
      "export interface UseIdleReturn {\r",
      "  idle: Ref<boolean>\r",
      "  lastActive: Ref<number>\r",
      "  reset: () => void\r",
      "}\r",
      "\r",
      "/**\r",
      " * Tracks whether the user is being inactive.\r",
      " *\r",
      " * @see https://vueuse.org/useIdle\r",
      " * @param timeout default to 1 minute\r",
      " * @param options IdleOptions\r",
      " */\r",
      "export function useIdle(\r",
      "  timeout: number = oneMinute,\r",
      "  options: UseIdleOptions = {},\r",
      "): UseIdleReturn {\r",
      "  const {\r",
      "    initialState = false,\r",
      "    listenForVisibilityChange = true,\r",
      "    events = defaultEvents,\r",
      "    window = defaultWindow,\r",
      "    eventFilter = throttleFilter(50),\r",
      "  } = options\r",
      "  const idle = ref(initialState)\r",
      "  const lastActive = ref(timestamp())\r",
      "\r",
      "  let timer: any\r",
      "\r",
      "  const reset = () => {\r",
      "    idle.value = false\r",
      "    clearTimeout(timer)\r",
      "    timer = setTimeout(() => idle.value = true, timeout)\r",
      "  }\r",
      "\r",
      "  const onEvent = createFilterWrapper(\r",
      "    eventFilter,\r",
      "    () => {\r",
      "      lastActive.value = timestamp()\r",
      "      reset()\r",
      "    },\r",
      "  )\r",
      "\r",
      "  if (window) {\r",
      "    const document = window.document\r",
      "    for (const event of events)\r",
      "      useEventListener(window, event, onEvent, { passive: true })\r",
      "\r",
      "    if (listenForVisibilityChange) {\r",
      "      useEventListener(document, 'visibilitychange', () => {\r",
      "        if (!document.hidden)\r",
      "          onEvent()\r",
      "      })\r",
      "    }\r",
      "\r",
      "    reset()\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    idle,\r",
      "    lastActive,\r",
      "    reset,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed } from 'vue'\r",
      "import { useIdle, useTimestamp } from '@vueuse/core'\r",
      "\r",
      "const { idle, lastActive } = useIdle(5000)\r",
      "\r",
      "const now = useTimestamp({ interval: 1000 })\r",
      "\r",
      "const idledFor = computed(() =>\r",
      "  Math.floor((now.value - lastActive.value) / 1000),\r",
      ")\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    For demonstration purpose, the idle timeout is set to <b>5s</b> in this\r",
      "    demo (default 1min).\r",
      "  </note>\r",
      "  <div class=\"mb-2\">\r",
      "    Idle: <BooleanDisplay :value=\"idle\" />\r",
      "  </div>\r",
      "  <div>Inactive: <b class=\"text-primary\">{{ idledFor }}s</b></div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useImage - vueuse": {
    "prefix": "hvue useImage - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useImage\r",
      "\r",
      "Reactive load an image in the browser, you can wait the result to display it or show a fallback.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { useImage } from '@vueuse/core'\r",
      "\r",
      "const avatarUrl = 'https://place.dog/300/200'\r",
      "const { isLoading } = useImage({ src: avatarUrl })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <span v-if=\"isLoading\">Loading</span>\r",
      "  <img v-else :src=\"avatarUrl\">\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <UseImage src=\"https://place.dog/300/200\">\r",
      "    <template #loading>\r",
      "      Loading..\r",
      "    </template>\r",
      "\r",
      "    <template #error>\r",
      "      Failed\r",
      "    </template>\r",
      "  </UseImage>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { watch } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import type { UseAsyncStateOptions } from '../useAsyncState'\r",
      "import { useAsyncState } from '../useAsyncState'\r",
      "\r",
      "export interface UseImageOptions {\r",
      "  /** Address of the resource */\r",
      "  src: string\r",
      "  /** Images to use in different situations, e.g., high-resolution displays, small monitors, etc. */\r",
      "  srcset?: string\r",
      "  /** Image sizes for different page layouts */\r",
      "  sizes?: string\r",
      "  /** Image alternative information */\r",
      "  alt?: string\r",
      "  /** Image classes */\r",
      "  class?: string\r",
      "  /** Image loading */\r",
      "  loading?: HTMLImageElement['loading']\r",
      "  /** Image CORS settings */\r",
      "  crossorigin?: string\r",
      "  /** Referrer policy for fetch https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy */\r",
      "  referrerPolicy?: HTMLImageElement['referrerPolicy']\r",
      "}\r",
      "\r",
      "async function loadImage(options: UseImageOptions): Promise<HTMLImageElement> {\r",
      "  return new Promise((resolve, reject) => {\r",
      "    const img = new Image()\r",
      "    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy } = options\r",
      "\r",
      "    img.src = src\r",
      "\r",
      "    if (srcset)\r",
      "      img.srcset = srcset\r",
      "\r",
      "    if (sizes)\r",
      "      img.sizes = sizes\r",
      "\r",
      "    if (clazz)\r",
      "      img.className = clazz\r",
      "\r",
      "    if (loading)\r",
      "      img.loading = loading\r",
      "\r",
      "    if (crossorigin)\r",
      "      img.crossOrigin = crossorigin\r",
      "\r",
      "    if (referrerPolicy)\r",
      "      img.referrerPolicy = referrerPolicy\r",
      "\r",
      "    img.onload = () => resolve(img)\r",
      "    img.onerror = reject\r",
      "  })\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive load an image in the browser, you can wait the result to display it or show a fallback.\r",
      " *\r",
      " * @see https://vueuse.org/useImage\r",
      " * @param options Image attributes, as used in the <img> tag\r",
      " * @param asyncStateOptions\r",
      " */\r",
      "export function useImage<Shallow extends true>(options: MaybeRefOrGetter<UseImageOptions>,\r",
      "  asyncStateOptions: UseAsyncStateOptions<Shallow> = {}) {\r",
      "  const state = useAsyncState<HTMLImageElement | undefined>(\r",
      "    () => loadImage(toValue(options)),\r",
      "    undefined,\r",
      "    {\r",
      "      resetOnExecute: true,\r",
      "      ...asyncStateOptions,\r",
      "    },\r",
      "  )\r",
      "\r",
      "  watch(\r",
      "    () => toValue(options),\r",
      "    () => state.execute(asyncStateOptions.delay),\r",
      "    { deep: true },\r",
      "  )\r",
      "\r",
      "  return state\r",
      "}\r",
      "\r",
      "export type UseImageReturn = ReturnType<typeof useImage>\r",
      "```",
      "# Demo",
      "```vue",
      "<script lang=\"ts\" setup>\r",
      "import { useImage } from '@vueuse/core'\r",
      "import { ref } from 'vue'\r",
      "\r",
      "const imageOptions = ref({ src: 'https://place-hold.it/300x200' })\r",
      "const colors = ['fff', '000', '5f0caa']\r",
      "const { isLoading, error } = useImage(imageOptions, { delay: 1000 })\r",
      "\r",
      "function change() {\r",
      "  imageOptions.value.src = ''\r",
      "  const color: string = colors[Math.floor(Math.random() * colors.length)]\r",
      "  imageOptions.value.src = `https://place-hold.it/300x200/${color}`\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div v-if=\"isLoading\" class=\"w-[300px] h-[200px] animate-pulse bg-gray-500/5 p-2\">\r",
      "    Loading...\r",
      "  </div>\r",
      "  <div v-else-if=\"error\" class=\"text-red\">\r",
      "    Failed\r",
      "  </div>\r",
      "  <img v-else :src=\"imageOptions.src\" class=\"w-[300px] h-[200px]\">\r",
      "\r",
      "  <button @click=\"change\">\r",
      "    Change\r",
      "  </button>\r",
      "\r",
      "  <button @click=\"imageOptions.src = ''\">\r",
      "    Create Error\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useInfiniteScroll - vueuse": {
    "prefix": "hvue useInfiniteScroll - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useInfiniteScroll\r",
      "\r",
      "Infinite scrolling of the element.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useInfiniteScroll } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLElement>(null)\r",
      "const data = ref([1, 2, 3, 4, 5, 6])\r",
      "\r",
      "useInfiniteScroll(\r",
      "  el,\r",
      "  () => {\r",
      "    // load more\r",
      "    data.value.push(...moreData)\r",
      "  },\r",
      "  { distance: 10 }\r",
      ")\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\">\r",
      "    <div v-for=\"item in data\">\r",
      "      {{ item }}\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Directive Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { vInfiniteScroll } from '@vueuse/components'\r",
      "\r",
      "const data = ref([1, 2, 3, 4, 5, 6])\r",
      "\r",
      "function onLoadMore() {\r",
      "  const length = data.value.length + 1\r",
      "  data.value.push(...Array.from({ length: 5 }, (_, i) => length + i))\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div v-infinite-scroll=\"onLoadMore\">\r",
      "    <div v-for=\"item in data\" :key=\"item\">\r",
      "      {{ item }}\r",
      "    </div>\r",
      "  </div>\r",
      "\r",
      "  <!-- with options -->\r",
      "  <div v-infinite-scroll=\"[onLoadMore, { 'distance' : 10 }]\">\r",
      "    <div v-for=\"item in data\" :key=\"item\">\r",
      "      {{ item }}\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Awaitable, MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import type { UnwrapNestedRefs } from 'vue-demi'\r",
      "import { computed, nextTick, reactive, ref, watch } from 'vue-demi'\r",
      "import { useElementVisibility } from '../useElementVisibility'\r",
      "import type { UseScrollOptions } from '../useScroll'\r",
      "import { useScroll } from '../useScroll'\r",
      "\r",
      "export interface UseInfiniteScrollOptions extends UseScrollOptions {\r",
      "  /**\r",
      "   * The minimum distance between the bottom of the element and the bottom of the viewport\r",
      "   *\r",
      "   * @default 0\r",
      "   */\r",
      "  distance?: number\r",
      "\r",
      "  /**\r",
      "   * The direction in which to listen the scroll.\r",
      "   *\r",
      "   * @default 'bottom'\r",
      "   */\r",
      "  direction?: 'top' | 'bottom' | 'left' | 'right'\r",
      "\r",
      "  /**\r",
      "   * The interval time between two load more (to avoid too many invokes).\r",
      "   *\r",
      "   * @default 100\r",
      "   */\r",
      "  interval?: number\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive infinite scroll.\r",
      " *\r",
      " * @see https://vueuse.org/useInfiniteScroll\r",
      " */\r",
      "export function useInfiniteScroll(\r",
      "  element: MaybeRefOrGetter<HTMLElement | SVGElement | Window | Document | null | undefined>,\r",
      "  onLoadMore: (state: UnwrapNestedRefs<ReturnType<typeof useScroll>>) => Awaitable<void>,\r",
      "  options: UseInfiniteScrollOptions = {},\r",
      ") {\r",
      "  const {\r",
      "    direction = 'bottom',\r",
      "    interval = 100,\r",
      "  } = options\r",
      "\r",
      "  const state = reactive(useScroll(\r",
      "    element,\r",
      "    {\r",
      "      ...options,\r",
      "      offset: {\r",
      "        [direction]: options.distance ?? 0,\r",
      "        ...options.offset,\r",
      "      },\r",
      "    },\r",
      "  ))\r",
      "\r",
      "  const promise = ref<any>()\r",
      "  const isLoading = computed(() => !!promise.value)\r",
      "  // Document and Window cannot be observed by IntersectionObserver\r",
      "  const observedElement = computed<HTMLElement | SVGElement | null | undefined>(() => {\r",
      "    const el = toValue(element)\r",
      "    if (el instanceof Window)\r",
      "      return window.document.documentElement\r",
      "\r",
      "    if (el instanceof Document)\r",
      "      return document.documentElement\r",
      "\r",
      "    return el\r",
      "  })\r",
      "  const isElementVisible = useElementVisibility(observedElement)\r",
      "\r",
      "  function checkAndLoad() {\r",
      "    state.measure()\r",
      "\r",
      "    if (!observedElement.value || !isElementVisible.value)\r",
      "      return\r",
      "\r",
      "    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value as HTMLElement\r",
      "    const isNarrower = (direction === 'bottom' || direction === 'top')\r",
      "      ? scrollHeight <= clientHeight\r",
      "      : scrollWidth <= clientWidth\r",
      "\r",
      "    if (state.arrivedState[direction] || isNarrower) {\r",
      "      if (!promise.value) {\r",
      "        promise.value = Promise.all([\r",
      "          onLoadMore(state),\r",
      "          new Promise(resolve => setTimeout(resolve, interval)),\r",
      "        ])\r",
      "          .finally(() => {\r",
      "            promise.value = null\r",
      "            nextTick(() => checkAndLoad())\r",
      "          })\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "\r",
      "  watch(\r",
      "    () => [state.arrivedState[direction], isElementVisible.value],\r",
      "    checkAndLoad,\r",
      "    { immediate: true },\r",
      "  )\r",
      "\r",
      "  return {\r",
      "    isLoading,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useInfiniteScroll } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "const data = ref([1])\r",
      "\r",
      "useInfiniteScroll(\r",
      "  el,\r",
      "  () => {\r",
      "    const length = data.value.length + 1\r",
      "    data.value.push(...Array.from({ length: 5 }, (_, i) => length + i))\r",
      "  },\r",
      "  { distance: 10 },\r",
      ")\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\" class=\"flex flex-col gap-2 p-4 w-300px h-300px m-auto overflow-y-scroll bg-gray-500/5 rounded\">\r",
      "    <div v-for=\"item in data\" :key=\"item\" class=\"h-15 bg-gray-500/5 rounded p-3\">\r",
      "      {{ item }}\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useIntersectionObserver - vueuse": {
    "prefix": "hvue useIntersectionObserver - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useIntersectionObserver\r",
      "\r",
      "Detects that a target element's visibility.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<div ref=\"target\">\r",
      "  <h1>Hello world</h1>\r",
      "</div>\r",
      "```\r",
      "\r",
      "```js\r",
      "import { ref } from 'vue'\r",
      "import { useIntersectionObserver } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const target = ref(null)\r",
      "    const targetIsVisible = ref(false)\r",
      "\r",
      "    const { stop } = useIntersectionObserver(\r",
      "      target,\r",
      "      ([{ isIntersecting }], observerElement) => {\r",
      "        targetIsVisible.value = isIntersecting\r",
      "      },\r",
      "    )\r",
      "\r",
      "    return {\r",
      "      target,\r",
      "      targetIsVisible,\r",
      "    }\r",
      "  },\r",
      "}\r",
      "```\r",
      "\r",
      "## Directive Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { vIntersectionObserver } from '@vueuse/components'\r",
      "\r",
      "const root = ref(null)\r",
      "\r",
      "const isVisible = ref(false)\r",
      "\r",
      "function onIntersectionObserver([{ isIntersecting }]) {\r",
      "  isVisible.value = isIntersecting\r",
      "}\r",
      "\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <p>\r",
      "      Scroll me down!\r",
      "    </p>\r",
      "    <div v-intersection-observer=\"onIntersectionObserver\">\r",
      "      <p>Hello world!</p>\r",
      "    </div>\r",
      "  </div>\r",
      "\r",
      "  <!-- with options -->\r",
      "  <div ref=\"root\">\r",
      "    <p>\r",
      "      Scroll me down!\r",
      "    </p>\r",
      "    <div v-intersection-observer=\"[onIntersectionObserver, { root }]\">\r",
      "      <p>Hello world!</p>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "\r",
      "[IntersectionObserver MDN](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver)\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { computed, ref, watch } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter, Pausable } from '@vueuse/shared'\r",
      "import { noop, notNullish, toValue, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import type { MaybeComputedElementRef, MaybeElement } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "export interface UseIntersectionObserverOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Start the IntersectionObserver immediately on creation\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "\r",
      "  /**\r",
      "   * The Element or Document whose bounds are used as the bounding box when testing for intersection.\r",
      "   */\r",
      "  root?: MaybeComputedElementRef\r",
      "\r",
      "  /**\r",
      "   * A string which specifies a set of offsets to add to the root's bounding_box when calculating intersections.\r",
      "   */\r",
      "  rootMargin?: string\r",
      "\r",
      "  /**\r",
      "   * Either a single number or an array of numbers between 0.0 and 1.\r",
      "   */\r",
      "  threshold?: number | number[]\r",
      "}\r",
      "\r",
      "export interface UseIntersectionObserverReturn extends Pausable {\r",
      "  isSupported: Ref<boolean>\r",
      "  stop: () => void\r",
      "}\r",
      "\r",
      "/**\r",
      " * Detects that a target element's visibility.\r",
      " *\r",
      " * @see https://vueuse.org/useIntersectionObserver\r",
      " * @param target\r",
      " * @param callback\r",
      " * @param options\r",
      " */\r",
      "export function useIntersectionObserver(\r",
      "  target: MaybeComputedElementRef | MaybeRefOrGetter<MaybeElement[]> | MaybeComputedElementRef[],\r",
      "  callback: IntersectionObserverCallback,\r",
      "  options: UseIntersectionObserverOptions = {},\r",
      "): UseIntersectionObserverReturn {\r",
      "  const {\r",
      "    root,\r",
      "    rootMargin = '0px',\r",
      "    threshold = 0.1,\r",
      "    window = defaultWindow,\r",
      "    immediate = true,\r",
      "  } = options\r",
      "\r",
      "  const isSupported = useSupported(() => window && 'IntersectionObserver' in window)\r",
      "  const targets = computed(() => {\r",
      "    const _target = toValue(target)\r",
      "    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish)\r",
      "  })\r",
      "\r",
      "  let cleanup = noop\r",
      "  const isActive = ref(immediate)\r",
      "\r",
      "  const stopWatch = isSupported.value\r",
      "    ? watch(\r",
      "      () => [targets.value, unrefElement(root), isActive.value] as const,\r",
      "      ([targets, root]) => {\r",
      "        cleanup()\r",
      "        if (!isActive.value)\r",
      "          return\r",
      "\r",
      "        if (!targets.length)\r",
      "          return\r",
      "\r",
      "        const observer = new IntersectionObserver(\r",
      "          callback,\r",
      "          {\r",
      "            root: unrefElement(root),\r",
      "            rootMargin,\r",
      "            threshold,\r",
      "          },\r",
      "        )\r",
      "\r",
      "        targets.forEach(el => el && observer.observe(el))\r",
      "\r",
      "        cleanup = () => {\r",
      "          observer.disconnect()\r",
      "          cleanup = noop\r",
      "        }\r",
      "      },\r",
      "      { immediate, flush: 'post' },\r",
      "    )\r",
      "    : noop\r",
      "\r",
      "  const stop = () => {\r",
      "    cleanup()\r",
      "    stopWatch()\r",
      "    isActive.value = false\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(stop)\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    isActive,\r",
      "    pause() {\r",
      "      cleanup()\r",
      "      isActive.value = false\r",
      "    },\r",
      "    resume() {\r",
      "      isActive.value = true\r",
      "    },\r",
      "    stop,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useIntersectionObserver } from '@vueuse/core'\r",
      "\r",
      "const root = ref(null)\r",
      "const target = ref(null)\r",
      "const isVisible = ref(false)\r",
      "\r",
      "const { isActive, pause, resume } = useIntersectionObserver(\r",
      "  target,\r",
      "  ([{ isIntersecting }]) => {\r",
      "    isVisible.value = isIntersecting\r",
      "  },\r",
      "  { root },\r",
      ")\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"text-center\">\r",
      "    <label class=\"checkbox\">\r",
      "      <input\r",
      "        :checked=\"isActive\" type=\"checkbox\" name=\"enabled\"\r",
      "        @input=\"($event.target as HTMLInputElement)!.checked ? resume() : pause() \"\r",
      "      >\r",
      "      <span>Enable</span>\r",
      "    </label>\r",
      "  </div>\r",
      "  <div ref=\"root\" class=\"root\">\r",
      "    <p class=\"notice\">\r",
      "      Scroll me down!\r",
      "    </p>\r",
      "    <div ref=\"target\" class=\"target\">\r",
      "      <p>Hello world!</p>\r",
      "    </div>\r",
      "  </div>\r",
      "  <div class=\"text-center\">\r",
      "    Element\r",
      "    <BooleanDisplay\r",
      "      :value=\"isVisible\"\r",
      "      true=\"inside\"\r",
      "      false=\"outside\"\r",
      "      class=\"font-bold\"\r",
      "    />\r",
      "    the viewport\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      ".root {\r",
      "  border: 2px dashed #ccc;\r",
      "  height: 200px;\r",
      "  margin: 2rem 1rem;\r",
      "  overflow-y: scroll;\r",
      "}\r",
      ".notice {\r",
      "  text-align: center;\r",
      "  padding: 2em 0;\r",
      "  margin-bottom: 300px;\r",
      "  font-style: italic;\r",
      "  font-size: 1.2rem;\r",
      "  opacity: 0.8;\r",
      "}\r",
      ".target {\r",
      "  border: 2px dashed var(--vp-c-brand);\r",
      "  padding: 10px;\r",
      "  max-height: 150px;\r",
      "  margin: 0 2rem 400px;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useKeyModifier - vueuse": {
    "prefix": "hvue useKeyModifier - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useKeyModifier\r",
      "\r",
      "Reactive [Modifier State](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState). Tracks state of any of the [supported modifiers](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState#browser_compatibility) - see Browser Compatibility notes.\r",
      "\r",
      "<CourseLink href=\"https://vueschool.io/lessons/alt-drag-to-clone-tasks?friend=vueuse\">Learn useKeyModifier with this FREE video lesson from Vue School!</CourseLink>\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useKeyModifier } from '@vueuse/core'\r",
      "\r",
      "const capsLockState = useKeyModifier('CapsLock')\r",
      "\r",
      "console.log(capsLockState.value)\r",
      "```\r",
      "\r",
      "## Events\r",
      "\r",
      "You can customize which events will prompt the state to update. By default, these are `mouseup`, `mousedown`, `keyup`, `keydown`. To customize these events:\r",
      "\r",
      "```ts\r",
      "import { useKeyModifier } from '@vueuse/core'\r",
      "\r",
      "const capsLockState = useKeyModifier('CapsLock', { events: ['mouseup', 'mousedown'] })\r",
      "\r",
      "console.log(capsLockState) // null\r",
      "\r",
      "// Caps Lock turned on with key press\r",
      "console.log(capsLockState) // null\r",
      "\r",
      "// Mouse button clicked\r",
      "console.log(capsLockState) // true\r",
      "```\r",
      "\r",
      "## Initial State\r",
      "\r",
      "By default, the returned ref will be `Ref<null>` until the first event is received. You can explicitly pass the initial state to it via:\r",
      "\r",
      "```ts\r",
      "const capsLockState1 = useKeyModifier('CapsLock') // Ref<boolean | null>\r",
      "const capsLockState2 = useKeyModifier('CapsLock', { initial: false }) // Ref<boolean>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import type { WindowEventName } from '../useEventListener'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "\r",
      "export type KeyModifier = 'Alt' | 'AltGraph' | 'CapsLock' | 'Control' | 'Fn' | 'FnLock' | 'Meta' | 'NumLock' | 'ScrollLock' | 'Shift' | 'Symbol' | 'SymbolLock'\r",
      "\r",
      "const defaultEvents: WindowEventName[] = ['mousedown', 'mouseup', 'keydown', 'keyup']\r",
      "\r",
      "export interface UseModifierOptions<Initial> extends ConfigurableDocument {\r",
      "  /**\r",
      "   * Event names that will prompt update to modifier states\r",
      "   *\r",
      "   * @default ['mousedown', 'mouseup', 'keydown', 'keyup']\r",
      "   */\r",
      "  events?: WindowEventName[]\r",
      "\r",
      "  /**\r",
      "   * Initial value of the returned ref\r",
      "   *\r",
      "   * @default null\r",
      "   */\r",
      "  initial?: Initial\r",
      "}\r",
      "\r",
      "export type UseKeyModifierReturn<Initial> = Ref<Initial extends boolean ? boolean : boolean | null>\r",
      "\r",
      "export function useKeyModifier<Initial extends boolean | null>(modifier: KeyModifier, options: UseModifierOptions<Initial> = {}): UseKeyModifierReturn<Initial> {\r",
      "  const {\r",
      "    events = defaultEvents,\r",
      "    document = defaultDocument,\r",
      "    initial = null,\r",
      "  } = options\r",
      "\r",
      "  const state = ref(initial) as Ref<boolean>\r",
      "\r",
      "  if (document) {\r",
      "    events.forEach((listenerEvent) => {\r",
      "      useEventListener(document, listenerEvent, (evt: KeyboardEvent | MouseEvent) => {\r",
      "        if (typeof evt.getModifierState === 'function')\r",
      "          state.value = evt.getModifierState(modifier)\r",
      "      })\r",
      "    })\r",
      "  }\r",
      "\r",
      "  return state\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useKeyModifier } from '@vueuse/core'\r",
      "import Key from '../useMagicKeys/Key.vue'\r",
      "\r",
      "const capsLock = useKeyModifier('CapsLock')\r",
      "const numLock = useKeyModifier('NumLock')\r",
      "const scrollLock = useKeyModifier('ScrollLock')\r",
      "const shift = useKeyModifier('Shift')\r",
      "const control = useKeyModifier('Control')\r",
      "const alt = useKeyModifier('Alt')\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"grid grid-cols-1 md:grid-cols-3 gap-2\">\r",
      "    <Key :value=\"capsLock || false\">\r",
      "      capsLock\r",
      "    </Key>\r",
      "    <Key :value=\"numLock || false\">\r",
      "      numLock\r",
      "    </Key>\r",
      "    <Key :value=\"scrollLock || false\">\r",
      "      scrollLock\r",
      "    </Key>\r",
      "    <Key :value=\"shift || false\">\r",
      "      shift\r",
      "    </Key>\r",
      "    <Key :value=\"control || false\">\r",
      "      control\r",
      "    </Key>\r",
      "    <Key :value=\"alt || false\">\r",
      "      alt\r",
      "    </Key>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMagicKeys - vueuse": {
    "prefix": "hvue useMagicKeys - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useMagicKeys\r",
      "\r",
      "Reactive keys pressed state, with magical keys combination support.\r",
      "\r",
      "<RequiresProxy />\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useMagicKeys } from '@vueuse/core'\r",
      "\r",
      "const { shift, space, a /* keys you want to monitor */ } = useMagicKeys()\r",
      "\r",
      "watch(space, (v) => {\r",
      "  if (v)\r",
      "    console.log('space has been pressed')\r",
      "})\r",
      "\r",
      "watchEffect(() => {\r",
      "  if (shift.value && a.value)\r",
      "    console.log('Shift + A have been pressed')\r",
      "})\r",
      "```\r",
      "\r",
      "Check out [all the possible keycodes](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values).\r",
      "\r",
      "### Combinations\r",
      "\r",
      "You can magically use combinations (shortcuts/hotkeys) by connecting keys with `+` or `_`.\r",
      "\r",
      "```ts\r",
      "import { useMagicKeys } from '@vueuse/core'\r",
      "\r",
      "const keys = useMagicKeys()\r",
      "const shiftCtrlA = keys['Shift+Ctrl+A']\r",
      "\r",
      "watch(shiftCtrlA, (v) => {\r",
      "  if (v)\r",
      "    console.log('Shift + Ctrl + A have been pressed')\r",
      "})\r",
      "```\r",
      "\r",
      "```ts\r",
      "import { useMagicKeys } from '@vueuse/core'\r",
      "\r",
      "const { Ctrl_A_B, space, alt_s /* ... */ } = useMagicKeys()\r",
      "\r",
      "watch(Ctrl_A_B, (v) => {\r",
      "  if (v)\r",
      "    console.log('Control+A+B have been pressed')\r",
      "})\r",
      "```\r",
      "\r",
      "You can also use `whenever` function to make it shorter\r",
      "\r",
      "```ts\r",
      "import { useMagicKeys, whenever } from '@vueuse/core'\r",
      "\r",
      "const keys = useMagicKeys()\r",
      "\r",
      "whenever(keys.shift_space, () => {\r",
      "  console.log('Shift+Space have been pressed')\r",
      "})\r",
      "```\r",
      "\r",
      "### Current Pressed keys\r",
      "\r",
      "A special property `current` is provided to representing all the keys been pressed currently.\r",
      "\r",
      "```ts\r",
      "import { useMagicKeys } from '@vueuse/core'\r",
      "\r",
      "const { current } = useMagicKeys()\r",
      "\r",
      "console.log(current) // Set { 'control', 'a' }\r",
      "\r",
      "whenever(\r",
      "  () => current.has('a') && !current.has('b'),\r",
      "  () => console.log('A is pressed but not B'),\r",
      ")\r",
      "```\r",
      "\r",
      "### Key Aliasing\r",
      "\r",
      "```ts\r",
      "import { useMagicKeys, whenever } from '@vueuse/core'\r",
      "\r",
      "const { shift_cool } = useMagicKeys({\r",
      "  aliasMap: {\r",
      "    cool: 'space',\r",
      "  },\r",
      "})\r",
      "\r",
      "whenever(shift_cool, () => console.log('Shift + Space have been pressed'))\r",
      "```\r",
      "\r",
      "By default, we have some [preconfigured alias for common practices](https://github.com/vueuse/vueuse/blob/main/packages/core/useMagicKeys/aliasMap.ts).\r",
      "\r",
      "### Conditionally Disable\r",
      "\r",
      "You might have some `<input />` elements in your apps, and you don't want to trigger the magic keys handling when users focused on those inputs. There is an example of using `useActiveElement` and `logicAnd` to do that.\r",
      "\r",
      "```ts\r",
      "import { useActiveElement, useMagicKeys, whenever } from '@vueuse/core'\r",
      "import { logicAnd } from '@vueuse/math'\r",
      "\r",
      "const activeElement = useActiveElement()\r",
      "const notUsingInput = computed(() =>\r",
      "  activeElement.value?.tagName !== 'INPUT'\r",
      "  && activeElement.value?.tagName !== 'TEXTAREA',\r",
      ")\r",
      "\r",
      "const { tab } = useMagicKeys()\r",
      "\r",
      "whenever(logicAnd(tab, notUsingInput), () => {\r",
      "  console.log('Tab has been pressed outside of inputs!')\r",
      "})\r",
      "```\r",
      "\r",
      "### Custom Event Handler\r",
      "\r",
      "```ts\r",
      "import { useMagicKeys, whenever } from '@vueuse/core'\r",
      "\r",
      "const { ctrl_s } = useMagicKeys({\r",
      "  passive: false,\r",
      "  onEventFired(e) {\r",
      "    if (e.ctrlKey && e.key === 's' && e.type === 'keydown')\r",
      "      e.preventDefault()\r",
      "\r",
      "  },\r",
      "})\r",
      "\r",
      "whenever(ctrl_s, () => console.log('Ctrl+S have been pressed'))\r",
      "```\r",
      "\r",
      "> ‚ö†Ô∏è This usage is NOT recommended, please use with caution.\r",
      "\r",
      "### Reactive Mode\r",
      "\r",
      "By default, the values of `useMagicKeys()` are `Ref<boolean>`. If you want to use the object in the template, you can set it to reactive mode.\r",
      "\r",
      "```ts\r",
      "const keys = useMagicKeys({ reactive: true })\r",
      "```\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <div v-if=\"keys.shift\">\r",
      "    You are holding the Shift key!\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef } from 'vue-demi'\r",
      "import { computed, reactive, ref } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { noop, toValue } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import { DefaultMagicKeysAliasMap } from './aliasMap'\r",
      "\r",
      "export interface UseMagicKeysOptions<Reactive extends boolean> {\r",
      "  /**\r",
      "   * Returns a reactive object instead of an object of refs\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  reactive?: Reactive\r",
      "\r",
      "  /**\r",
      "   * Target for listening events\r",
      "   *\r",
      "   * @default window\r",
      "   */\r",
      "  target?: MaybeRefOrGetter<EventTarget>\r",
      "\r",
      "  /**\r",
      "   * Alias map for keys, all the keys should be lowercase\r",
      "   * { target: keycode }\r",
      "   *\r",
      "   * @example { ctrl: \"control\" }\r",
      "   * @default <predefined-map>\r",
      "   */\r",
      "  aliasMap?: Record<string, string>\r",
      "\r",
      "  /**\r",
      "   * Register passive listener\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  passive?: boolean\r",
      "\r",
      "  /**\r",
      "   * Custom event handler for keydown/keyup event.\r",
      "   * Useful when you want to apply custom logic.\r",
      "   *\r",
      "   * When using `e.preventDefault()`, you will need to pass `passive: false` to useMagicKeys().\r",
      "   */\r",
      "  onEventFired?: (e: KeyboardEvent) => void | boolean\r",
      "}\r",
      "\r",
      "export interface MagicKeysInternal {\r",
      "  /**\r",
      "   * A Set of currently pressed keys,\r",
      "   * Stores raw keyCodes.\r",
      "   *\r",
      "   * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r",
      "   */\r",
      "  current: Set<string>\r",
      "}\r",
      "\r",
      "export type UseMagicKeysReturn<Reactive extends boolean> =\r",
      "  Readonly<\r",
      "  Omit<Reactive extends true\r",
      "    ? Record<string, boolean>\r",
      "    : Record<string, ComputedRef<boolean>>,\r",
      "  keyof MagicKeysInternal>\r",
      "  & MagicKeysInternal\r",
      "  >\r",
      "\r",
      "/**\r",
      " * Reactive keys pressed state, with magical keys combination support.\r",
      " *\r",
      " * @see https://vueuse.org/useMagicKeys\r",
      " */\r",
      "export function useMagicKeys(options?: UseMagicKeysOptions<false>): UseMagicKeysReturn<false>\r",
      "export function useMagicKeys(options: UseMagicKeysOptions<true>): UseMagicKeysReturn<true>\r",
      "export function useMagicKeys(options: UseMagicKeysOptions<boolean> = {}): any {\r",
      "  const {\r",
      "    reactive: useReactive = false,\r",
      "    target = defaultWindow,\r",
      "    aliasMap = DefaultMagicKeysAliasMap,\r",
      "    passive = true,\r",
      "    onEventFired = noop,\r",
      "  } = options\r",
      "  const current = reactive(new Set<string>())\r",
      "  const obj = {\r",
      "    toJSON() { return {} },\r",
      "    current,\r",
      "  }\r",
      "  const refs: Record<string, any> = useReactive ? reactive(obj) : obj\r",
      "  const metaDeps = new Set<string>()\r",
      "  const usedKeys = new Set<string>()\r",
      "\r",
      "  function setRefs(key: string, value: boolean) {\r",
      "    if (key in refs) {\r",
      "      if (useReactive)\r",
      "        refs[key] = value\r",
      "      else\r",
      "        refs[key].value = value\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function reset() {\r",
      "    current.clear()\r",
      "    for (const key of usedKeys)\r",
      "      setRefs(key, false)\r",
      "  }\r",
      "\r",
      "  function updateRefs(e: KeyboardEvent, value: boolean) {\r",
      "    const key = e.key?.toLowerCase()\r",
      "    const code = e.code?.toLowerCase()\r",
      "    const values = [code, key].filter(Boolean)\r",
      "\r",
      "    // current set\r",
      "    if (key) {\r",
      "      if (value)\r",
      "        current.add(key)\r",
      "      else\r",
      "        current.delete(key)\r",
      "    }\r",
      "\r",
      "    for (const key of values) {\r",
      "      usedKeys.add(key)\r",
      "      setRefs(key, value)\r",
      "    }\r",
      "\r",
      "    // #1312\r",
      "    // In macOS, keys won't trigger \"keyup\" event when Meta key is released\r",
      "    // We track it's combination and release manually\r",
      "    if (key === 'meta' && !value) {\r",
      "      // Meta key released\r",
      "      metaDeps.forEach((key) => {\r",
      "        current.delete(key)\r",
      "        setRefs(key, false)\r",
      "      })\r",
      "      metaDeps.clear()\r",
      "    }\r",
      "    else if (typeof e.getModifierState === 'function' && e.getModifierState('Meta') && value) {\r",
      "      [...current, ...values].forEach(key => metaDeps.add(key))\r",
      "    }\r",
      "  }\r",
      "\r",
      "  useEventListener(target, 'keydown', (e: KeyboardEvent) => {\r",
      "    updateRefs(e, true)\r",
      "    return onEventFired(e)\r",
      "  }, { passive })\r",
      "  useEventListener(target, 'keyup', (e: KeyboardEvent) => {\r",
      "    updateRefs(e, false)\r",
      "    return onEventFired(e)\r",
      "  }, { passive })\r",
      "\r",
      "  // #1350\r",
      "  useEventListener('blur', reset, { passive: true })\r",
      "  useEventListener('focus', reset, { passive: true })\r",
      "\r",
      "  const proxy = new Proxy(\r",
      "    refs,\r",
      "    {\r",
      "      get(target, prop, rec) {\r",
      "        if (typeof prop !== 'string')\r",
      "          return Reflect.get(target, prop, rec)\r",
      "\r",
      "        prop = prop.toLowerCase()\r",
      "        // alias\r",
      "        if (prop in aliasMap)\r",
      "          prop = aliasMap[prop]\r",
      "        // create new tracking\r",
      "        if (!(prop in refs)) {\r",
      "          if (/[+_-]/.test(prop)) {\r",
      "            const keys = prop.split(/[+_-]/g).map(i => i.trim())\r",
      "            refs[prop] = computed(() => keys.every(key => toValue(proxy[key])))\r",
      "          }\r",
      "          else {\r",
      "            refs[prop] = ref(false)\r",
      "          }\r",
      "        }\r",
      "        const r = Reflect.get(target, prop, rec)\r",
      "        return useReactive ? toValue(r) : r\r",
      "      },\r",
      "    },\r",
      "  )\r",
      "\r",
      "  return proxy as any\r",
      "}\r",
      "\r",
      "export { DefaultMagicKeysAliasMap } from './aliasMap'\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed } from 'vue'\r",
      "import { useMagicKeys } from '@vueuse/core'\r",
      "import Key from './Key.vue'\r",
      "\r",
      "const { shift, v, u, e, s, v_u_e, u_s_e, current } = useMagicKeys()\r",
      "const keys = computed(() => Array.from(current))\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"flex flex-col md:flex-row\">\r",
      "    <img\r",
      "      src=\"/vue.svg\"\r",
      "      class=\"h-38 py-8 m-auto transform transition duration-500\"\r",
      "      :class=\"{ 'opacity-0': !v_u_e, 'rotate-180': shift }\"\r",
      "    >\r",
      "\r",
      "    <div>\r",
      "      <note class=\"text-center mt-0 mb-5\">\r",
      "        Press the following keys to test out\r",
      "      </note>\r",
      "      <div class=\"flex gap-3 justify-center\">\r",
      "        <Key :value=\"v\">\r",
      "          V\r",
      "        </Key>\r",
      "        <Key :value=\"u\">\r",
      "          u\r",
      "        </Key>\r",
      "        <Key :value=\"e\">\r",
      "          e\r",
      "        </Key>\r",
      "        <div class=\"mx-1\" />\r",
      "        <Key :value=\"u\">\r",
      "          U\r",
      "        </Key>\r",
      "        <Key :value=\"s\">\r",
      "          s\r",
      "        </Key>\r",
      "        <Key :value=\"e\">\r",
      "          e\r",
      "        </Key>\r",
      "      </div>\r",
      "\r",
      "      <div class=\"flex gap-3 justify-center mt-3\">\r",
      "        <Key :value=\"shift\">\r",
      "          Shift\r",
      "        </Key>\r",
      "        <Key :value=\"v_u_e\">\r",
      "          Vue\r",
      "        </Key>\r",
      "        <Key :value=\"u_s_e\">\r",
      "          Use\r",
      "        </Key>\r",
      "      </div>\r",
      "\r",
      "      <div class=\"text-center mt-4\">\r",
      "        <Note>Keys Pressed</Note>\r",
      "        <div class=\"flex mt-2 justify-center space-x-1 min-h-1.5em\">\r",
      "          <code\r",
      "            v-for=\"key in keys\"\r",
      "            :key=\"key\"\r",
      "            class=\"font-mono\"\r",
      "          >\r",
      "            {{ key }}\r",
      "          </code>\r",
      "        </div>\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <img\r",
      "      src=\"/favicon.svg\"\r",
      "      class=\"h-38 py-8 m-auto transform transition duration-500\"\r",
      "      :class=\"{ 'opacity-0': !u_s_e, 'rotate-180': shift }\"\r",
      "    >\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useManualRefHistory - vueuse": {
    "prefix": "hvue useManualRefHistory - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: State\r",
      "related: useRefHistory\r",
      "---\r",
      "\r",
      "# useManualRefHistory\r",
      "\r",
      "Manually track the change history of a ref when the using calls `commit()`, also provides undo and redo functionality\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts {5}\r",
      "import { ref } from 'vue'\r",
      "import { useManualRefHistory } from '@vueuse/core'\r",
      "\r",
      "const counter = ref(0)\r",
      "const { history, commit, undo, redo } = useManualRefHistory(counter)\r",
      "\r",
      "counter.value += 1\r",
      "commit()\r",
      "\r",
      "console.log(history.value)\r",
      "/* [\r",
      "  { snapshot: 1, timestamp: 1601912898062 },\r",
      "  { snapshot: 0, timestamp: 1601912898061 }\r",
      "] */\r",
      "```\r",
      "\r",
      "You can use `undo` to reset the ref value to the last history point.\r",
      "\r",
      "```ts\r",
      "console.log(counter.value) // 1\r",
      "undo()\r",
      "console.log(counter.value) // 0\r",
      "```\r",
      "\r",
      "#### History of mutable objects\r",
      "\r",
      "If you are going to mutate the source, you need to pass a custom clone function or use `clone` `true` as a param, that is a shortcut for a minimal clone function `x => JSON.parse(JSON.stringify(x))` that will be used in both `dump` and `parse`.\r",
      "\r",
      "```ts {5}\r",
      "import { ref } from 'vue'\r",
      "import { useManualRefHistory } from '@vueuse/core'\r",
      "\r",
      "const counter = ref({ foo: 1, bar: 2 })\r",
      "const { history, commit, undo, redo } = useManualRefHistory(counter, { clone: true })\r",
      "\r",
      "counter.value.foo += 1\r",
      "commit()\r",
      "```\r",
      "\r",
      "#### Custom Clone Function\r",
      "\r",
      "To use a full featured or custom clone function, you can set up via the `clone` options.\r",
      "\r",
      "For example, using [structuredClone](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone):\r",
      "\r",
      "```ts\r",
      "import { useManualRefHistory } from '@vueuse/core'\r",
      "\r",
      "const refHistory = useManualRefHistory(target, { clone: structuredClone })\r",
      "```\r",
      "\r",
      "Or by using [lodash's `cloneDeep`](https://lodash.com/docs/4.17.15#cloneDeep):\r",
      "\r",
      "```ts\r",
      "import { cloneDeep } from 'lodash-es'\r",
      "import { useManualRefHistory } from '@vueuse/core'\r",
      "\r",
      "const refHistory = useManualRefHistory(target, { clone: cloneDeep })\r",
      "```\r",
      "\r",
      "Or a more lightweight [`klona`](https://github.com/lukeed/klona):\r",
      "\r",
      "```ts\r",
      "import { klona } from 'klona'\r",
      "import { useManualRefHistory } from '@vueuse/core'\r",
      "\r",
      "const refHistory = useManualRefHistory(target, { clone: klona })\r",
      "```\r",
      "\r",
      "#### Custom Dump and Parse Function\r",
      "\r",
      "Instead of using the `clone` options, you can pass custom functions to control the serialization and parsing. In case you do not need history values to be objects, this can save an extra clone when undoing. It is also useful in case you want to have the snapshots already stringified to be saved to local storage for example.\r",
      "\r",
      "```ts\r",
      "import { useManualRefHistory } from '@vueuse/core'\r",
      "\r",
      "const refHistory = useManualRefHistory(target, {\r",
      "  dump: JSON.stringify,\r",
      "  parse: JSON.parse,\r",
      "})\r",
      "```\r",
      "\r",
      "### History Capacity\r",
      "\r",
      "We will keep all the history by default (unlimited) until you explicitly clear them up, you can set the maximal amount of history to be kept by `capacity` options.\r",
      "\r",
      "```ts\r",
      "const refHistory = useManualRefHistory(target, {\r",
      "  capacity: 15, // limit to 15 history records\r",
      "})\r",
      "\r",
      "refHistory.clear() // explicitly clear all the history\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { timestamp } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { computed, markRaw, ref } from 'vue-demi'\r",
      "import type { CloneFn } from '../useCloned'\r",
      "import { cloneFnJSON } from '../useCloned'\r",
      "\r",
      "export interface UseRefHistoryRecord<T> {\r",
      "  snapshot: T\r",
      "  timestamp: number\r",
      "}\r",
      "\r",
      "export interface UseManualRefHistoryOptions<Raw, Serialized = Raw> {\r",
      "  /**\r",
      "   * Maximum number of history to be kept. Default to unlimited.\r",
      "   */\r",
      "  capacity?: number\r",
      "  /**\r",
      "   * Clone when taking a snapshot, shortcut for dump: JSON.parse(JSON.stringify(value)).\r",
      "   * Default to false\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  clone?: boolean | CloneFn<Raw>\r",
      "  /**\r",
      "   * Serialize data into the history\r",
      "   */\r",
      "  dump?: (v: Raw) => Serialized\r",
      "  /**\r",
      "   * Deserialize data from the history\r",
      "   */\r",
      "  parse?: (v: Serialized) => Raw\r",
      "\r",
      "  /**\r",
      "   * set data source\r",
      "   */\r",
      "  setSource?: (source: Ref<Raw>, v: Raw) => void\r",
      "}\r",
      "\r",
      "export interface UseManualRefHistoryReturn<Raw, Serialized> {\r",
      "  /**\r",
      "   * Bypassed tracking ref from the argument\r",
      "   */\r",
      "  source: Ref<Raw>\r",
      "\r",
      "  /**\r",
      "   * An array of history records for undo, newest comes to first\r",
      "   */\r",
      "  history: Ref<UseRefHistoryRecord<Serialized>[]>\r",
      "\r",
      "  /**\r",
      "   * Last history point, source can be different if paused\r",
      "   */\r",
      "  last: Ref<UseRefHistoryRecord<Serialized>>\r",
      "\r",
      "  /**\r",
      "   * Same as {@link UseManualRefHistoryReturn.history | history}\r",
      "   */\r",
      "  undoStack: Ref<UseRefHistoryRecord<Serialized>[]>\r",
      "\r",
      "  /**\r",
      "   * Records array for redo\r",
      "   */\r",
      "  redoStack: Ref<UseRefHistoryRecord<Serialized>[]>\r",
      "\r",
      "  /**\r",
      "   * A ref representing if undo is possible (non empty undoStack)\r",
      "   */\r",
      "  canUndo: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * A ref representing if redo is possible (non empty redoStack)\r",
      "   */\r",
      "  canRedo: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * Undo changes\r",
      "   */\r",
      "  undo: () => void\r",
      "\r",
      "  /**\r",
      "   * Redo changes\r",
      "   */\r",
      "  redo: () => void\r",
      "\r",
      "  /**\r",
      "   * Clear all the history\r",
      "   */\r",
      "  clear: () => void\r",
      "\r",
      "  /**\r",
      "   * Create a new history record\r",
      "   */\r",
      "  commit: () => void\r",
      "\r",
      "  /**\r",
      "   * Reset ref's value with latest history\r",
      "   */\r",
      "  reset: () => void\r",
      "}\r",
      "\r",
      "function fnBypass<F, T>(v: F) {\r",
      "  return v as unknown as T\r",
      "}\r",
      "function fnSetSource<F>(source: Ref<F>, value: F) {\r",
      "  return source.value = value\r",
      "}\r",
      "\r",
      "type FnCloneOrBypass<F, T> = (v: F) => T\r",
      "\r",
      "function defaultDump<R, S>(clone?: boolean | CloneFn<R>) {\r",
      "  return (clone\r",
      "    ? typeof clone === 'function'\r",
      "      ? clone\r",
      "      : cloneFnJSON\r",
      "    : fnBypass\r",
      "  ) as unknown as FnCloneOrBypass<R, S>\r",
      "}\r",
      "\r",
      "function defaultParse<R, S>(clone?: boolean | CloneFn<R>) {\r",
      "  return (clone\r",
      "    ? typeof clone === 'function'\r",
      "      ? clone\r",
      "      : cloneFnJSON\r",
      "    : fnBypass\r",
      "  ) as unknown as FnCloneOrBypass<S, R>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Track the change history of a ref, also provides undo and redo functionality.\r",
      " *\r",
      " * @see https://vueuse.org/useManualRefHistory\r",
      " * @param source\r",
      " * @param options\r",
      " */\r",
      "export function useManualRefHistory<Raw, Serialized = Raw>(\r",
      "  source: Ref<Raw>,\r",
      "  options: UseManualRefHistoryOptions<Raw, Serialized> = {},\r",
      "): UseManualRefHistoryReturn<Raw, Serialized> {\r",
      "  const {\r",
      "    clone = false,\r",
      "    dump = defaultDump<Raw, Serialized>(clone),\r",
      "    parse = defaultParse<Raw, Serialized>(clone),\r",
      "    setSource = fnSetSource,\r",
      "  } = options\r",
      "\r",
      "  function _createHistoryRecord(): UseRefHistoryRecord<Serialized> {\r",
      "    return markRaw({\r",
      "      snapshot: dump(source.value),\r",
      "      timestamp: timestamp(),\r",
      "    })\r",
      "  }\r",
      "\r",
      "  const last: Ref<UseRefHistoryRecord<Serialized>> = ref(_createHistoryRecord()) as Ref<UseRefHistoryRecord<Serialized>>\r",
      "\r",
      "  const undoStack: Ref<UseRefHistoryRecord<Serialized>[]> = ref([])\r",
      "  const redoStack: Ref<UseRefHistoryRecord<Serialized>[]> = ref([])\r",
      "\r",
      "  const _setSource = (record: UseRefHistoryRecord<Serialized>) => {\r",
      "    setSource(source, parse(record.snapshot))\r",
      "    last.value = record\r",
      "  }\r",
      "\r",
      "  const commit = () => {\r",
      "    undoStack.value.unshift(last.value)\r",
      "    last.value = _createHistoryRecord()\r",
      "\r",
      "    if (options.capacity && undoStack.value.length > options.capacity)\r",
      "      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY)\r",
      "    if (redoStack.value.length)\r",
      "      redoStack.value.splice(0, redoStack.value.length)\r",
      "  }\r",
      "\r",
      "  const clear = () => {\r",
      "    undoStack.value.splice(0, undoStack.value.length)\r",
      "    redoStack.value.splice(0, redoStack.value.length)\r",
      "  }\r",
      "\r",
      "  const undo = () => {\r",
      "    const state = undoStack.value.shift()\r",
      "\r",
      "    if (state) {\r",
      "      redoStack.value.unshift(last.value)\r",
      "      _setSource(state)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const redo = () => {\r",
      "    const state = redoStack.value.shift()\r",
      "\r",
      "    if (state) {\r",
      "      undoStack.value.unshift(last.value)\r",
      "      _setSource(state)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const reset = () => {\r",
      "    _setSource(last.value)\r",
      "  }\r",
      "\r",
      "  const history = computed(() => [last.value, ...undoStack.value])\r",
      "\r",
      "  const canUndo = computed(() => undoStack.value.length > 0)\r",
      "  const canRedo = computed(() => redoStack.value.length > 0)\r",
      "\r",
      "  return {\r",
      "    source,\r",
      "    undoStack,\r",
      "    redoStack,\r",
      "    last,\r",
      "    history,\r",
      "    canUndo,\r",
      "    canRedo,\r",
      "\r",
      "    clear,\r",
      "    commit,\r",
      "    reset,\r",
      "    undo,\r",
      "    redo,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useCounter } from '@vueuse/shared'\r",
      "import { formatDate, useManualRefHistory } from '@vueuse/core'\r",
      "\r",
      "function format(ts: number) {\r",
      "  return formatDate(new Date(ts), 'YYYY-MM-DD HH:mm:ss')\r",
      "}\r",
      "\r",
      "const { inc, dec, count } = useCounter()\r",
      "const { canUndo, canRedo, history, commit, undo, redo } = useManualRefHistory(count, { capacity: 10 })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Count: {{ count }}</div>\r",
      "  <button @click=\"inc()\">\r",
      "    Increment\r",
      "  </button>\r",
      "  <button @click=\"dec()\">\r",
      "    Decrement\r",
      "  </button>\r",
      "  <span class=\"ml-2\">/</span>\r",
      "  <button @click=\"commit()\">\r",
      "    Commit\r",
      "  </button>\r",
      "  <button :disabled=\"!canUndo\" @click=\"undo()\">\r",
      "    Undo\r",
      "  </button>\r",
      "  <button :disabled=\"!canRedo\" @click=\"redo()\">\r",
      "    Redo\r",
      "  </button>\r",
      "  <br>\r",
      "  <br>\r",
      "  <note>History (limited to 10 records for demo)</note>\r",
      "  <div class=\"code-block mt-4\">\r",
      "    <div v-for=\"i in history\" :key=\"i.timestamp\">\r",
      "      <span class=\"opacity-50 mr-2 font-mono\">{{ format(i.timestamp) }}</span>\r",
      "      <span class=\"font-mono\">{ value: {{ i.snapshot }} }</span>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMediaControls - vueuse": {
    "prefix": "hvue useMediaControls - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useMediaControls\r",
      "\r",
      "Reactive media controls for both `audio` and `video` elements\r",
      "\r",
      "## Usage\r",
      "\r",
      "### Basic Usage\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { onMounted, ref } from 'vue'\r",
      "import { useMediaControls } from '@vueuse/core'\r",
      "\r",
      "const video = ref()\r",
      "const { playing, currentTime, duration, volume } = useMediaControls(video, { \r",
      "  src: 'video.mp4',\r",
      "})\r",
      "\r",
      "// Change initial media properties\r",
      "onMounted(() => {\r",
      "  volume.value = 0.5\r",
      "  currentTime.value = 60\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <video ref=\"video\" />\r",
      "  <button @click=\"playing = !playing\">Play / Pause</button>\r",
      "  <span>{{ currentTime }} / {{ duration }}</span>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Providing Captions, Subtitles, etc...\r",
      "You can provide captions, subtitles, etc in the `tracks` options of the\r",
      "`useMediaControls` function. The function will return an array of tracks\r",
      "along with two functions for controlling them, `enableTrack`, `disableTrack`, and `selectedTrack`.\r",
      "Using these you can manage the currently selected track. `selectedTrack` will\r",
      "be `-1` if there is no selected track.\r",
      "\r",
      "```html\r",
      "\r",
      "<script setup lang=\"ts\">\r",
      "import { useMediaControls } from '@vueuse/core'\r",
      "import { ref } from 'vue'\r",
      "  const video = ref()\r",
      "  const {\r",
      "    tracks,\r",
      "    enableTrack\r",
      "  } = useMediaControls(video, {\r",
      "    src: 'video.mp4',\r",
      "    tracks: [\r",
      "      {\r",
      "        default: true,\r",
      "        src: './subtitles.vtt',\r",
      "        kind: 'subtitles',\r",
      "        label: 'English',\r",
      "        srcLang: 'en',\r",
      "      },\r",
      "    ]\r",
      "  })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <video ref=\"video\" />\r",
      "  <button v-for=\"track in tracks\" :key=\"track.id\" @click=\"enableTrack(track)\">\r",
      "    {{ track.label }}\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref, watch, watchEffect } from 'vue-demi'\r",
      "import type { Fn, MaybeRef, MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { createEventHook, isObject, toValue, tryOnScopeDispose, watchIgnorable } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Many of the jsdoc definitions here are modified version of the\r",
      " * documentation from MDN(https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)\r",
      " */\r",
      "\r",
      "export interface UseMediaSource {\r",
      "  /**\r",
      "   * The source url for the media\r",
      "   */\r",
      "  src: string\r",
      "\r",
      "  /**\r",
      "   * The media codec type\r",
      "   */\r",
      "  type?: string\r",
      "}\r",
      "\r",
      "export interface UseMediaTextTrackSource {\r",
      "  /**\r",
      "   * Indicates that the track should be enabled unless the user's preferences indicate\r",
      "   * that another track is more appropriate\r",
      "   */\r",
      "  default?: boolean\r",
      "\r",
      "  /**\r",
      "   * How the text track is meant to be used. If omitted the default kind is subtitles.\r",
      "   */\r",
      "  kind: TextTrackKind\r",
      "\r",
      "  /**\r",
      "   * A user-readable title of the text track which is used by the browser\r",
      "   * when listing available text tracks.\r",
      "   */\r",
      "  label: string\r",
      "\r",
      "  /**\r",
      "   * Address of the track (.vtt file). Must be a valid URL. This attribute\r",
      "   * must be specified and its URL value must have the same origin as the document\r",
      "   */\r",
      "  src: string\r",
      "\r",
      "  /**\r",
      "   * Language of the track text data. It must be a valid BCP 47 language tag.\r",
      "   * If the kind attribute is set to subtitles, then srclang must be defined.\r",
      "   */\r",
      "  srcLang: string\r",
      "}\r",
      "\r",
      "interface UseMediaControlsOptions extends ConfigurableDocument {\r",
      "  /**\r",
      "   * The source for the media, may either be a string, a `UseMediaSource` object, or a list\r",
      "   * of `UseMediaSource` objects.\r",
      "   */\r",
      "  src?: MaybeRefOrGetter<string | UseMediaSource | UseMediaSource[]>\r",
      "\r",
      "  /**\r",
      "   * A list of text tracks for the media\r",
      "   */\r",
      "  tracks?: MaybeRefOrGetter<UseMediaTextTrackSource[]>\r",
      "}\r",
      "\r",
      "export interface UseMediaTextTrack {\r",
      "  /**\r",
      "   * The index of the text track\r",
      "   */\r",
      "  id: number\r",
      "\r",
      "  /**\r",
      "   * The text track label\r",
      "   */\r",
      "  label: string\r",
      "\r",
      "  /**\r",
      "   * Language of the track text data. It must be a valid BCP 47 language tag.\r",
      "   * If the kind attribute is set to subtitles, then srclang must be defined.\r",
      "   */\r",
      "  language: string\r",
      "\r",
      "  /**\r",
      "   * Specifies the display mode of the text track, either `disabled`,\r",
      "   * `hidden`, or `showing`\r",
      "   */\r",
      "  mode: TextTrackMode\r",
      "\r",
      "  /**\r",
      "   * How the text track is meant to be used. If omitted the default kind is subtitles.\r",
      "   */\r",
      "  kind: TextTrackKind\r",
      "\r",
      "  /**\r",
      "   * Indicates the track's in-band metadata track dispatch type.\r",
      "   */\r",
      "  inBandMetadataTrackDispatchType: string\r",
      "\r",
      "  /**\r",
      "   * A list of text track cues\r",
      "   */\r",
      "  cues: TextTrackCueList | null\r",
      "\r",
      "  /**\r",
      "   * A list of active text track cues\r",
      "   */\r",
      "  activeCues: TextTrackCueList | null\r",
      "}\r",
      "\r",
      "/**\r",
      " * Automatically check if the ref exists and if it does run the cb fn\r",
      " */\r",
      "function usingElRef<T = any>(source: MaybeRefOrGetter<any>, cb: (el: T) => void) {\r",
      "  if (toValue(source))\r",
      "    cb(toValue(source))\r",
      "}\r",
      "\r",
      "/**\r",
      " * Converts a TimeRange object to an array\r",
      " */\r",
      "function timeRangeToArray(timeRanges: TimeRanges) {\r",
      "  let ranges: [number, number][] = []\r",
      "\r",
      "  for (let i = 0; i < timeRanges.length; ++i)\r",
      "    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]]\r",
      "\r",
      "  return ranges\r",
      "}\r",
      "\r",
      "/**\r",
      " * Converts a TextTrackList object to an array of `UseMediaTextTrack`\r",
      " */\r",
      "function tracksToArray(tracks: TextTrackList): UseMediaTextTrack[] {\r",
      "  return Array.from(tracks)\r",
      "    .map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) =>\r",
      "      ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }))\r",
      "}\r",
      "\r",
      "const defaultOptions: UseMediaControlsOptions = {\r",
      "  src: '',\r",
      "  tracks: [],\r",
      "}\r",
      "\r",
      "export function useMediaControls(target: MaybeRef<HTMLMediaElement | null | undefined>, options: UseMediaControlsOptions = {}) {\r",
      "  options = {\r",
      "    ...defaultOptions,\r",
      "    ...options,\r",
      "  }\r",
      "\r",
      "  const {\r",
      "    document = defaultDocument,\r",
      "  } = options\r",
      "\r",
      "  const currentTime = ref(0)\r",
      "  const duration = ref(0)\r",
      "  const seeking = ref(false)\r",
      "  const volume = ref(1)\r",
      "  const waiting = ref(false)\r",
      "  const ended = ref(false)\r",
      "  const playing = ref(false)\r",
      "  const rate = ref(1)\r",
      "  const stalled = ref(false)\r",
      "  const buffered = ref<[number, number][]>([])\r",
      "  const tracks = ref<UseMediaTextTrack[]>([])\r",
      "  const selectedTrack = ref<number>(-1)\r",
      "  const isPictureInPicture = ref(false)\r",
      "  const muted = ref(false)\r",
      "\r",
      "  const supportsPictureInPicture = document && 'pictureInPictureEnabled' in document\r",
      "\r",
      "  // Events\r",
      "  const sourceErrorEvent = createEventHook<Event>()\r",
      "\r",
      "  /**\r",
      "   * Disables the specified track. If no track is specified then\r",
      "   * all tracks will be disabled\r",
      "   *\r",
      "   * @param track The id of the track to disable\r",
      "   */\r",
      "  const disableTrack = (track?: number | UseMediaTextTrack) => {\r",
      "    usingElRef<HTMLMediaElement>(target, (el) => {\r",
      "      if (track) {\r",
      "        const id = typeof track === 'number' ? track : track.id\r",
      "        el.textTracks[id].mode = 'disabled'\r",
      "      }\r",
      "      else {\r",
      "        for (let i = 0; i < el.textTracks.length; ++i)\r",
      "          el.textTracks[i].mode = 'disabled'\r",
      "      }\r",
      "\r",
      "      selectedTrack.value = -1\r",
      "    })\r",
      "  }\r",
      "\r",
      "  /**\r",
      "   * Enables the specified track and disables the\r",
      "   * other tracks unless otherwise specified\r",
      "   *\r",
      "   * @param track The track of the id of the track to enable\r",
      "   * @param disableTracks Disable all other tracks\r",
      "   */\r",
      "  const enableTrack = (track: number | UseMediaTextTrack, disableTracks = true) => {\r",
      "    usingElRef<HTMLMediaElement>(target, (el) => {\r",
      "      const id = typeof track === 'number' ? track : track.id\r",
      "\r",
      "      if (disableTracks)\r",
      "        disableTrack()\r",
      "\r",
      "      el.textTracks[id].mode = 'showing'\r",
      "      selectedTrack.value = id\r",
      "    })\r",
      "  }\r",
      "  /**\r",
      "   * Toggle picture in picture mode for the player.\r",
      "   */\r",
      "  const togglePictureInPicture = () => {\r",
      "    return new Promise((resolve, reject) => {\r",
      "      usingElRef<HTMLVideoElement>(target, async (el) => {\r",
      "        if (supportsPictureInPicture) {\r",
      "          if (!isPictureInPicture.value) {\r",
      "            (el as any).requestPictureInPicture()\r",
      "              .then(resolve)\r",
      "              .catch(reject)\r",
      "          }\r",
      "          else {\r",
      "            (document as any).exitPictureInPicture()\r",
      "              .then(resolve)\r",
      "              .catch(reject)\r",
      "          }\r",
      "        }\r",
      "      })\r",
      "    })\r",
      "  }\r",
      "\r",
      "  /**\r",
      "   * This will automatically inject sources to the media element. The sources will be\r",
      "   * appended as children to the media element as `<source>` elements.\r",
      "   */\r",
      "  watchEffect(() => {\r",
      "    if (!document)\r",
      "      return\r",
      "\r",
      "    const el = toValue(target)\r",
      "    if (!el)\r",
      "      return\r",
      "\r",
      "    const src = toValue(options.src)\r",
      "    let sources: UseMediaSource[] = []\r",
      "\r",
      "    if (!src)\r",
      "      return\r",
      "\r",
      "    // Merge sources into an array\r",
      "    if (typeof src === 'string')\r",
      "      sources = [{ src }]\r",
      "    else if (Array.isArray(src))\r",
      "      sources = src\r",
      "    else if (isObject(src))\r",
      "      sources = [src]\r",
      "\r",
      "    // Clear the sources\r",
      "    el.querySelectorAll('source').forEach((e) => {\r",
      "      e.removeEventListener('error', sourceErrorEvent.trigger)\r",
      "      e.remove()\r",
      "    })\r",
      "\r",
      "    // Add new sources\r",
      "    sources.forEach(({ src, type }) => {\r",
      "      const source = document.createElement('source')\r",
      "\r",
      "      source.setAttribute('src', src)\r",
      "      source.setAttribute('type', type || '')\r",
      "\r",
      "      source.addEventListener('error', sourceErrorEvent.trigger)\r",
      "\r",
      "      el.appendChild(source)\r",
      "    })\r",
      "\r",
      "    // Finally, load the new sources.\r",
      "    el.load()\r",
      "  })\r",
      "\r",
      "  // Remove source error listeners\r",
      "  tryOnScopeDispose(() => {\r",
      "    const el = toValue(target)\r",
      "    if (!el)\r",
      "      return\r",
      "\r",
      "    el.querySelectorAll('source').forEach(e => e.removeEventListener('error', sourceErrorEvent.trigger))\r",
      "  })\r",
      "\r",
      "  /**\r",
      "   * Apply composable state to the element, also when element is changed\r",
      "   */\r",
      "  watch([target, volume], () => {\r",
      "    const el = toValue(target)\r",
      "    if (!el)\r",
      "      return\r",
      "\r",
      "    el.volume = volume.value\r",
      "  })\r",
      "\r",
      "  watch([target, muted], () => {\r",
      "    const el = toValue(target)\r",
      "    if (!el)\r",
      "      return\r",
      "\r",
      "    el.muted = muted.value\r",
      "  })\r",
      "\r",
      "  watch([target, rate], () => {\r",
      "    const el = toValue(target)\r",
      "    if (!el)\r",
      "      return\r",
      "\r",
      "    el.playbackRate = rate.value\r",
      "  })\r",
      "\r",
      "  /**\r",
      "   * Load Tracks\r",
      "   */\r",
      "  watchEffect(() => {\r",
      "    if (!document)\r",
      "      return\r",
      "\r",
      "    const textTracks = toValue(options.tracks)\r",
      "    const el = toValue(target)\r",
      "\r",
      "    if (!textTracks || !textTracks.length || !el)\r",
      "      return\r",
      "\r",
      "    /**\r",
      "     * The MediaAPI provides an API for adding text tracks, but they don't currently\r",
      "     * have an API for removing text tracks, so instead we will just create and remove\r",
      "     * the tracks manually using the HTML api.\r",
      "     */\r",
      "    el.querySelectorAll('track').forEach(e => e.remove())\r",
      "\r",
      "    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\r",
      "      const track = document.createElement('track')\r",
      "\r",
      "      track.default = isDefault || false\r",
      "      track.kind = kind\r",
      "      track.label = label\r",
      "      track.src = src\r",
      "      track.srclang = srcLang\r",
      "\r",
      "      if (track.default)\r",
      "        selectedTrack.value = i\r",
      "\r",
      "      el.appendChild(track)\r",
      "    })\r",
      "  })\r",
      "\r",
      "  /**\r",
      "   * This will allow us to update the current time from the timeupdate event\r",
      "   * without setting the medias current position, but if the user changes the\r",
      "   * current time via the ref, then the media will seek.\r",
      "   *\r",
      "   * If we did not use an ignorable watch, then the current time update from\r",
      "   * the timeupdate event would cause the media to stutter.\r",
      "   */\r",
      "  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\r",
      "    const el = toValue(target)\r",
      "    if (!el)\r",
      "      return\r",
      "\r",
      "    el.currentTime = time\r",
      "  })\r",
      "\r",
      "  /**\r",
      "   * Using an ignorable watch so we can control the play state using a ref and not\r",
      "   * a function\r",
      "   */\r",
      "  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\r",
      "    const el = toValue(target)\r",
      "    if (!el)\r",
      "      return\r",
      "\r",
      "    isPlaying ? el.play() : el.pause()\r",
      "  })\r",
      "\r",
      "  useEventListener(target, 'timeupdate', () => ignoreCurrentTimeUpdates(() => currentTime.value = (toValue(target))!.currentTime))\r",
      "  useEventListener(target, 'durationchange', () => duration.value = (toValue(target))!.duration)\r",
      "  useEventListener(target, 'progress', () => buffered.value = timeRangeToArray((toValue(target))!.buffered))\r",
      "  useEventListener(target, 'seeking', () => seeking.value = true)\r",
      "  useEventListener(target, 'seeked', () => seeking.value = false)\r",
      "  useEventListener(target, ['waiting', 'loadstart'], () => {\r",
      "    waiting.value = true\r",
      "    ignorePlayingUpdates(() => playing.value = false)\r",
      "  })\r",
      "  useEventListener(target, 'loadeddata', () => waiting.value = false)\r",
      "  useEventListener(target, 'playing', () => {\r",
      "    waiting.value = false\r",
      "    ended.value = false\r",
      "    ignorePlayingUpdates(() => playing.value = true)\r",
      "  })\r",
      "  useEventListener(target, 'ratechange', () => rate.value = (toValue(target))!.playbackRate)\r",
      "  useEventListener(target, 'stalled', () => stalled.value = true)\r",
      "  useEventListener(target, 'ended', () => ended.value = true)\r",
      "  useEventListener(target, 'pause', () => ignorePlayingUpdates(() => playing.value = false))\r",
      "  useEventListener(target, 'play', () => ignorePlayingUpdates(() => playing.value = true))\r",
      "  useEventListener(target, 'enterpictureinpicture', () => isPictureInPicture.value = true)\r",
      "  useEventListener(target, 'leavepictureinpicture', () => isPictureInPicture.value = false)\r",
      "  useEventListener(target, 'volumechange', () => {\r",
      "    const el = toValue(target)\r",
      "    if (!el)\r",
      "      return\r",
      "\r",
      "    volume.value = el.volume\r",
      "    muted.value = el.muted\r",
      "  })\r",
      "\r",
      "  /**\r",
      "   * The following listeners need to listen to a nested\r",
      "   * object on the target, so we will have to use a nested\r",
      "   * watch and manually remove the listeners\r",
      "   */\r",
      "  const listeners: Fn[] = []\r",
      "\r",
      "  const stop = watch([target], () => {\r",
      "    const el = toValue(target)\r",
      "    if (!el)\r",
      "      return\r",
      "\r",
      "    stop()\r",
      "\r",
      "    listeners[0] = useEventListener(el.textTracks, 'addtrack', () => tracks.value = tracksToArray(el.textTracks))\r",
      "    listeners[1] = useEventListener(el.textTracks, 'removetrack', () => tracks.value = tracksToArray(el.textTracks))\r",
      "    listeners[2] = useEventListener(el.textTracks, 'change', () => tracks.value = tracksToArray(el.textTracks))\r",
      "  })\r",
      "\r",
      "  // Remove text track listeners\r",
      "  tryOnScopeDispose(() => listeners.forEach(listener => listener()))\r",
      "\r",
      "  return {\r",
      "    currentTime,\r",
      "    duration,\r",
      "    waiting,\r",
      "    seeking,\r",
      "    ended,\r",
      "    stalled,\r",
      "    buffered,\r",
      "    playing,\r",
      "    rate,\r",
      "\r",
      "    // Volume\r",
      "    volume,\r",
      "    muted,\r",
      "\r",
      "    // Tracks\r",
      "    tracks,\r",
      "    selectedTrack,\r",
      "    enableTrack,\r",
      "    disableTrack,\r",
      "\r",
      "    // Picture in Picture\r",
      "    supportsPictureInPicture,\r",
      "    togglePictureInPicture,\r",
      "    isPictureInPicture,\r",
      "\r",
      "    // Events\r",
      "    onSourceError: sourceErrorEvent.on,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseMediaControlsReturn = ReturnType<typeof useMediaControls>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, reactive, ref } from 'vue'\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useMediaControls } from '@vueuse/core'\r",
      "import Scrubber from './components/Scrubber.vue'\r",
      "import Menu from './components/Menu.vue'\r",
      "import MenuItem from './components/MenuItem.vue'\r",
      "import Spinner from './components/Spinner.vue'\r",
      "\r",
      "const video = ref<HTMLVideoElement>()\r",
      "const loop = ref(false)\r",
      "const poster = 'https://cdn.bitmovin.com/content/assets/sintel/poster.png'\r",
      "\r",
      "const controls = useMediaControls(video, {\r",
      "  src: {\r",
      "    src: 'https://upload.wikimedia.org/wikipedia/commons/f/f1/Sintel_movie_4K.webm',\r",
      "    type: 'video/webm',\r",
      "  },\r",
      "  tracks: [\r",
      "    {\r",
      "      default: true,\r",
      "      src: 'https://gist.githubusercontent.com/wheatjs/a85a65a82d87d7c098e1a0972ef1f726/raw',\r",
      "      kind: 'subtitles',\r",
      "      label: 'English',\r",
      "      srcLang: 'en',\r",
      "    },\r",
      "    {\r",
      "      src: 'https://gist.githubusercontent.com/wheatjs/38f32925d20c683bf77ba33ff737891b/raw',\r",
      "      kind: 'subtitles',\r",
      "      label: 'French',\r",
      "      srcLang: 'fr',\r",
      "    },\r",
      "  ],\r",
      "})\r",
      "\r",
      "const {\r",
      "  playing,\r",
      "  buffered,\r",
      "  currentTime,\r",
      "  duration,\r",
      "  tracks,\r",
      "  waiting,\r",
      "  selectedTrack,\r",
      "  volume,\r",
      "  muted,\r",
      "  isPictureInPicture,\r",
      "  supportsPictureInPicture,\r",
      "  togglePictureInPicture,\r",
      "  enableTrack,\r",
      "  disableTrack,\r",
      "} = controls\r",
      "const text = stringify(reactive(controls))\r",
      "const endBuffer = computed(() => buffered.value.length > 0 ? buffered.value[buffered.value.length - 1][1] : 0)\r",
      "function formatDuration(seconds: number) {\r",
      "  return new Date(1000 * seconds).toISOString().slice(14, 19)\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div\r",
      "    class=\"outline-none\"\r",
      "    :tabindex=\"0\"\r",
      "    autofocus\r",
      "    @keydown.prevent.space=\"playing = !playing\"\r",
      "    @keydown.right=\"currentTime += 10\"\r",
      "    @keydown.left=\"currentTime -= 10\"\r",
      "  >\r",
      "    <div class=\"mt-5 relative bg-black rounded-md shadow overflow-hidden\">\r",
      "      <video\r",
      "        ref=\"video\"\r",
      "        crossorigin=\"anonymous\"\r",
      "        class=\"w-full block\"\r",
      "        :poster=\"poster\"\r",
      "        :loop=\"loop\"\r",
      "        @click=\"playing = !playing\"\r",
      "      />\r",
      "      <div\r",
      "        v-if=\"waiting\"\r",
      "        class=\"absolute inset-0 grid place-items-center pointer-events-none bg-black bg-opacity-20\"\r",
      "      >\r",
      "        <Spinner />\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <Scrubber v-model=\"currentTime\" :max=\"duration\" :secondary=\"endBuffer\" class=\"mt-2\">\r",
      "      <template #default=\"{ position, pendingValue }\">\r",
      "        <div\r",
      "          class=\"absolute transform -translate-x-1/2 bg-black rounded px-2 bottom-0 mb-4 py-1 text-xs text-white\"\r",
      "          :style=\"{ left: position }\"\r",
      "        >\r",
      "          {{ formatDuration(pendingValue) }}\r",
      "        </div>\r",
      "      </template>\r",
      "    </Scrubber>\r",
      "\r",
      "    <div class=\"flex flex-row items-center items-center\">\r",
      "      <button @click=\"playing = !playing\">\r",
      "        <i v-if=\"!playing\" inline-block align-middle i-carbon-play />\r",
      "        <i v-else i-carbon-pause inline-block align-middle />\r",
      "      </button>\r",
      "      <button @click=\"muted = !muted\">\r",
      "        <i v-if=\"muted\" i-carbon-volume-mute inline-block align-middle />\r",
      "        <i v-else i-carbon-volume-up inline-block align-middle />\r",
      "      </button>\r",
      "      <Scrubber v-model=\"volume\" :max=\"1\" class=\"w-32 ml-2\" />\r",
      "      <div\r",
      "        class=\"flex flex-col flex-1 text-sm ml-2\"\r",
      "      >\r",
      "        {{ formatDuration(currentTime) }} / {{ formatDuration(duration) }}\r",
      "      </div>\r",
      "\r",
      "      <Menu class=\"mr-2\">\r",
      "        <template #default=\"{ open }\">\r",
      "          <button @click=\"open\">\r",
      "            <i i-carbon-closed-caption inline-block align-middle />\r",
      "          </button>\r",
      "        </template>\r",
      "        <template #menu=\"{ close }\">\r",
      "          <div class=\"absolute bottom-0 right-0 bg-black rounded py-2 shadow\">\r",
      "            <MenuItem\r",
      "              @keydown.stop.prevent.enter.space=\"disableTrack()\"\r",
      "              @click=\"() => { disableTrack(); close() }\"\r",
      "            >\r",
      "              <span class=\"flex-1\">Off</span>\r",
      "              <i i-carbon-checkmark inline-block align-middle :class=\"{ 'opacity-0': selectedTrack !== -1 }\" />\r",
      "            </MenuItem>\r",
      "            <MenuItem\r",
      "              v-for=\"track in tracks\"\r",
      "              :key=\"track.id\"\r",
      "              @keydown.stop.prevent.enter.space=\"enableTrack(track)\"\r",
      "              @click=\"() => { enableTrack(track); close() }\"\r",
      "            >\r",
      "              <span class=\"flex-1\">{{ track.label }}</span>\r",
      "              <i i-carbon-checkmark inline-block align-middle :class=\"{ 'opacity-0': track.mode !== 'showing' }\" />\r",
      "            </MenuItem>\r",
      "          </div>\r",
      "        </template>\r",
      "      </Menu>\r",
      "      <Menu class=\"mr-2\">\r",
      "        <template #default=\"{ open }\">\r",
      "          <button class=\"block\" @click=\"open()\">\r",
      "            <i i-carbon-settings inline-block align-middle />\r",
      "          </button>\r",
      "        </template>\r",
      "        <template #menu=\"{ close }\">\r",
      "          <div class=\"absolute bottom-0 right-0 shadow py-2 bg-black rounded\">\r",
      "            <MenuItem\r",
      "              v-if=\"supportsPictureInPicture\"\r",
      "              @click=\"() => { togglePictureInPicture(); close(); }\"\r",
      "            >\r",
      "              <i i-carbon-popup />\r",
      "              <span>{{ isPictureInPicture ? 'Exit' : 'Enter' }} Picture in Picture</span>\r",
      "            </MenuItem>\r",
      "            <MenuItem @click=\"() => { loop = !loop; close(); }\">\r",
      "              <i i-carbon-repeat />\r",
      "              <span class=\"flex-1\">Loop</span>\r",
      "              <i v-if=\"loop\" i-carbon-checkmark />\r",
      "            </MenuItem>\r",
      "          </div>\r",
      "        </template>\r",
      "      </Menu>\r",
      "      <Menu>\r",
      "        <template #default=\"{ open }\">\r",
      "          <button class=\"block\" @click=\"open()\">\r",
      "            <i i-carbon-meter inline-block align-middle />\r",
      "          </button>\r",
      "        </template>\r",
      "        <template #menu=\"{ close }\">\r",
      "          <div class=\"absolute bottom-0 right-0 shadow py-2 bg-black rounded\">\r",
      "            <MenuItem @click=\"() => { controls.rate.value = 2; close(); }\">\r",
      "              <i i-carbon-meter-alt />2x\r",
      "            </MenuItem>\r",
      "            <MenuItem @click=\"() => { controls.rate.value = 1; close(); }\">\r",
      "              <i i-carbon-meter-alt />1x\r",
      "            </MenuItem>\r",
      "          </div>\r",
      "        </template>\r",
      "      </Menu>\r",
      "    </div>\r",
      "  </div>\r",
      "  <pre class=\"code-block\" lang=\"yaml\">{{ text }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMediaQuery - vueuse": {
    "prefix": "hvue useMediaQuery - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useMediaQuery\r",
      "\r",
      "Reactive [Media Query](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Testing_media_queries). Once you've created a MediaQueryList object, you can check the result of the query or receive notifications when the result changes.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useMediaQuery } from '@vueuse/core'\r",
      "\r",
      "const isLargeScreen = useMediaQuery('(min-width: 1024px)')\r",
      "const isPreferredDark = useMediaQuery('(prefers-color-scheme: dark)')\r",
      "```\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */\r",
      "\r",
      "import { ref, watchEffect } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "/**\r",
      " * Reactive Media Query.\r",
      " *\r",
      " * @see https://vueuse.org/useMediaQuery\r",
      " * @param query\r",
      " * @param options\r",
      " */\r",
      "export function useMediaQuery(query: MaybeRefOrGetter<string>, options: ConfigurableWindow = {}) {\r",
      "  const { window = defaultWindow } = options\r",
      "  const isSupported = useSupported(() => window && 'matchMedia' in window && typeof window.matchMedia === 'function')\r",
      "\r",
      "  let mediaQuery: MediaQueryList | undefined\r",
      "  const matches = ref(false)\r",
      "\r",
      "  const handler = (event: MediaQueryListEvent) => {\r",
      "    matches.value = event.matches\r",
      "  }\r",
      "\r",
      "  const cleanup = () => {\r",
      "    if (!mediaQuery)\r",
      "      return\r",
      "    if ('removeEventListener' in mediaQuery)\r",
      "      mediaQuery.removeEventListener('change', handler)\r",
      "    else\r",
      "      // @ts-expect-error deprecated API\r",
      "      mediaQuery.removeListener(handler)\r",
      "  }\r",
      "\r",
      "  const stopWatch = watchEffect(() => {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "\r",
      "    cleanup()\r",
      "\r",
      "    mediaQuery = window!.matchMedia(toValue(query))\r",
      "\r",
      "    if ('addEventListener' in mediaQuery)\r",
      "      mediaQuery.addEventListener('change', handler)\r",
      "    else\r",
      "      // @ts-expect-error deprecated API\r",
      "      mediaQuery.addListener(handler)\r",
      "\r",
      "    matches.value = mediaQuery.matches\r",
      "  })\r",
      "\r",
      "  tryOnScopeDispose(() => {\r",
      "    stopWatch()\r",
      "    cleanup()\r",
      "    mediaQuery = undefined\r",
      "  })\r",
      "\r",
      "  return matches\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, reactive } from 'vue'\r",
      "import YAML from 'js-yaml'\r",
      "import { useMediaQuery } from '@vueuse/core'\r",
      "\r",
      "const isLargeScreen = useMediaQuery('(min-width: 1024px)')\r",
      "const prefersDark = useMediaQuery('(prefers-color-scheme: dark)')\r",
      "\r",
      "const code = computed(() => YAML.dump(reactive({\r",
      "  isLargeScreen,\r",
      "  prefersDark,\r",
      "})))\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <pre lang=\"json\">{{ code }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMemory - vueuse": {
    "prefix": "hvue useMemory - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useMemory\r",
      "\r",
      "Reactive Memory Info.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useMemory } from '@vueuse/core'\r",
      "\r",
      "const { isSupported, memory } = useMemory()\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import type { UseIntervalFnOptions } from '@vueuse/shared'\r",
      "import { useIntervalFn } from '@vueuse/shared'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "/**\r",
      " * Performance.memory\r",
      " *\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/Performance/memory\r",
      " */\r",
      "export interface MemoryInfo {\r",
      "  /**\r",
      "   * The maximum size of the heap, in bytes, that is available to the context.\r",
      "   */\r",
      "  readonly jsHeapSizeLimit: number\r",
      "  /**\r",
      "   *  The total allocated heap size, in bytes.\r",
      "   */\r",
      "  readonly totalJSHeapSize: number\r",
      "  /**\r",
      "   * The currently active segment of JS heap, in bytes.\r",
      "   */\r",
      "  readonly usedJSHeapSize: number\r",
      "\r",
      "  [Symbol.toStringTag]: 'MemoryInfo'\r",
      "}\r",
      "\r",
      "export interface UseMemoryOptions extends UseIntervalFnOptions {\r",
      "  interval?: number\r",
      "}\r",
      "\r",
      "type PerformanceMemory = Performance & {\r",
      "  memory: MemoryInfo\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive Memory Info.\r",
      " *\r",
      " * @see https://vueuse.org/useMemory\r",
      " * @param options\r",
      " */\r",
      "export function useMemory(options: UseMemoryOptions = {}) {\r",
      "  const memory = ref<MemoryInfo>()\r",
      "  const isSupported = useSupported(() => typeof performance !== 'undefined' && 'memory' in performance)\r",
      "\r",
      "  if (isSupported.value) {\r",
      "    const { interval = 1000 } = options\r",
      "    useIntervalFn(() => {\r",
      "      memory.value = (performance as PerformanceMemory).memory\r",
      "    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback })\r",
      "  }\r",
      "\r",
      "  return { isSupported, memory }\r",
      "}\r",
      "\r",
      "export type UseMemoryReturn = ReturnType<typeof useMemory>\r",
      "```",
      "# Demo",
      "```vue",
      "<script lang=\"ts\" setup>\r",
      "import { useMemory } from '@vueuse/core'\r",
      "\r",
      "function size(v: number) {\r",
      "  const kb = v / 1024 / 1024\r",
      "  return `${kb.toFixed(2)} MB`\r",
      "}\r",
      "const { isSupported, memory } = useMemory()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div v-if=\"isSupported && memory\" class=\"inline-grid grid-cols-2 gap-x-4 gap-y-2\">\r",
      "    <template v-if=\"memory\">\r",
      "      <div opacity=\"50\">\r",
      "        Used\r",
      "      </div><div>{{ size(memory.usedJSHeapSize) }}</div>\r",
      "      <div opacity=\"50\">\r",
      "        Allocated\r",
      "      </div><div>{{ size(memory.totalJSHeapSize) }}</div>\r",
      "      <div opacity=\"50\">\r",
      "        Limit\r",
      "      </div><div>{{ size(memory.jsHeapSizeLimit) }}</div>\r",
      "    </template>\r",
      "  </div>\r",
      "  <div v-else>\r",
      "    Your browser does not support performance memory API\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMounted - vueuse": {
    "prefix": "hvue useMounted - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Component\r",
      "---\r",
      "\r",
      "# useMounted\r",
      "\r",
      "Mounted state in ref.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useMounted } from '@vueuse/core'\r",
      "\r",
      "const isMounted = useMounted()\r",
      "```\r",
      "\r",
      "Which is essentially a shorthand of:\r",
      "\r",
      "```ts\r",
      "const isMounted = ref(false)\r",
      "\r",
      "onMounted(() => {\r",
      "  isMounted.value = true\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "// eslint-disable-next-line no-restricted-imports\r",
      "import { getCurrentInstance, onMounted, ref } from 'vue-demi'\r",
      "\r",
      "/**\r",
      " * Mounted state in ref.\r",
      " *\r",
      " * @see https://vueuse.org/useMounted\r",
      " * @param options\r",
      " */\r",
      "export function useMounted() {\r",
      "  const isMounted = ref(false)\r",
      "\r",
      "  if (getCurrentInstance()) {\r",
      "    onMounted(() => {\r",
      "      isMounted.value = true\r",
      "    })\r",
      "  }\r",
      "\r",
      "  return isMounted\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useMounted } from '@vueuse/core'\r",
      "\r",
      "const isMounted = useMounted()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>{{ isMounted ? 'mounted' : 'unmounted' }}</div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMouse - vueuse": {
    "prefix": "hvue useMouse - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useMouse\r",
      "\r",
      "Reactive mouse position\r",
      "\r",
      "## Basic Usage\r",
      "\r",
      "```js\r",
      "import { useMouse } from '@vueuse/core'\r",
      "\r",
      "const { x, y, sourceType } = useMouse()\r",
      "```\r",
      "\r",
      "Touch is enabled by default. To only detect mouse changes, set `touch` to `false`.\r",
      "The `dragover` event is used to track mouse position while dragging.\r",
      "\r",
      "```js\r",
      "const { x, y } = useMouse({ touch: false })\r",
      "```\r",
      "\r",
      "## Custom Extractor\r",
      "\r",
      "It's also possible to provide a custom extractor function to get the position from the event.\r",
      "\r",
      "```js\r",
      "import { type UseMouseEventExtractor, useMouse, useParentElement } from '@vueuse/core'\r",
      "\r",
      "const parentEl = useParentElement()\r",
      "\r",
      "const extractor: UseMouseEventExtractor = event => (\r",
      "  event instanceof Touch\r",
      "    ? null\r",
      "    : [event.offsetX, event.offsetY]\r",
      ")\r",
      "\r",
      "const { x, y, sourceType } = useMouse({ target: parentEl, type: extractor })\r",
      "```\r",
      "\r",
      "Touch is enabled by default. To only detect mouse changes, set `touch` to `false`.\r",
      "The `dragover` event is used to track mouse position while dragging.\r",
      "\r",
      "```js\r",
      "const { x, y } = useMouse({ touch: false })\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseMouse v-slot=\"{ x, y }\">\r",
      "  x: {{ x }}\r",
      "  y: {{ y }}\r",
      "</UseMouse>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import type { ConfigurableEventFilter, MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import type { Position } from '../types'\r",
      "\r",
      "export type UseMouseCoordType = 'page' | 'client' | 'screen' | 'movement'\r",
      "export type UseMouseSourceType = 'mouse' | 'touch' | null\r",
      "export type UseMouseEventExtractor = (event: MouseEvent | Touch) => [x: number, y: number] | null | undefined\r",
      "\r",
      "export interface UseMouseOptions extends ConfigurableWindow, ConfigurableEventFilter {\r",
      "  /**\r",
      "   * Mouse position based by page, client, screen, or relative to previous position\r",
      "   *\r",
      "   * @default 'page'\r",
      "   */\r",
      "  type?: UseMouseCoordType | UseMouseEventExtractor\r",
      "\r",
      "  /**\r",
      "   * Listen events on `target` element\r",
      "   *\r",
      "   * @default 'Window'\r",
      "   */\r",
      "  target?: MaybeRefOrGetter<Window | EventTarget | null | undefined>\r",
      "\r",
      "  /**\r",
      "   * Listen to `touchmove` events\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  touch?: boolean\r",
      "\r",
      "  /**\r",
      "   * Reset to initial value when `touchend` event fired\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  resetOnTouchEnds?: boolean\r",
      "\r",
      "  /**\r",
      "   * Initial values\r",
      "   */\r",
      "  initialValue?: Position\r",
      "}\r",
      "\r",
      "const BuiltinExtractors: Record<UseMouseCoordType, UseMouseEventExtractor> = {\r",
      "  page: event => [event.pageX, event.pageY],\r",
      "  client: event => [event.clientX, event.clientY],\r",
      "  screen: event => [event.screenX, event.screenY],\r",
      "  movement: event => (\r",
      "    event instanceof Touch\r",
      "      ? null\r",
      "      : [event.movementX, event.movementY]\r",
      "  ),\r",
      "} as const\r",
      "\r",
      "/**\r",
      " * Reactive mouse position.\r",
      " *\r",
      " * @see https://vueuse.org/useMouse\r",
      " * @param options\r",
      " */\r",
      "export function useMouse(options: UseMouseOptions = {}) {\r",
      "  const {\r",
      "    type = 'page',\r",
      "    touch = true,\r",
      "    resetOnTouchEnds = false,\r",
      "    initialValue = { x: 0, y: 0 },\r",
      "    window = defaultWindow,\r",
      "    target = window,\r",
      "    eventFilter,\r",
      "  } = options\r",
      "\r",
      "  const x = ref(initialValue.x)\r",
      "  const y = ref(initialValue.y)\r",
      "  const sourceType = ref<UseMouseSourceType>(null)\r",
      "\r",
      "  const extractor = typeof type === 'function'\r",
      "    ? type\r",
      "    : BuiltinExtractors[type]\r",
      "\r",
      "  const mouseHandler = (event: MouseEvent) => {\r",
      "    const result = extractor(event)\r",
      "\r",
      "    if (result) {\r",
      "      [x.value, y.value] = result\r",
      "      sourceType.value = 'mouse'\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const touchHandler = (event: TouchEvent) => {\r",
      "    if (event.touches.length > 0) {\r",
      "      const result = extractor(event.touches[0])\r",
      "      if (result) {\r",
      "        [x.value, y.value] = result\r",
      "        sourceType.value = 'touch'\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const reset = () => {\r",
      "    x.value = initialValue.x\r",
      "    y.value = initialValue.y\r",
      "  }\r",
      "\r",
      "  const mouseHandlerWrapper = eventFilter\r",
      "    ? (event: MouseEvent) => eventFilter(() => mouseHandler(event), {} as any)\r",
      "    : (event: MouseEvent) => mouseHandler(event)\r",
      "\r",
      "  const touchHandlerWrapper = eventFilter\r",
      "    ? (event: TouchEvent) => eventFilter(() => touchHandler(event), {} as any)\r",
      "    : (event: TouchEvent) => touchHandler(event)\r",
      "\r",
      "  if (target) {\r",
      "    const listenerOptions = { passive: true }\r",
      "    useEventListener(target, ['mousemove', 'dragover'], mouseHandlerWrapper, listenerOptions)\r",
      "    if (touch && type !== 'movement') {\r",
      "      useEventListener(target, ['touchstart', 'touchmove'], touchHandlerWrapper, listenerOptions)\r",
      "      if (resetOnTouchEnds)\r",
      "        useEventListener(target, 'touchend', reset, listenerOptions)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    x,\r",
      "    y,\r",
      "    sourceType,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseMouseReturn = ReturnType<typeof useMouse>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { reactive } from 'vue'\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useMouse, useParentElement } from '@vueuse/core'\r",
      "import type { UseMouseEventExtractor } from '@vueuse/core'\r",
      "\r",
      "const parentEl = useParentElement()\r",
      "\r",
      "const mouseDefault = reactive(useMouse())\r",
      "const textDefault = stringify(mouseDefault)\r",
      "\r",
      "const extractor: UseMouseEventExtractor = event => (\r",
      "  event instanceof Touch\r",
      "    ? null\r",
      "    : [event.offsetX, event.offsetY]\r",
      ")\r",
      "\r",
      "const mouseWithExtractor = reactive(useMouse({ target: parentEl, type: extractor }))\r",
      "const textWithExtractor = stringify(mouseWithExtractor)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>Basic Usage</p>\r",
      "  <pre lang=\"yaml\">{{ textDefault }}</pre>\r",
      "  <p>Extractor Usage</p>\r",
      "  <pre lang=\"yaml\">{{ textWithExtractor }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMouseInElement - vueuse": {
    "prefix": "hvue useMouseInElement - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useMouseInElement\r",
      "\r",
      "Reactive mouse position related to an element\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html {15}\r",
      "<template>\r",
      "  <div ref=\"target\">\r",
      "    <h1>Hello world</h1>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<script>\r",
      "import { ref } from 'vue'\r",
      "import { useMouseInElement } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const target = ref(null)\r",
      "\r",
      "    const { x, y, isOutside } = useMouseInElement(target)\r",
      "\r",
      "    return { x, y, isOutside }\r",
      "  }\r",
      "}\r",
      "</script>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "```html\r",
      "<UseMouseInElement v-slot=\"{ elementX, elementY, isOutside }\">\r",
      "  x: {{ elementX }}\r",
      "  y: {{ elementY }}\r",
      "  Is Outside: {{ isOutside }}\r",
      "</UseMouseInElement>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref, watch } from 'vue-demi'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import type { UseMouseOptions } from '../useMouse'\r",
      "import { useMouse } from '../useMouse'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "\r",
      "export interface MouseInElementOptions extends UseMouseOptions {\r",
      "  handleOutside?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive mouse position related to an element.\r",
      " *\r",
      " * @see https://vueuse.org/useMouseInElement\r",
      " * @param target\r",
      " * @param options\r",
      " */\r",
      "export function useMouseInElement(\r",
      "  target?: MaybeElementRef,\r",
      "  options: MouseInElementOptions = {},\r",
      ") {\r",
      "  const {\r",
      "    handleOutside = true,\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "  const { x, y, sourceType } = useMouse(options)\r",
      "\r",
      "  const targetRef = ref(target ?? window?.document.body)\r",
      "  const elementX = ref(0)\r",
      "  const elementY = ref(0)\r",
      "  const elementPositionX = ref(0)\r",
      "  const elementPositionY = ref(0)\r",
      "  const elementHeight = ref(0)\r",
      "  const elementWidth = ref(0)\r",
      "  const isOutside = ref(true)\r",
      "\r",
      "  let stop = () => {}\r",
      "\r",
      "  if (window) {\r",
      "    stop = watch(\r",
      "      [targetRef, x, y],\r",
      "      () => {\r",
      "        const el = unrefElement(targetRef)\r",
      "        if (!el)\r",
      "          return\r",
      "\r",
      "        const {\r",
      "          left,\r",
      "          top,\r",
      "          width,\r",
      "          height,\r",
      "        } = el.getBoundingClientRect()\r",
      "\r",
      "        elementPositionX.value = left + window.pageXOffset\r",
      "        elementPositionY.value = top + window.pageYOffset\r",
      "        elementHeight.value = height\r",
      "        elementWidth.value = width\r",
      "\r",
      "        const elX = x.value - elementPositionX.value\r",
      "        const elY = y.value - elementPositionY.value\r",
      "        isOutside.value = width === 0 || height === 0\r",
      "          || elX < 0 || elY < 0\r",
      "          || elX > width || elY > height\r",
      "\r",
      "        if (handleOutside || !isOutside.value) {\r",
      "          elementX.value = elX\r",
      "          elementY.value = elY\r",
      "        }\r",
      "      },\r",
      "      { immediate: true },\r",
      "    )\r",
      "\r",
      "    useEventListener(document, 'mouseleave', () => {\r",
      "      isOutside.value = true\r",
      "    })\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    x,\r",
      "    y,\r",
      "    sourceType,\r",
      "    elementX,\r",
      "    elementY,\r",
      "    elementPositionX,\r",
      "    elementPositionY,\r",
      "    elementHeight,\r",
      "    elementWidth,\r",
      "    isOutside,\r",
      "    stop,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseMouseInElementReturn = ReturnType<typeof useMouseInElement>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { reactive, ref } from 'vue'\r",
      "import { useMouseInElement } from '@vueuse/core'\r",
      "import Area from './Area.vue'\r",
      "\r",
      "const target = ref(null)\r",
      "const mouse = reactive(useMouseInElement(target))\r",
      "const text = stringify(mouse)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div flex=\"~\" gap=\"4\">\r",
      "    <Area ref=\"target\" />\r",
      "    <pre lang=\"yaml\">{{ text }}</pre>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMousePressed - vueuse": {
    "prefix": "hvue useMousePressed - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useMousePressed\r",
      "\r",
      "Reactive mouse pressing state. Triggered by `mousedown` `touchstart` on target element and released by `mouseup` `mouseleave` `touchend` `touchcancel` on window.\r",
      "\r",
      "## Basic Usage\r",
      "\r",
      "```js\r",
      "import { useMousePressed } from '@vueuse/core'\r",
      "\r",
      "const { pressed } = useMousePressed()\r",
      "```\r",
      "\r",
      "Touching is enabled by default. To make it only detects mouse changes, set `touch` to `false`\r",
      "\r",
      "```js\r",
      "const { pressed } = useMousePressed({ touch: false })\r",
      "```\r",
      "\r",
      "To only capture `mousedown` and `touchstart` on specific element, you can specify `target` by passing a ref of the element. \r",
      "\r",
      "\r",
      "```html {16-20}\r",
      "<template>\r",
      "  <div ref=\"el\">\r",
      "    Only clicking on this element will trigger the update.\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<script>\r",
      "import { ref } from 'vue'\r",
      "import { useMousePressed } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const el = ref(null)\r",
      "\r",
      "    const { pressed } = useMousePressed({ target: el })\r",
      "\r",
      "    return {\r",
      "      el,\r",
      "      pressed,\r",
      "    }\r",
      "  }\r",
      "}\r",
      "</script>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseMousePressed v-slot=\"{ pressed }\">\r",
      "  Is Pressed: {{ pressed }}\r",
      "</UseMousePressed>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed, ref } from 'vue-demi'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { UseMouseSourceType } from '../useMouse'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface MousePressedOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Listen to `touchstart` `touchend` events\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  touch?: boolean\r",
      "\r",
      "  /**\r",
      "   * Listen to `dragstart` `drop` and `dragend` events\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  drag?: boolean\r",
      "\r",
      "  /**\r",
      "   * Initial values\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  initialValue?: boolean\r",
      "\r",
      "  /**\r",
      "   * Element target to be capture the click\r",
      "   */\r",
      "  target?: MaybeElementRef\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive mouse position.\r",
      " *\r",
      " * @see https://vueuse.org/useMousePressed\r",
      " * @param options\r",
      " */\r",
      "export function useMousePressed(options: MousePressedOptions = {}) {\r",
      "  const {\r",
      "    touch = true,\r",
      "    drag = true,\r",
      "    initialValue = false,\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const pressed = ref(initialValue)\r",
      "  const sourceType = ref<UseMouseSourceType>(null)\r",
      "\r",
      "  if (!window) {\r",
      "    return {\r",
      "      pressed,\r",
      "      sourceType,\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const onPressed = (srcType: UseMouseSourceType) => () => {\r",
      "    pressed.value = true\r",
      "    sourceType.value = srcType\r",
      "  }\r",
      "  const onReleased = () => {\r",
      "    pressed.value = false\r",
      "    sourceType.value = null\r",
      "  }\r",
      "\r",
      "  const target = computed(() => unrefElement(options.target) || window)\r",
      "\r",
      "  useEventListener(target, 'mousedown', onPressed('mouse'), { passive: true })\r",
      "\r",
      "  useEventListener(window, 'mouseleave', onReleased, { passive: true })\r",
      "  useEventListener(window, 'mouseup', onReleased, { passive: true })\r",
      "\r",
      "  if (drag) {\r",
      "    useEventListener(target, 'dragstart', onPressed('mouse'), { passive: true })\r",
      "\r",
      "    useEventListener(window, 'drop', onReleased, { passive: true })\r",
      "    useEventListener(window, 'dragend', onReleased, { passive: true })\r",
      "  }\r",
      "\r",
      "  if (touch) {\r",
      "    useEventListener(target, 'touchstart', onPressed('touch'), { passive: true })\r",
      "\r",
      "    useEventListener(window, 'touchend', onReleased, { passive: true })\r",
      "    useEventListener(window, 'touchcancel', onReleased, { passive: true })\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    pressed,\r",
      "    sourceType,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseMousePressedReturn = ReturnType<typeof useMousePressed>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useToggle } from '@vueuse/shared'\r",
      "import { computed, reactive, ref } from 'vue'\r",
      "import { useMousePressed } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLElement | null>()\r",
      "const [withTarget, toggle] = useToggle()\r",
      "const target = computed<HTMLElement | null>(() =>\r",
      "  (withTarget.value ? el.value : window) as HTMLElement,\r",
      ")\r",
      "\r",
      "const mouse = reactive(useMousePressed({ target }))\r",
      "const text = stringify(mouse)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\" class=\"select-none\">\r",
      "    <pre lang=\"yaml\">{{ text }}</pre>\r",
      "    <div>\r",
      "      Tracking on\r",
      "      <button class=\"ml-2 button small\" @click=\"toggle()\">\r",
      "        {{ withTarget ? 'Demo section' : 'Entire page' }}\r",
      "      </button>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMutationObserver - vueuse": {
    "prefix": "hvue useMutationObserver - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useMutationObserver\r",
      "\r",
      "Watch for changes being made to the DOM tree. [MutationObserver MDN](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { ref } from 'vue'\r",
      "import { useMutationObserver } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const el = ref(null)\r",
      "    const messages = ref([])\r",
      "\r",
      "    useMutationObserver(el, (mutations) => {\r",
      "      if (mutations[0])\r",
      "        messages.value.push(mutations[0].attributeName)\r",
      "    }, {\r",
      "      attributes: true,\r",
      "    })\r",
      "\r",
      "    return {\r",
      "      el,\r",
      "      messages,\r",
      "    }\r",
      "  },\r",
      "}\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { tryOnScopeDispose } from '@vueuse/shared'\r",
      "import { watch } from 'vue-demi'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface UseMutationObserverOptions extends MutationObserverInit, ConfigurableWindow {}\r",
      "\r",
      "/**\r",
      " * Watch for changes being made to the DOM tree.\r",
      " *\r",
      " * @see https://vueuse.org/useMutationObserver\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver MutationObserver MDN\r",
      " * @param target\r",
      " * @param callback\r",
      " * @param options\r",
      " */\r",
      "export function useMutationObserver(\r",
      "  target: MaybeElementRef,\r",
      "  callback: MutationCallback,\r",
      "  options: UseMutationObserverOptions = {},\r",
      ") {\r",
      "  const { window = defaultWindow, ...mutationOptions } = options\r",
      "  let observer: MutationObserver | undefined\r",
      "  const isSupported = useSupported(() => window && 'MutationObserver' in window)\r",
      "\r",
      "  const cleanup = () => {\r",
      "    if (observer) {\r",
      "      observer.disconnect()\r",
      "      observer = undefined\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const stopWatch = watch(\r",
      "    () => unrefElement(target),\r",
      "    (el) => {\r",
      "      cleanup()\r",
      "\r",
      "      if (isSupported.value && window && el) {\r",
      "        observer = new MutationObserver(callback)\r",
      "        observer!.observe(el, mutationOptions)\r",
      "      }\r",
      "    },\r",
      "    { immediate: true },\r",
      "  )\r",
      "\r",
      "  const stop = () => {\r",
      "    cleanup()\r",
      "    stopWatch()\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(stop)\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    stop,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseMutationObserverReturn = ReturnType<typeof useMutationObserver>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useMutationObserver } from '@vueuse/core'\r",
      "\r",
      "const el = ref(null)\r",
      "const messages = ref<string[]>([])\r",
      "const className = ref({})\r",
      "const style = ref({})\r",
      "\r",
      "useMutationObserver(\r",
      "  el,\r",
      "  (mutations) => {\r",
      "    const mutation = mutations[0]\r",
      "\r",
      "    if (!mutation)\r",
      "      return\r",
      "\r",
      "    messages.value.push(mutation.attributeName!)\r",
      "  },\r",
      "  { attributes: true },\r",
      ")\r",
      "\r",
      "setTimeout(() => {\r",
      "  className.value = {\r",
      "    test: true,\r",
      "    test2: true,\r",
      "  }\r",
      "}, 1000)\r",
      "\r",
      "setTimeout(() => {\r",
      "  style.value = {\r",
      "    color: 'red',\r",
      "  }\r",
      "}, 1550)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div ref=\"el\" :class=\"className\" :style=\"style\">\r",
      "      <div v-for=\"(text, index) of messages\" :key=\"index\">\r",
      "        Mutation Attribute: {{ text }}\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useNavigatorLanguage - vueuse": {
    "prefix": "hvue useNavigatorLanguage - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useNavigatorLanguage\r",
      "\r",
      "Reactive [navigator.language](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/language).\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { defineComponent, ref } from 'vue'\r",
      "import { useNavigatorLanguage } from '@vueuse/core'\r",
      "\r",
      "export default defineComponent({\r",
      "  setup() {\r",
      "    const { language } = useNavigatorLanguage()\r",
      "\r",
      "    watch(language, () => {\r",
      "      // Listen to the value changing\r",
      "    })\r",
      "\r",
      "    return {\r",
      "      language,\r",
      "    }\r",
      "  },\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface NavigatorLanguageState {\r",
      "  isSupported: Ref<boolean>\r",
      "  /**\r",
      "   *\r",
      "   * ISO 639-1 standard Language Code\r",
      "   *\r",
      "   * @info The detected user agent language preference as a language tag\r",
      "   * (which is sometimes referred to as a \"locale identifier\").\r",
      "   * This consists of a 2-3 letter base language tag that indicates a\r",
      "   * language, optionally followed by additional subtags separated by\r",
      "   * '-'. The most common extra information is the country or region\r",
      "   * variant (like 'en-US' or 'fr-CA').\r",
      "   *\r",
      "   *\r",
      "   * @see https://www.iso.org/iso-639-language-codes.html\r",
      "   * @see https://www.loc.gov/standards/iso639-2/php/code_list.php\r",
      "   *\r",
      "   */\r",
      "  language: Ref<string | undefined>\r",
      "}\r",
      "\r",
      "/**\r",
      " *\r",
      " * Reactive useNavigatorLanguage\r",
      " *\r",
      " * Detects the currently selected user language and returns a reactive language\r",
      " * @see https://vueuse.org/useNavigatorLanguage\r",
      " *\r",
      " */\r",
      "export function useNavigatorLanguage(options: ConfigurableWindow = {}): Readonly<NavigatorLanguageState> {\r",
      "  const { window = defaultWindow } = options\r",
      "\r",
      "  const navigator = window?.navigator\r",
      "\r",
      "  const isSupported = useSupported(() => navigator && 'language' in navigator)\r",
      "\r",
      "  const language = ref<string | undefined>(navigator?.language)\r",
      "\r",
      "  // Listen to when to user changes language:\r",
      "  useEventListener(window, 'languagechange', () => {\r",
      "    if (navigator)\r",
      "      language.value = navigator.language\r",
      "  })\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    language,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseNavigatorLanguageReturn = ReturnType<typeof useNavigatorLanguage>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useNavigatorLanguage } from '@vueuse/core'\r",
      "\r",
      "const { isSupported, language } = useNavigatorLanguage()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>\r",
      "    Supported: <BooleanDisplay :value=\"isSupported\" />\r",
      "  </p>\r",
      "  <note class=\"mb-2\">\r",
      "    Navigator Language:\r",
      "  </note>\r",
      "  <div v-if=\"isSupported\">\r",
      "    <code class=\"mr-2\">{{ language }}</code>\r",
      "  </div>\r",
      "  <div v-else>\r",
      "    The Navigator.language API is not supported in your browser.\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useNetwork - vueuse": {
    "prefix": "hvue useNetwork - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useNetwork\r",
      "\r",
      "Reactive [Network status](https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API). The Network Information API provides information about the system's connection in terms of general connection type (e.g., 'wifi', 'cellular', etc.). This can be used to select high definition content or low definition content based on the user's connection. The entire API consists of the addition of the NetworkInformation interface and a single property to the Navigator interface: Navigator.connection.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useNetwork } from '@vueuse/core'\r",
      "\r",
      "const { isOnline, offlineAt, downlink, downlinkMax, effectiveType, saveData, type } = useNetwork()\r",
      "\r",
      "console.log(isOnline.value)\r",
      "```\r",
      "\r",
      "To use as an object, wrap it with `reactive()`\r",
      "\r",
      "```js\r",
      "import { reactive } from 'vue'\r",
      "\r",
      "const network = reactive(useNetwork())\r",
      "\r",
      "console.log(network.isOnline)\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseNetwork v-slot=\"{ isOnline, type }\">\r",
      "  Is Online: {{ isOnline }}\r",
      "  Type: {{ type }}\r",
      "</UseNetwork>\r",
      "```\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */\r",
      "\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export type NetworkType = 'bluetooth' | 'cellular' | 'ethernet' | 'none' | 'wifi' | 'wimax' | 'other' | 'unknown'\r",
      "\r",
      "export type NetworkEffectiveType = 'slow-2g' | '2g' | '3g' | '4g' | undefined\r",
      "\r",
      "export interface NetworkState {\r",
      "  isSupported: Ref<boolean>\r",
      "  /**\r",
      "   * If the user is currently connected.\r",
      "   */\r",
      "  isOnline: Ref<boolean>\r",
      "  /**\r",
      "   * The time since the user was last connected.\r",
      "   */\r",
      "  offlineAt: Ref<number | undefined>\r",
      "  /**\r",
      "   * At this time, if the user is offline and reconnects\r",
      "   */\r",
      "  onlineAt: Ref<number | undefined>\r",
      "  /**\r",
      "   * The download speed in Mbps.\r",
      "   */\r",
      "  downlink: Ref<number | undefined>\r",
      "  /**\r",
      "   * The max reachable download speed in Mbps.\r",
      "   */\r",
      "  downlinkMax: Ref<number | undefined>\r",
      "  /**\r",
      "   * The detected effective speed type.\r",
      "   */\r",
      "  effectiveType: Ref<NetworkEffectiveType | undefined>\r",
      "  /**\r",
      "   * The estimated effective round-trip time of the current connection.\r",
      "   */\r",
      "  rtt: Ref<number | undefined>\r",
      "  /**\r",
      "   * If the user activated data saver mode.\r",
      "   */\r",
      "  saveData: Ref<boolean | undefined>\r",
      "  /**\r",
      "   * The detected connection/network type.\r",
      "   */\r",
      "  type: Ref<NetworkType>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive Network status.\r",
      " *\r",
      " * @see https://vueuse.org/useNetwork\r",
      " * @param options\r",
      " */\r",
      "export function useNetwork(options: ConfigurableWindow = {}): Readonly<NetworkState> {\r",
      "  const { window = defaultWindow } = options\r",
      "  const navigator = window?.navigator\r",
      "  const isSupported = useSupported(() => navigator && 'connection' in navigator)\r",
      "\r",
      "  const isOnline = ref(true)\r",
      "  const saveData = ref(false)\r",
      "  const offlineAt: Ref<number | undefined> = ref(undefined)\r",
      "  const onlineAt: Ref<number | undefined> = ref(undefined)\r",
      "  const downlink: Ref<number | undefined> = ref(undefined)\r",
      "  const downlinkMax: Ref<number | undefined> = ref(undefined)\r",
      "  const rtt: Ref<number | undefined> = ref(undefined)\r",
      "  const effectiveType: Ref<NetworkEffectiveType> = ref(undefined)\r",
      "  const type: Ref<NetworkType> = ref<NetworkType>('unknown')\r",
      "\r",
      "  const connection = isSupported.value && (navigator as any).connection\r",
      "\r",
      "  function updateNetworkInformation() {\r",
      "    if (!navigator)\r",
      "      return\r",
      "\r",
      "    isOnline.value = navigator.onLine\r",
      "    offlineAt.value = isOnline.value ? undefined : Date.now()\r",
      "    onlineAt.value = isOnline.value ? Date.now() : undefined\r",
      "\r",
      "    if (connection) {\r",
      "      downlink.value = connection.downlink\r",
      "      downlinkMax.value = connection.downlinkMax\r",
      "      effectiveType.value = connection.effectiveType\r",
      "      rtt.value = connection.rtt\r",
      "      saveData.value = connection.saveData\r",
      "      type.value = connection.type\r",
      "    }\r",
      "  }\r",
      "\r",
      "  if (window) {\r",
      "    useEventListener(window, 'offline', () => {\r",
      "      isOnline.value = false\r",
      "      offlineAt.value = Date.now()\r",
      "    })\r",
      "\r",
      "    useEventListener(window, 'online', () => {\r",
      "      isOnline.value = true\r",
      "      onlineAt.value = Date.now()\r",
      "    })\r",
      "  }\r",
      "\r",
      "  if (connection)\r",
      "    useEventListener(connection, 'change', updateNetworkInformation, false)\r",
      "\r",
      "  updateNetworkInformation()\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    isOnline,\r",
      "    saveData,\r",
      "    offlineAt,\r",
      "    onlineAt,\r",
      "    downlink,\r",
      "    downlinkMax,\r",
      "    effectiveType,\r",
      "    rtt,\r",
      "    type,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseNetworkReturn = ReturnType<typeof useNetwork>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { reactive } from 'vue'\r",
      "import { useNetwork } from '@vueuse/core'\r",
      "\r",
      "const network = reactive(useNetwork())\r",
      "const text = stringify(network)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <pre lang=\"yaml\">{{ text }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useNow - vueuse": {
    "prefix": "hvue useNow - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Animation\r",
      "---\r",
      "\r",
      "# useNow\r",
      "\r",
      "Reactive current Date instance.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useNow } from '@vueuse/core'\r",
      "\r",
      "const now = useNow()\r",
      "```\r",
      "\r",
      "```js\r",
      "const { now, pause, resume } = useNow({ controls: true })\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseNow v-slot=\"{ now, pause, resume }\">\r",
      "  Now: {{ now }}\r",
      "  <button @click=\"pause()\">Pause</button>\r",
      "  <button @click=\"resume()\">Resume</button>\r",
      "</UseNow>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Pausable } from '@vueuse/shared'\r",
      "import { useIntervalFn } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { useRafFn } from '../useRafFn'\r",
      "\r",
      "export interface UseNowOptions<Controls extends boolean> {\r",
      "  /**\r",
      "   * Expose more controls\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  controls?: Controls\r",
      "\r",
      "  /**\r",
      "   * Update interval, or use requestAnimationFrame\r",
      "   *\r",
      "   * @default requestAnimationFrame\r",
      "   */\r",
      "  interval?: 'requestAnimationFrame' | number\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive current Date instance.\r",
      " *\r",
      " * @see https://vueuse.org/useNow\r",
      " * @param options\r",
      " */\r",
      "export function useNow(options?: UseNowOptions<false>): Ref<Date>\r",
      "export function useNow(options: UseNowOptions<true>): { now: Ref<Date> } & Pausable\r",
      "export function useNow(options: UseNowOptions<boolean> = {}) {\r",
      "  const {\r",
      "    controls: exposeControls = false,\r",
      "    interval = 'requestAnimationFrame',\r",
      "  } = options\r",
      "\r",
      "  const now = ref(new Date())\r",
      "\r",
      "  const update = () => now.value = new Date()\r",
      "\r",
      "  const controls: Pausable = interval === 'requestAnimationFrame'\r",
      "    ? useRafFn(update, { immediate: true })\r",
      "    : useIntervalFn(update, interval, { immediate: true })\r",
      "\r",
      "  if (exposeControls) {\r",
      "    return {\r",
      "      now,\r",
      "      ...controls,\r",
      "    }\r",
      "  }\r",
      "  else {\r",
      "    return now\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseNowReturn = ReturnType<typeof useNow>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useNow } from '@vueuse/core'\r",
      "\r",
      "const now = useNow()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Now: {{ now }}</div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useObjectUrl - vueuse": {
    "prefix": "hvue useObjectUrl - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useObjectUrl\r",
      "\r",
      "Reactive URL representing an object.\r",
      "\r",
      "Creates an URL for the provided `File`, `Blob`, or `MediaSource` via [URL.createObjectURL()](https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL) and automatically releases the URL via [URL.revokeObjectURL()](https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL) when the source changes or the component is unmounted.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { useObjectUrl } from '@vueuse/core'\r",
      "import { shallowRef } from 'vue'\r",
      "\r",
      "const file = shallowRef()\r",
      "const url = useObjectUrl(file)\r",
      "\r",
      "const onFileChange = (event) => {\r",
      "  file.value = event.target.files[0]\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <input type=\"file\" @change=\"onFileChange\" />\r",
      "\r",
      "  <a :href=\"url\">Open file</a>\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <UseObjectUrl v-slot=\"url\" :object=\"file\">\r",
      "    <a :href=\"url\">Open file</a>\r",
      "  </UseObjectUrl>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { readonly, ref, watch } from 'vue-demi'\r",
      "import { toValue, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "\r",
      "/**\r",
      " * Reactive URL representing an object.\r",
      " *\r",
      " * @see https://vueuse.org/useObjectUrl\r",
      " * @param object\r",
      " */\r",
      "export function useObjectUrl(object: MaybeRefOrGetter<Blob | MediaSource | null | undefined>) {\r",
      "  const url = ref<string | undefined>()\r",
      "\r",
      "  const release = () => {\r",
      "    if (url.value)\r",
      "      URL.revokeObjectURL(url.value)\r",
      "\r",
      "    url.value = undefined\r",
      "  }\r",
      "\r",
      "  watch(\r",
      "    () => toValue(object),\r",
      "    (newObject) => {\r",
      "      release()\r",
      "\r",
      "      if (newObject)\r",
      "        url.value = URL.createObjectURL(newObject)\r",
      "    },\r",
      "    { immediate: true },\r",
      "  )\r",
      "\r",
      "  tryOnScopeDispose(release)\r",
      "\r",
      "  return readonly(url)\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { shallowRef } from 'vue-demi'\r",
      "import { useObjectUrl } from '@vueuse/core'\r",
      "\r",
      "const file = shallowRef()\r",
      "const url = useObjectUrl(file)\r",
      "\r",
      "function onFileChange(e: Event) {\r",
      "  const target = e.target as HTMLInputElement\r",
      "  const files = target.files\r",
      "  file.value = (files && files.length > 0) ? files[0] : undefined\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <note class=\"mb-1\">\r",
      "      Select file:\r",
      "    </note>\r",
      "    <input type=\"file\" @change=\"onFileChange\">\r",
      "\r",
      "    <note class=\"mt-4 mb-1\">\r",
      "      Object URL:\r",
      "    </note>\r",
      "    <code>\r",
      "      <a v-if=\"url\" :href=\"url\" target=\"_blank\">{{ url }}</a>\r",
      "      <span v-else>none</span>\r",
      "    </code>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useOffsetPagination - vueuse": {
    "prefix": "hvue useOffsetPagination - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useOffsetPagination\r",
      "\r",
      "Reactive offset pagination.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useOffsetPagination } from '@vueuse/core'\r",
      "\r",
      "function fetchData({ currentPage, currentPageSize }: { currentPage: number; currentPageSize: number }) {\r",
      "  fetch(currentPage, currentPageSize).then((responseData) => {\r",
      "    data.value = responseData\r",
      "  })\r",
      "}\r",
      "\r",
      "const {\r",
      "  currentPage,\r",
      "  currentPageSize,\r",
      "  pageCount,\r",
      "  isFirstPage,\r",
      "  isLastPage,\r",
      "  prev,\r",
      "  next,\r",
      "} = useOffsetPagination({\r",
      "  total: database.value.length,\r",
      "  page: 1,\r",
      "  pageSize: 10,\r",
      "  onPageChange: fetchData,\r",
      "  onPageSizeChange: fetchData,\r",
      "})\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseOffsetPagination\r",
      "  v-slot=\"{\r",
      "    currentPage,\r",
      "    currentPageSize,\r",
      "    next,\r",
      "    prev,\r",
      "    pageCount,\r",
      "    isFirstPage,\r",
      "    isLastPage\r",
      "  }\"\r",
      "  :total=\"database.length\"\r",
      "  @page-change=\"fetchData\"\r",
      "  @page-size-change=\"fetchData\"\r",
      ">\r",
      "  <div class=\"gap-x-4 gap-y-2 grid-cols-2 inline-grid items-center\">\r",
      "    <div opacity=\"50\">\r",
      "      total:\r",
      "    </div>\r",
      "    <div>{{ database.length }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      pageCount:\r",
      "    </div>\r",
      "    <div>{{ pageCount }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      currentPageSize:\r",
      "    </div>\r",
      "    <div>{{ currentPageSize }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      currentPage:\r",
      "    </div>\r",
      "    <div>{{ currentPage }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      isFirstPage:\r",
      "    </div>\r",
      "    <div>{{ isFirstPage }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      isLastPage:\r",
      "    </div>\r",
      "    <div>{{ isLastPage }}</div>\r",
      "  </div>\r",
      "  <div>\r",
      "    <button :disabled=\"isFirstPage\" @click=\"prev\">\r",
      "      prev\r",
      "    </button>\r",
      "    <button :disabled=\"isLastPage\" @click=\"next\">\r",
      "      next\r",
      "    </button>\r",
      "  </div>\r",
      "</UseOffsetPagination>\r",
      "```\r",
      "\r",
      "Component event supported props event callback and event listener.\r",
      "\r",
      "event listener:\r",
      "```html\r",
      "<UseOffsetPagination\r",
      "  v-slot=\"{\r",
      "    currentPage,\r",
      "    currentPageSize,\r",
      "    next,\r",
      "    prev,\r",
      "    pageCount,\r",
      "    isFirstPage,\r",
      "    isLastPage\r",
      "  }\"\r",
      "  :total=\"database.length\"\r",
      "  @page-change=\"fetchData\"\r",
      "  @page-size-change=\"fetchData\"\r",
      "  @page-count-change=\"onPageCountChange\"\r",
      ">\r",
      "  <!-- your code -->\r",
      "</UseOffsetPagination>\r",
      "```\r",
      "\r",
      "or props event callback:\r",
      "\r",
      "```html\r",
      "<UseOffsetPagination\r",
      "  v-slot=\"{\r",
      "    currentPage,\r",
      "    currentPageSize,\r",
      "    next,\r",
      "    prev,\r",
      "    pageCount,\r",
      "    isFirstPage,\r",
      "    isLastPage\r",
      "  }\"\r",
      "  :total=\"database.length\"\r",
      "  :on-page-change=\"fetchData\"\r",
      "  :on-page-size-change=\"fetchData\"\r",
      "  :on-page-count-change=\"onPageCountChange\"\r",
      ">\r",
      "  <!-- your code -->\r",
      "</UseOffsetPagination>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef, Ref, UnwrapNestedRefs } from 'vue-demi'\r",
      "import { computed, isRef, reactive, watch } from 'vue-demi'\r",
      "import { noop, syncRef, toValue } from '@vueuse/shared'\r",
      "import type { MaybeRef, MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { useClamp } from '../../math/useClamp'\r",
      "\r",
      "export interface UseOffsetPaginationOptions {\r",
      "  /**\r",
      "   * Total number of items.\r",
      "   */\r",
      "  total?: MaybeRefOrGetter<number>\r",
      "\r",
      "  /**\r",
      "   * The number of items to display per page.\r",
      "   * @default 10\r",
      "   */\r",
      "  pageSize?: MaybeRefOrGetter<number>\r",
      "\r",
      "  /**\r",
      "   * The current page number.\r",
      "   * @default 1\r",
      "   */\r",
      "  page?: MaybeRef<number>\r",
      "\r",
      "  /**\r",
      "   * Callback when the `page` change.\r",
      "   */\r",
      "  onPageChange?: (returnValue: UnwrapNestedRefs<UseOffsetPaginationReturn>) => unknown\r",
      "\r",
      "  /**\r",
      "   * Callback when the `pageSize` change.\r",
      "   */\r",
      "  onPageSizeChange?: (returnValue: UnwrapNestedRefs<UseOffsetPaginationReturn>) => unknown\r",
      "\r",
      "  /**\r",
      "   * Callback when the `pageCount` change.\r",
      "   */\r",
      "  onPageCountChange?: (returnValue: UnwrapNestedRefs<UseOffsetPaginationReturn>) => unknown\r",
      "}\r",
      "\r",
      "export interface UseOffsetPaginationReturn {\r",
      "  currentPage: Ref<number>\r",
      "  currentPageSize: Ref<number>\r",
      "  pageCount: ComputedRef<number>\r",
      "  isFirstPage: ComputedRef<boolean>\r",
      "  isLastPage: ComputedRef<boolean>\r",
      "  prev: () => void\r",
      "  next: () => void\r",
      "}\r",
      "\r",
      "export type UseOffsetPaginationInfinityPageReturn = Omit<UseOffsetPaginationReturn, 'isLastPage'>\r",
      "\r",
      "export function useOffsetPagination(options: Omit<UseOffsetPaginationOptions, 'total'>): UseOffsetPaginationInfinityPageReturn\r",
      "export function useOffsetPagination(options: UseOffsetPaginationOptions): UseOffsetPaginationReturn\r",
      "export function useOffsetPagination(options: UseOffsetPaginationOptions): UseOffsetPaginationReturn {\r",
      "  const {\r",
      "    total = Number.POSITIVE_INFINITY,\r",
      "    pageSize = 10,\r",
      "    page = 1,\r",
      "    onPageChange = noop,\r",
      "    onPageSizeChange = noop,\r",
      "    onPageCountChange = noop,\r",
      "  } = options\r",
      "\r",
      "  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY)\r",
      "\r",
      "  const pageCount = computed(() => Math.max(\r",
      "    1,\r",
      "    Math.ceil((toValue(total)) / toValue(currentPageSize)),\r",
      "  ))\r",
      "\r",
      "  const currentPage = useClamp(page, 1, pageCount)\r",
      "\r",
      "  const isFirstPage = computed(() => currentPage.value === 1)\r",
      "  const isLastPage = computed(() => currentPage.value === pageCount.value)\r",
      "\r",
      "  if (isRef(page))\r",
      "    syncRef(page, currentPage)\r",
      "\r",
      "  if (isRef(pageSize))\r",
      "    syncRef(pageSize, currentPageSize)\r",
      "\r",
      "  function prev() {\r",
      "    currentPage.value--\r",
      "  }\r",
      "\r",
      "  function next() {\r",
      "    currentPage.value++\r",
      "  }\r",
      "\r",
      "  const returnValue = {\r",
      "    currentPage,\r",
      "    currentPageSize,\r",
      "    pageCount,\r",
      "    isFirstPage,\r",
      "    isLastPage,\r",
      "    prev,\r",
      "    next,\r",
      "  }\r",
      "\r",
      "  watch(currentPage, () => {\r",
      "    onPageChange(reactive(returnValue))\r",
      "  })\r",
      "\r",
      "  watch(currentPageSize, () => {\r",
      "    onPageSizeChange(reactive(returnValue))\r",
      "  })\r",
      "\r",
      "  watch(pageCount, () => {\r",
      "    onPageCountChange(reactive(returnValue))\r",
      "  })\r",
      "\r",
      "  return returnValue\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import type { Ref } from 'vue'\r",
      "import { ref } from 'vue'\r",
      "import { useOffsetPagination } from '@vueuse/core'\r",
      "\r",
      "interface User {\r",
      "  id: number\r",
      "  name: string\r",
      "}\r",
      "const database = ref([]) as Ref<User[]>\r",
      "\r",
      "for (let i = 0; i < 80; i++)\r",
      "  database.value.push({ id: i, name: `user ${i}` })\r",
      "\r",
      "function fetch(page: number, pageSize: number) {\r",
      "  return new Promise<User[]>((resolve, reject) => {\r",
      "    const start = (page - 1) * pageSize\r",
      "    const end = start + pageSize\r",
      "    setTimeout(() => {\r",
      "      resolve(database.value.slice(start, end))\r",
      "    }, 100)\r",
      "  })\r",
      "}\r",
      "\r",
      "const data: Ref<User[]> = ref([])\r",
      "\r",
      "const page = ref(1)\r",
      "const pageSize = ref(10)\r",
      "\r",
      "fetchData({\r",
      "  currentPage: page.value,\r",
      "  currentPageSize: pageSize.value,\r",
      "})\r",
      "\r",
      "function fetchData({ currentPage, currentPageSize }: { currentPage: number; currentPageSize: number }) {\r",
      "  fetch(currentPage, currentPageSize).then((responseData) => {\r",
      "    data.value = responseData\r",
      "  })\r",
      "}\r",
      "\r",
      "const {\r",
      "  currentPage,\r",
      "  currentPageSize,\r",
      "  pageCount,\r",
      "  isFirstPage,\r",
      "  isLastPage,\r",
      "  prev,\r",
      "  next,\r",
      "} = useOffsetPagination({\r",
      "  total: database.value.length,\r",
      "  page: 1,\r",
      "  pageSize,\r",
      "  onPageChange: fetchData,\r",
      "  onPageSizeChange: fetchData,\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"gap-x-4 gap-y-2 grid-cols-2 inline-grid items-center\">\r",
      "    <div opacity=\"50\">\r",
      "      total:\r",
      "    </div>\r",
      "    <div>{{ database.length }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      pageCount:\r",
      "    </div>\r",
      "    <div>{{ pageCount }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      currentPageSize:\r",
      "    </div>\r",
      "    <div>{{ currentPageSize }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      currentPage:\r",
      "    </div>\r",
      "    <div>{{ currentPage }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      isFirstPage:\r",
      "    </div>\r",
      "    <div>{{ isFirstPage }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      isLastPage:\r",
      "    </div>\r",
      "    <div>{{ isLastPage }}</div>\r",
      "  </div>\r",
      "  <div class=\"my-4\">\r",
      "    <button :disabled=\"isFirstPage\" @click=\"prev\">\r",
      "      prev\r",
      "    </button>\r",
      "    <button\r",
      "      v-for=\"item in pageCount\"\r",
      "      :key=\"item\"\r",
      "      :disabled=\"currentPage === item\"\r",
      "      @click=\"currentPage = item\"\r",
      "    >\r",
      "      {{ item }}\r",
      "    </button>\r",
      "    <button :disabled=\"isLastPage\" @click=\"next\">\r",
      "      next\r",
      "    </button>\r",
      "  </div>\r",
      "\r",
      "  <table>\r",
      "    <thead>\r",
      "      <tr>\r",
      "        <td>id</td>\r",
      "        <td>name</td>\r",
      "      </tr>\r",
      "    </thead>\r",
      "    <tr v-for=\"d in data\" :key=\"d.id\">\r",
      "      <td>{{ d.id }}</td>\r",
      "      <td>{{ d.name }}</td>\r",
      "    </tr>\r",
      "  </table>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useOnline - vueuse": {
    "prefix": "hvue useOnline - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useOnline\r",
      "\r",
      "Reactive online state. A wrapper of `useNetwork`.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useOnline } from '@vueuse/core'\r",
      "\r",
      "const online = useOnline()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "```html\r",
      "<UseOnline v-slot=\"{ isOnline }\">\r",
      "  Is Online: {{ isOnline }}\r",
      "</UseOnline>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { useNetwork } from '../useNetwork'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Reactive online state.\r",
      " *\r",
      " * @see https://vueuse.org/useOnline\r",
      " * @param options\r",
      " */\r",
      "export function useOnline(options: ConfigurableWindow = {}) {\r",
      "  const { isOnline } = useNetwork(options)\r",
      "  return isOnline\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed } from 'vue'\r",
      "import { useOnline } from '@vueuse/core'\r",
      "\r",
      "const online = useOnline()\r",
      "\r",
      "const clazz = computed(() => online.value ? 'text-primary' : 'text-gray')\r",
      "const text = computed(() => online.value ? 'Online' : 'Offline')\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    Disconnect your network to see changes\r",
      "  </note>\r",
      "  <div>Status: <b :class=\"clazz\">{{ text }}</b></div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePageLeave - vueuse": {
    "prefix": "hvue usePageLeave - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# usePageLeave\r",
      "\r",
      "Reactive state to show whether the mouse leaves the page.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { usePageLeave } from '@vueuse/core'\r",
      "\r",
      "const isLeft = usePageLeave()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "```html\r",
      "<UsePageLeave v-slot=\"{ isLeft }\">\r",
      "  Has Left Page: {{ isLeft }}\r",
      "</UsePageLeave>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Reactive state to show whether mouse leaves the page.\r",
      " *\r",
      " * @see https://vueuse.org/usePageLeave\r",
      " * @param options\r",
      " */\r",
      "export function usePageLeave(options: ConfigurableWindow = {}) {\r",
      "  const { window = defaultWindow } = options\r",
      "  const isLeft = ref(false)\r",
      "\r",
      "  const handler = (event: MouseEvent) => {\r",
      "    if (!window)\r",
      "      return\r",
      "\r",
      "    event = event || (window.event as any)\r",
      "    // @ts-expect-error missing types\r",
      "    const from = event.relatedTarget || event.toElement\r",
      "    isLeft.value = !from\r",
      "  }\r",
      "\r",
      "  if (window) {\r",
      "    useEventListener(window, 'mouseout', handler, { passive: true })\r",
      "    useEventListener(window.document, 'mouseleave', handler, { passive: true })\r",
      "    useEventListener(window.document, 'mouseenter', handler, { passive: true })\r",
      "  }\r",
      "\r",
      "  return isLeft\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { usePageLeave } from '@vueuse/core'\r",
      "\r",
      "const isLeft = usePageLeave()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <pre lang=\"json\">{{ { isLeft } }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useParallax - vueuse": {
    "prefix": "hvue useParallax - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useParallax\r",
      "\r",
      "Create parallax effect easily. It uses `useDeviceOrientation` and fallback to `useMouse` if orientation is not supported.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<div ref='container'>\r",
      "</div>\r",
      "```\r",
      "\r",
      "```js\r",
      "import { useParallax } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const container = ref(null)\r",
      "    const { tilt, roll, source } = useParallax(container)\r",
      "\r",
      "    return {\r",
      "      container,\r",
      "    }\r",
      "  },\r",
      "}\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef } from 'vue-demi'\r",
      "import { computed, reactive } from 'vue-demi'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import { useDeviceOrientation } from '../useDeviceOrientation'\r",
      "import { useMouseInElement } from '../useMouseInElement'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface UseParallaxOptions extends ConfigurableWindow {\r",
      "  deviceOrientationTiltAdjust?: (i: number) => number\r",
      "  deviceOrientationRollAdjust?: (i: number) => number\r",
      "  mouseTiltAdjust?: (i: number) => number\r",
      "  mouseRollAdjust?: (i: number) => number\r",
      "}\r",
      "\r",
      "export interface UseParallaxReturn {\r",
      "  /**\r",
      "   * Roll value. Scaled to `-0.5 ~ 0.5`\r",
      "   */\r",
      "  roll: ComputedRef<number>\r",
      "  /**\r",
      "   * Tilt value. Scaled to `-0.5 ~ 0.5`\r",
      "   */\r",
      "  tilt: ComputedRef<number>\r",
      "  /**\r",
      "   * Sensor source, can be `mouse` or `deviceOrientation`\r",
      "   */\r",
      "  source: ComputedRef<'deviceOrientation' | 'mouse'>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Create parallax effect easily. It uses `useDeviceOrientation` and fallback to `useMouse`\r",
      " * if orientation is not supported.\r",
      " *\r",
      " * @param target\r",
      " * @param options\r",
      " */\r",
      "export function useParallax(\r",
      "  target: MaybeElementRef,\r",
      "  options: UseParallaxOptions = {},\r",
      "): UseParallaxReturn {\r",
      "  const {\r",
      "    deviceOrientationTiltAdjust = i => i,\r",
      "    deviceOrientationRollAdjust = i => i,\r",
      "    mouseTiltAdjust = i => i,\r",
      "    mouseRollAdjust = i => i,\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const orientation = reactive(useDeviceOrientation({ window }))\r",
      "  const {\r",
      "    elementX: x,\r",
      "    elementY: y,\r",
      "    elementWidth: width,\r",
      "    elementHeight: height,\r",
      "  } = useMouseInElement(target, { handleOutside: false, window })\r",
      "\r",
      "  const source = computed(() => {\r",
      "    if (orientation.isSupported\r",
      "      && ((orientation.alpha != null && orientation.alpha !== 0) || (orientation.gamma != null && orientation.gamma !== 0))\r",
      "    )\r",
      "      return 'deviceOrientation'\r",
      "    return 'mouse'\r",
      "  })\r",
      "\r",
      "  const roll = computed(() => {\r",
      "    if (source.value === 'deviceOrientation') {\r",
      "      const value = -orientation.beta! / 90\r",
      "      return deviceOrientationRollAdjust(value)\r",
      "    }\r",
      "    else {\r",
      "      const value = -(y.value - height.value / 2) / height.value\r",
      "      return mouseRollAdjust(value)\r",
      "    }\r",
      "  })\r",
      "\r",
      "  const tilt = computed(() => {\r",
      "    if (source.value === 'deviceOrientation') {\r",
      "      const value = orientation.gamma! / 90\r",
      "      return deviceOrientationTiltAdjust(value)\r",
      "    }\r",
      "    else {\r",
      "      const value = (x.value - width.value / 2) / width.value\r",
      "      return mouseTiltAdjust(value)\r",
      "    }\r",
      "  })\r",
      "\r",
      "  return { roll, tilt, source }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import YAML from 'js-yaml'\r",
      "import { computed, reactive, ref } from 'vue'\r",
      "import type { CSSProperties } from 'vue'\r",
      "import { useMediaQuery, useParallax } from '@vueuse/core'\r",
      "\r",
      "const target = ref(null)\r",
      "const isMobile = useMediaQuery('(max-width: 700px)')\r",
      "\r",
      "const parallax = reactive(useParallax(target))\r",
      "\r",
      "const targetStyle: CSSProperties = {\r",
      "  display: 'flex',\r",
      "  flexDirection: 'column',\r",
      "  justifyContent: 'center',\r",
      "  minHeight: '500px',\r",
      "  transition: '.3s ease-out all',\r",
      "}\r",
      "const cardWindowStyle: CSSProperties = {\r",
      "  overflow: 'hidden',\r",
      "  fontSize: '6rem',\r",
      "  position: 'absolute',\r",
      "  top: 'calc(50% - 1em)',\r",
      "  left: 'calc(50% - 1em)',\r",
      "  height: '2em',\r",
      "  width: '2em',\r",
      "  margin: 'auto',\r",
      "}\r",
      "const layerBase: CSSProperties = {\r",
      "  position: 'absolute',\r",
      "  height: '100%',\r",
      "  width: '100%',\r",
      "  transition: '.3s ease-out all',\r",
      "}\r",
      "const containerStyle: CSSProperties = {\r",
      "  margin: '3em auto',\r",
      "  perspective: '300px',\r",
      "}\r",
      "\r",
      "const infoStyle = computed(() => ({\r",
      "  opacity: 0.4,\r",
      "  top: '20px',\r",
      "  left: '40px',\r",
      "  position: isMobile.value ? 'inherit' : 'absolute',\r",
      "}))\r",
      "\r",
      "const layer0 = computed(() => ({\r",
      "  ...layerBase,\r",
      "  transform: `translateX(${parallax.tilt * 10}px) translateY(${\r",
      "    parallax.roll * 10\r",
      "  }px) scale(1.33)`,\r",
      "}))\r",
      "\r",
      "const layer1 = computed(() => ({\r",
      "  ...layerBase,\r",
      "  transform: `translateX(${parallax.tilt * 20}px) translateY(${\r",
      "    parallax.roll * 20\r",
      "  }px) scale(1.33)`,\r",
      "}))\r",
      "\r",
      "const layer2 = computed(() => ({\r",
      "  ...layerBase,\r",
      "  transform: `translateX(${parallax.tilt * 30}px) translateY(${\r",
      "    parallax.roll * 30\r",
      "  }px) scale(1.33)`,\r",
      "}))\r",
      "\r",
      "const layer3 = computed(() => ({\r",
      "  ...layerBase,\r",
      "  transform: `translateX(${parallax.tilt * 40}px) translateY(${\r",
      "    parallax.roll * 40\r",
      "  }px) scale(1.33)`,\r",
      "}))\r",
      "\r",
      "const layer4 = layerBase\r",
      "\r",
      "const cardStyle = computed(() => ({\r",
      "  background: '#fff',\r",
      "  height: '20rem',\r",
      "  width: '15rem',\r",
      "  borderRadius: '5px',\r",
      "  border: '1px solid #cdcdcd',\r",
      "  overflow: 'hidden',\r",
      "  transition: '.3s ease-out all',\r",
      "  boxShadow: '0 0 20px 0 rgba(255, 255, 255, 0.25)',\r",
      "  transform: `rotateX(${parallax.roll * 20}deg) rotateY(${\r",
      "    parallax.tilt * 20\r",
      "  }deg)`,\r",
      "}))\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div ref=\"target\" :style=\"targetStyle\">\r",
      "      <pre :style=\"infoStyle\">{{ YAML.dump(parallax) }}</pre>\r",
      "      <div :style=\"containerStyle\">\r",
      "        <div :style=\"cardStyle\">\r",
      "          <div :style=\"cardWindowStyle\">\r",
      "            <img\r",
      "              :style=\"layer0\"\r",
      "              src=\"https://jaromvogel.com/images/design/jumping_rabbit/page2layer0.png\"\r",
      "              alt=\"\"\r",
      "            >\r",
      "            <img\r",
      "              :style=\"layer1\"\r",
      "              src=\"https://jaromvogel.com/images/design/jumping_rabbit/page2layer1.png\"\r",
      "              alt=\"\"\r",
      "            >\r",
      "            <img\r",
      "              :style=\"layer2\"\r",
      "              src=\"https://jaromvogel.com/images/design/jumping_rabbit/page2layer2.png\"\r",
      "              alt=\"\"\r",
      "            >\r",
      "            <img\r",
      "              :style=\"layer3\"\r",
      "              src=\"https://jaromvogel.com/images/design/jumping_rabbit/page2layer3.png\"\r",
      "              alt=\"\"\r",
      "            >\r",
      "            <img\r",
      "              :style=\"layer4\"\r",
      "              src=\"https://jaromvogel.com/images/design/jumping_rabbit/page2layer4.png\"\r",
      "              alt=\"\"\r",
      "            >\r",
      "          </div>\r",
      "        </div>\r",
      "      </div>\r",
      "      <div class=\"note opacity-1\">\r",
      "        Credit of images to\r",
      "        <a\r",
      "          href=\"https://codepen.io/jaromvogel\"\r",
      "          target=\"__blank\"\r",
      "        >Jarom Vogel</a>\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useParentElement - vueuse": {
    "prefix": "hvue useParentElement - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useParentElement\r",
      "\r",
      "Get parent element of the given element\r",
      "\r",
      "## Usage\r",
      "\r",
      "When no argument is passed, it will return the parent element of the current component.\r",
      "\r",
      "```js\r",
      "import { useParentElement } from '@vueuse/core'\r",
      "\r",
      "const parentEl = useParentElement()\r",
      "\r",
      "onMounted(() => {\r",
      "  console.log(parentEl.value)\r",
      "})\r",
      "```\r",
      "\r",
      "It can also accept a `ref` as the first argument.\r",
      "\r",
      "```ts\r",
      "import { useParentElement } from '@vueuse/core'\r",
      "\r",
      "// Don't forget to bind the ref to the element\r",
      "const tooltip = ref<HTMLElement | undefined>()\r",
      "\r",
      "const tooltipWrapper = useParentElement(tooltip)\r",
      "\r",
      "onMounted(() => {\r",
      "  console.log(tooltipWrapper.value)\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue, tryOnMounted } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { shallowRef, watch } from 'vue-demi'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { useCurrentElement } from '../useCurrentElement'\r",
      "\r",
      "export function useParentElement(\r",
      "  element: MaybeRefOrGetter<HTMLElement | SVGElement | null | undefined> = useCurrentElement<HTMLElement | SVGAElement>(),\r",
      "): Readonly<Ref<HTMLElement | SVGElement | null | undefined>> {\r",
      "  const parentElement = shallowRef<HTMLElement | SVGElement | null | undefined>()\r",
      "\r",
      "  const update = () => {\r",
      "    const el = unrefElement(element)\r",
      "    if (el)\r",
      "      parentElement.value = el.parentElement\r",
      "  }\r",
      "\r",
      "  tryOnMounted(update)\r",
      "  watch(() => toValue(element), update)\r",
      "\r",
      "  return parentElement\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script lang=\"ts\" setup>\r",
      "import { useParentElement } from '@vueuse/core'\r",
      "\r",
      "const parentElement = useParentElement()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>Parent element tag: {{ parentElement ? parentElement.tagName : 'Finding...' }}</p>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePerformanceObserver - vueuse": {
    "prefix": "hvue usePerformanceObserver - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# usePerformanceObserver\r",
      "\r",
      "Observe performance metrics.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { usePerformanceObserver } from '@vueuse/core'\r",
      "\r",
      "const entrys = ref<PerformanceEntry[]>([])\r",
      "usePerformanceObserver({\r",
      "  entryTypes: ['paint'],\r",
      "}, (list) => {\r",
      "  entrys.value = list.getEntries()\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { tryOnScopeDispose } from '@vueuse/shared'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export type UsePerformanceObserverOptions = PerformanceObserverInit & ConfigurableWindow & {\r",
      "  /**\r",
      "   * Start the observer immediate.\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Observe performance metrics.\r",
      " *\r",
      " * @see https://vueuse.org/usePerformanceObserver\r",
      " * @param options\r",
      " */\r",
      "export function usePerformanceObserver(options: UsePerformanceObserverOptions, callback: PerformanceObserverCallback) {\r",
      "  const {\r",
      "    window = defaultWindow,\r",
      "    immediate = true,\r",
      "    ...performanceOptions\r",
      "  } = options\r",
      "\r",
      "  const isSupported = useSupported(() => window && 'PerformanceObserver' in window)\r",
      "\r",
      "  let observer: PerformanceObserver | undefined\r",
      "\r",
      "  const stop = () => {\r",
      "    observer?.disconnect()\r",
      "  }\r",
      "\r",
      "  const start = () => {\r",
      "    if (isSupported.value) {\r",
      "      stop()\r",
      "      observer = new PerformanceObserver(callback)\r",
      "      observer.observe(performanceOptions)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(stop)\r",
      "\r",
      "  if (immediate)\r",
      "    start()\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    start,\r",
      "    stop,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { usePerformanceObserver } from '@vueuse/core'\r",
      "import { ref } from 'vue'\r",
      "\r",
      "const entrys = ref<PerformanceEntry[]>([])\r",
      "usePerformanceObserver({\r",
      "  entryTypes: ['paint'],\r",
      "}, (list) => {\r",
      "  entrys.value = list.getEntries()\r",
      "})\r",
      "function refresh() {\r",
      "  return window.location.reload()\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"refresh\">\r",
      "    refresh\r",
      "  </button>\r",
      "\r",
      "  <pre lang=\"json\">{{ entrys }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePermission - vueuse": {
    "prefix": "hvue usePermission - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# usePermission\r",
      "\r",
      "Reactive [Permissions API](https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API). The Permissions API provides the tools to allow developers to implement a better user experience as far as permissions are concerned.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { usePermission } from '@vueuse/core'\r",
      "\r",
      "const microphoneAccess = usePermission('microphone')\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { createSingletonPromise } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableNavigator } from '../_configurable'\r",
      "import { defaultNavigator } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "type DescriptorNamePolyfill =\r",
      "  'accelerometer' |\r",
      "  'accessibility-events' |\r",
      "  'ambient-light-sensor' |\r",
      "  'background-sync' |\r",
      "  'camera' |\r",
      "  'clipboard-read' |\r",
      "  'clipboard-write' |\r",
      "  'gyroscope' |\r",
      "  'magnetometer' |\r",
      "  'microphone' |\r",
      "  'notifications' |\r",
      "  'payment-handler' |\r",
      "  'persistent-storage' |\r",
      "  'push' |\r",
      "  'speaker'\r",
      "\r",
      "export type GeneralPermissionDescriptor =\r",
      "  | PermissionDescriptor\r",
      "  | { name: DescriptorNamePolyfill }\r",
      "\r",
      "export interface UsePermissionOptions<Controls extends boolean> extends ConfigurableNavigator {\r",
      "  /**\r",
      "   * Expose more controls\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  controls?: Controls\r",
      "}\r",
      "\r",
      "export type UsePermissionReturn = Readonly<Ref<PermissionState | undefined>>\r",
      "export interface UsePermissionReturnWithControls {\r",
      "  state: UsePermissionReturn\r",
      "  isSupported: Ref<boolean>\r",
      "  query: () => Promise<PermissionStatus | undefined>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive Permissions API.\r",
      " *\r",
      " * @see https://vueuse.org/usePermission\r",
      " */\r",
      "export function usePermission(\r",
      "  permissionDesc: GeneralPermissionDescriptor | GeneralPermissionDescriptor['name'],\r",
      "  options?: UsePermissionOptions<false>\r",
      "): UsePermissionReturn\r",
      "export function usePermission(\r",
      "  permissionDesc: GeneralPermissionDescriptor | GeneralPermissionDescriptor['name'],\r",
      "  options: UsePermissionOptions<true>,\r",
      "): UsePermissionReturnWithControls\r",
      "export function usePermission(\r",
      "  permissionDesc: GeneralPermissionDescriptor | GeneralPermissionDescriptor['name'],\r",
      "  options: UsePermissionOptions<boolean> = {},\r",
      "): UsePermissionReturn | UsePermissionReturnWithControls {\r",
      "  const {\r",
      "    controls = false,\r",
      "    navigator = defaultNavigator,\r",
      "  } = options\r",
      "\r",
      "  const isSupported = useSupported(() => navigator && 'permissions' in navigator)\r",
      "  let permissionStatus: PermissionStatus | undefined\r",
      "\r",
      "  const desc = typeof permissionDesc === 'string'\r",
      "    ? { name: permissionDesc } as PermissionDescriptor\r",
      "    : permissionDesc as PermissionDescriptor\r",
      "  const state = ref<PermissionState | undefined>()\r",
      "\r",
      "  const onChange = () => {\r",
      "    if (permissionStatus)\r",
      "      state.value = permissionStatus.state\r",
      "  }\r",
      "\r",
      "  const query = createSingletonPromise(async () => {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "    if (!permissionStatus) {\r",
      "      try {\r",
      "        permissionStatus = await navigator!.permissions.query(desc)\r",
      "        useEventListener(permissionStatus, 'change', onChange)\r",
      "        onChange()\r",
      "      }\r",
      "      catch {\r",
      "        state.value = 'prompt'\r",
      "      }\r",
      "    }\r",
      "    return permissionStatus\r",
      "  })\r",
      "\r",
      "  query()\r",
      "\r",
      "  if (controls) {\r",
      "    return {\r",
      "      state: state as UsePermissionReturn,\r",
      "      isSupported,\r",
      "      query,\r",
      "    }\r",
      "  }\r",
      "  else {\r",
      "    return state as UsePermissionReturn\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, reactive } from 'vue'\r",
      "import YAML from 'js-yaml'\r",
      "import { usePermission } from '@vueuse/core'\r",
      "\r",
      "const accelerometer = usePermission('accelerometer')\r",
      "const accessibilityEvents = usePermission('accessibility-events')\r",
      "const ambientLightSensor = usePermission('ambient-light-sensor')\r",
      "const backgroundSync = usePermission('background-sync')\r",
      "const camera = usePermission('camera')\r",
      "const clipboardRead = usePermission('clipboard-read')\r",
      "const clipboardWrite = usePermission('clipboard-write')\r",
      "const gyroscope = usePermission('gyroscope')\r",
      "const magnetometer = usePermission('magnetometer')\r",
      "const microphone = usePermission('microphone')\r",
      "const notifications = usePermission('notifications')\r",
      "const paymentHandler = usePermission('payment-handler')\r",
      "const persistentStorage = usePermission('persistent-storage')\r",
      "const push = usePermission('push')\r",
      "const speaker = usePermission('speaker')\r",
      "\r",
      "const code = computed(() => YAML.dump(reactive({\r",
      "  accelerometer,\r",
      "  accessibilityEvents,\r",
      "  ambientLightSensor,\r",
      "  backgroundSync,\r",
      "  camera,\r",
      "  clipboardRead,\r",
      "  clipboardWrite,\r",
      "  gyroscope,\r",
      "  magnetometer,\r",
      "  microphone,\r",
      "  notifications,\r",
      "  paymentHandler,\r",
      "  persistentStorage,\r",
      "  push,\r",
      "  speaker,\r",
      "})))\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <pre>{{ code }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePointer - vueuse": {
    "prefix": "hvue usePointer - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# usePointer\r",
      "\r",
      "Reactive [pointer state](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events).\r",
      "\r",
      "## Basic Usage\r",
      "\r",
      "```js\r",
      "import { usePointer } from '@vueuse/core'\r",
      "\r",
      "const { x, y, pressure, pointerType } = usePointer()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "By default, the component will track the pointer on `window`\r",
      "\r",
      "```html\r",
      "<UsePointer v-slot=\"{ x, y }\">\r",
      "  x: {{ x }}\r",
      "  y: {{ y }}\r",
      "</UsePointer>\r",
      "```\r",
      "\r",
      "To track local position in the element, set `target=\"self\"`:\r",
      "\r",
      "```html\r",
      "<UsePointer target=\"self\" v-slot=\"{ x, y }\">\r",
      "  x: {{ x }}\r",
      "  y: {{ y }}\r",
      "</UsePointer>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRef } from '@vueuse/shared'\r",
      "import { objectPick, toRefs } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import type { PointerType, Position } from '../types'\r",
      "\r",
      "export interface UsePointerState extends Position {\r",
      "  pressure: number\r",
      "  pointerId: number\r",
      "  tiltX: number\r",
      "  tiltY: number\r",
      "  width: number\r",
      "  height: number\r",
      "  twist: number\r",
      "  pointerType: PointerType | null\r",
      "}\r",
      "\r",
      "export interface UsePointerOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Pointer types that listen to.\r",
      "   *\r",
      "   * @default ['mouse', 'touch', 'pen']\r",
      "   */\r",
      "  pointerTypes?: PointerType[]\r",
      "\r",
      "  /**\r",
      "   * Initial values\r",
      "   */\r",
      "  initialValue?: MaybeRef<Partial<UsePointerState>>\r",
      "\r",
      "  /**\r",
      "   * @default window\r",
      "   */\r",
      "  target?: MaybeRef<EventTarget | null | undefined> | Document | Window\r",
      "}\r",
      "\r",
      "const defaultState: UsePointerState = /*#__PURE__*/ {\r",
      "  x: 0,\r",
      "  y: 0,\r",
      "  pointerId: 0,\r",
      "  pressure: 0,\r",
      "  tiltX: 0,\r",
      "  tiltY: 0,\r",
      "  width: 0,\r",
      "  height: 0,\r",
      "  twist: 0,\r",
      "  pointerType: null,\r",
      "}\r",
      "const keys = /*#__PURE__*/ Object.keys(defaultState) as (keyof UsePointerState)[]\r",
      "\r",
      "/**\r",
      " * Reactive pointer state.\r",
      " *\r",
      " * @see https://vueuse.org/usePointer\r",
      " * @param options\r",
      " */\r",
      "export function usePointer(options: UsePointerOptions = {}) {\r",
      "  const {\r",
      "    target = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const isInside = ref(false)\r",
      "  const state = ref(options.initialValue || {}) as unknown as Ref<UsePointerState>\r",
      "  Object.assign(state.value, defaultState, state.value)\r",
      "\r",
      "  const handler = (event: PointerEvent) => {\r",
      "    isInside.value = true\r",
      "    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType as PointerType))\r",
      "      return\r",
      "\r",
      "    state.value = objectPick(event, keys, false) as UsePointerState\r",
      "  }\r",
      "\r",
      "  if (target) {\r",
      "    const listenerOptions = { passive: true }\r",
      "    useEventListener(target, ['pointerdown', 'pointermove', 'pointerup'], handler, listenerOptions)\r",
      "    useEventListener(target, 'pointerleave', () => isInside.value = false, listenerOptions)\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    ...toRefs(state),\r",
      "    isInside,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UsePointerReturn = ReturnType<typeof usePointer>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { reactive } from 'vue'\r",
      "import { usePointer } from '@vueuse/core'\r",
      "\r",
      "const pointer = reactive(usePointer())\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <pre class=\"select-none\" style=\"touch-action: none\">{{ pointer }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePointerLock - vueuse": {
    "prefix": "hvue usePointerLock - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# usePointerLock\r",
      "\r",
      "Reactive [pointer lock](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API).\r",
      "\r",
      "## Basic Usage\r",
      "\r",
      "```js\r",
      "import { usePointerLock } from '@vueuse/core'\r",
      "\r",
      "const { isSupported, lock, unlock, element, triggerElement } = usePointerLock()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UsePointerLock v-slot=\"{ lock }\">\r",
      "  <canvas />\r",
      "  <button @click=\"lock\">\r",
      "    Lock Pointer on Canvas\r",
      "  </button>\r",
      "</UsePointerLock>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import { until } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useSupported } from '../useSupported'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import type { MaybeElementRef } from '../unrefElement'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "\r",
      "declare global {\r",
      "  interface PointerLockOptions {\r",
      "    unadjustedMovement?: boolean\r",
      "  }\r",
      "\r",
      "  interface Element {\r",
      "    requestPointerLock(options?: PointerLockOptions): Promise<void> | void\r",
      "  }\r",
      "}\r",
      "\r",
      "type MaybeHTMLElement = HTMLElement | undefined | null\r",
      "\r",
      "export interface UsePointerLockOptions extends ConfigurableDocument {\r",
      "  pointerLockOptions?: PointerLockOptions\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive pointer lock.\r",
      " *\r",
      " * @see https://vueuse.org/usePointerLock\r",
      " * @param target\r",
      " * @param options\r",
      " */\r",
      "export function usePointerLock(target?: MaybeElementRef<MaybeHTMLElement>, options: UsePointerLockOptions = {}) {\r",
      "  const { document = defaultDocument, pointerLockOptions } = options\r",
      "\r",
      "  const isSupported = useSupported(() => document && 'pointerLockElement' in document)\r",
      "\r",
      "  const element = ref<MaybeHTMLElement>()\r",
      "\r",
      "  const triggerElement = ref<MaybeHTMLElement>()\r",
      "\r",
      "  let targetElement: MaybeHTMLElement\r",
      "\r",
      "  if (isSupported.value) {\r",
      "    useEventListener(document, 'pointerlockchange', () => {\r",
      "      const currentElement = document!.pointerLockElement ?? element.value\r",
      "      if (targetElement && currentElement === targetElement) {\r",
      "        element.value = document!.pointerLockElement as MaybeHTMLElement\r",
      "        if (!element.value)\r",
      "          targetElement = triggerElement.value = null\r",
      "      }\r",
      "    })\r",
      "\r",
      "    useEventListener(document, 'pointerlockerror', () => {\r",
      "      const currentElement = document!.pointerLockElement ?? element.value\r",
      "      if (targetElement && currentElement === targetElement) {\r",
      "        const action = document!.pointerLockElement ? 'release' : 'acquire'\r",
      "        throw new Error(`Failed to ${action} pointer lock.`)\r",
      "      }\r",
      "    })\r",
      "  }\r",
      "\r",
      "  async function lock(e: MaybeElementRef<MaybeHTMLElement> | Event, options?: PointerLockOptions) {\r",
      "    if (!isSupported.value)\r",
      "      throw new Error('Pointer Lock API is not supported by your browser.')\r",
      "\r",
      "    triggerElement.value = e instanceof Event ? <HTMLElement>e.currentTarget : null\r",
      "    targetElement = e instanceof Event ? unrefElement(target) ?? triggerElement.value : unrefElement(e)\r",
      "    if (!targetElement)\r",
      "      throw new Error('Target element undefined.')\r",
      "    targetElement.requestPointerLock(options ?? pointerLockOptions)\r",
      "\r",
      "    return await until(element).toBe(targetElement)\r",
      "  }\r",
      "\r",
      "  async function unlock() {\r",
      "    if (!element.value)\r",
      "      return false\r",
      "\r",
      "    document!.exitPointerLock()\r",
      "\r",
      "    await until(element).toBeNull()\r",
      "    return true\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    element,\r",
      "    triggerElement,\r",
      "    lock,\r",
      "    unlock,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UsePointerLockReturn = ReturnType<typeof usePointerLock>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup>\r",
      "import { ref, watch } from 'vue-demi'\r",
      "import { useMouse, usePointerLock } from '@vueuse/core'\r",
      "\r",
      "const { lock, unlock, element } = usePointerLock()\r",
      "const { x, y } = useMouse({ type: 'movement' })\r",
      "const rotY = ref(-45)\r",
      "const rotX = ref(0)\r",
      "\r",
      "watch([x, y], ([x, y]) => {\r",
      "  if (!element.value)\r",
      "    return\r",
      "  rotY.value += x / 2\r",
      "  rotX.value -= y / 2\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div scene>\r",
      "    <div cube @mousedown.capture=\"lock\" @mouseup=\"unlock\">\r",
      "      <span face base style=\"--i: 1\" logo-vue />\r",
      "      <span face base style=\"--i: -1\" logo-vueuse />\r",
      "      <span face side style=\"--i: 0\" logo-vue />\r",
      "      <span face side style=\"--i: 1\" logo-vueuse />\r",
      "      <span face side style=\"--i: 2\" logo-vue />\r",
      "      <span face side style=\"--i: 3\" logo-vueuse />\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped lang=\"postcss\">\r",
      "[scene] {\r",
      "  @apply flex justify-center items-center box-border perspective-300;\r",
      "}\r",
      "\r",
      "[cube] {\r",
      "  @apply cursor-all-scroll relative w-100px h-100px preserve-3d;\r",
      "  --rotY: v-bind(rotY);\r",
      "  --rotX: v-bind(rotX);\r",
      "  transform: rotateY(calc(var(--rotY) * 1deg)) rotateX(calc(var(--rotX) * 1deg));\r",
      "}\r",
      "\r",
      "[face] {\r",
      "  @apply absolute top-0 left-0 w-full h-full b-1 b-solid backface-hidden\r",
      "    bg-emerald-4 bg-opacity-20 bg-center bg-[length:75%] bg-no-repeat;\r",
      "}\r",
      "\r",
      "[base] {\r",
      "  transform: rotateX(calc(90deg * var(--i))) translateZ(50px);\r",
      "}\r",
      "\r",
      "[side] {\r",
      "  transform: rotateY(calc(90deg * var(--i))) translateZ(50px);\r",
      "}\r",
      "\r",
      "[logo-vue] {\r",
      "  @apply bg-[url(/vue.svg)];\r",
      "}\r",
      "\r",
      "[logo-vueuse] {\r",
      "  @apply bg-[url(/favicon.svg)];\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePointerSwipe - vueuse": {
    "prefix": "hvue usePointerSwipe - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# usePointerSwipe\r",
      "\r",
      "Reactive swipe detection based on [PointerEvents](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent).\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { ref } from 'vue'\r",
      "import { usePointerSwipe } from '@vueuse/core'\r",
      "\r",
      "const el = ref(null)\r",
      "const { isSwiping, direction } = usePointerSwipe(el)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\">\r",
      "    Swipe here\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toRef } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { computed, reactive, readonly, ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { PointerType, Position } from '../types'\r",
      "import type { UseSwipeDirection } from '../useSwipe'\r",
      "\r",
      "export interface UsePointerSwipeOptions {\r",
      "  /**\r",
      "   * @default 50\r",
      "   */\r",
      "  threshold?: number\r",
      "\r",
      "  /**\r",
      "   * Callback on swipe start.\r",
      "   */\r",
      "  onSwipeStart?: (e: PointerEvent) => void\r",
      "\r",
      "  /**\r",
      "   * Callback on swipe move.\r",
      "   */\r",
      "  onSwipe?: (e: PointerEvent) => void\r",
      "\r",
      "  /**\r",
      "   * Callback on swipe end.\r",
      "   */\r",
      "  onSwipeEnd?: (e: PointerEvent, direction: UseSwipeDirection) => void\r",
      "\r",
      "  /**\r",
      "   * Pointer types to listen to.\r",
      "   *\r",
      "   * @default ['mouse', 'touch', 'pen']\r",
      "   */\r",
      "  pointerTypes?: PointerType[]\r",
      "}\r",
      "\r",
      "export interface UsePointerSwipeReturn {\r",
      "  readonly isSwiping: Ref<boolean>\r",
      "  direction: Readonly<Ref<UseSwipeDirection>>\r",
      "  readonly posStart: Position\r",
      "  readonly posEnd: Position\r",
      "  distanceX: Readonly<Ref<number>>\r",
      "  distanceY: Readonly<Ref<number>>\r",
      "  stop: () => void\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive swipe detection based on PointerEvents.\r",
      " *\r",
      " * @see https://vueuse.org/usePointerSwipe\r",
      " * @param target\r",
      " * @param options\r",
      " */\r",
      "export function usePointerSwipe(\r",
      "  target: MaybeRefOrGetter<HTMLElement | null | undefined>,\r",
      "  options: UsePointerSwipeOptions = {},\r",
      "): UsePointerSwipeReturn {\r",
      "  const targetRef = toRef(target)\r",
      "  const {\r",
      "    threshold = 50,\r",
      "    onSwipe,\r",
      "    onSwipeEnd,\r",
      "    onSwipeStart,\r",
      "  } = options\r",
      "\r",
      "  const posStart = reactive<Position>({ x: 0, y: 0 })\r",
      "  const updatePosStart = (x: number, y: number) => {\r",
      "    posStart.x = x\r",
      "    posStart.y = y\r",
      "  }\r",
      "\r",
      "  const posEnd = reactive<Position>({ x: 0, y: 0 })\r",
      "  const updatePosEnd = (x: number, y: number) => {\r",
      "    posEnd.x = x\r",
      "    posEnd.y = y\r",
      "  }\r",
      "\r",
      "  const distanceX = computed(() => posStart.x - posEnd.x)\r",
      "  const distanceY = computed(() => posStart.y - posEnd.y)\r",
      "\r",
      "  const { max, abs } = Math\r",
      "  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold)\r",
      "  const isSwiping = ref(false)\r",
      "  const isPointerDown = ref(false)\r",
      "\r",
      "  const direction = computed(() => {\r",
      "    if (!isThresholdExceeded.value)\r",
      "      return 'none'\r",
      "\r",
      "    if (abs(distanceX.value) > abs(distanceY.value)) {\r",
      "      return distanceX.value > 0\r",
      "        ? 'left'\r",
      "        : 'right'\r",
      "    }\r",
      "    else {\r",
      "      return distanceY.value > 0\r",
      "        ? 'up'\r",
      "        : 'down'\r",
      "    }\r",
      "  })\r",
      "\r",
      "  const eventIsAllowed = (e: PointerEvent): boolean => {\r",
      "    const isReleasingButton = e.buttons === 0\r",
      "    const isPrimaryButton = e.buttons === 1\r",
      "    return options.pointerTypes?.includes(e.pointerType as PointerType) ?? (isReleasingButton || isPrimaryButton) ?? true\r",
      "  }\r",
      "\r",
      "  const stops = [\r",
      "    useEventListener(target, 'pointerdown', (e: PointerEvent) => {\r",
      "      if (!eventIsAllowed(e))\r",
      "        return\r",
      "      isPointerDown.value = true\r",
      "      // Disable scroll on for TouchEvents\r",
      "      targetRef.value?.style?.setProperty('touch-action', 'none')\r",
      "      // Future pointer events will be retargeted to target until pointerup/cancel\r",
      "      const eventTarget = e.target as HTMLElement | undefined\r",
      "      eventTarget?.setPointerCapture(e.pointerId)\r",
      "      const { clientX: x, clientY: y } = e\r",
      "      updatePosStart(x, y)\r",
      "      updatePosEnd(x, y)\r",
      "      onSwipeStart?.(e)\r",
      "    }),\r",
      "\r",
      "    useEventListener(target, 'pointermove', (e: PointerEvent) => {\r",
      "      if (!eventIsAllowed(e))\r",
      "        return\r",
      "      if (!isPointerDown.value)\r",
      "        return\r",
      "\r",
      "      const { clientX: x, clientY: y } = e\r",
      "      updatePosEnd(x, y)\r",
      "      if (!isSwiping.value && isThresholdExceeded.value)\r",
      "        isSwiping.value = true\r",
      "      if (isSwiping.value)\r",
      "        onSwipe?.(e)\r",
      "    }),\r",
      "\r",
      "    useEventListener(target, 'pointerup', (e: PointerEvent) => {\r",
      "      if (!eventIsAllowed(e))\r",
      "        return\r",
      "      if (isSwiping.value)\r",
      "        onSwipeEnd?.(e, direction.value)\r",
      "\r",
      "      isPointerDown.value = false\r",
      "      isSwiping.value = false\r",
      "      targetRef.value?.style?.setProperty('touch-action', 'initial')\r",
      "    }),\r",
      "  ]\r",
      "\r",
      "  const stop = () => stops.forEach(s => s())\r",
      "\r",
      "  return {\r",
      "    isSwiping: readonly(isSwiping),\r",
      "    direction: readonly(direction),\r",
      "    posStart: readonly(posStart),\r",
      "    posEnd: readonly(posEnd),\r",
      "    distanceX,\r",
      "    distanceY,\r",
      "    stop,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, ref } from 'vue'\r",
      "import { usePointerSwipe } from '@vueuse/core'\r",
      "import type { UseSwipeDirection } from '@vueuse/core'\r",
      "\r",
      "const target = ref<HTMLElement | null>(null)\r",
      "const container = ref<HTMLElement | null>(null)\r",
      "\r",
      "const containerWidth = computed(() => container.value?.offsetWidth)\r",
      "\r",
      "const left = ref('0')\r",
      "const opacity = ref(1)\r",
      "\r",
      "function reset() {\r",
      "  left.value = '0'\r",
      "  opacity.value = 1\r",
      "}\r",
      "\r",
      "const { distanceX, isSwiping } = usePointerSwipe(target, {\r",
      "  onSwipe(e: PointerEvent) {\r",
      "    if (containerWidth.value) {\r",
      "      if (distanceX.value < 0) {\r",
      "        const distance = Math.abs(distanceX.value)\r",
      "        left.value = `${distance}px`\r",
      "        opacity.value = 1.25 - distance / containerWidth.value\r",
      "      }\r",
      "      else {\r",
      "        left.value = '0'\r",
      "        opacity.value = 1\r",
      "      }\r",
      "    }\r",
      "  },\r",
      "  onSwipeEnd(e: PointerEvent, direction: UseSwipeDirection) {\r",
      "    if (distanceX.value < 0 && containerWidth.value && (Math.abs(distanceX.value) / containerWidth.value) >= 0.5) {\r",
      "      left.value = '100%'\r",
      "      opacity.value = 0\r",
      "    }\r",
      "    else {\r",
      "      left.value = '0'\r",
      "      opacity.value = 1\r",
      "    }\r",
      "  },\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"container\" class=\"bg-gray-200 rounded relative w-full h-[80px] m-auto flex items-center justify-center overflow-hidden\">\r",
      "    <button @click=\"reset\">\r",
      "      Reset\r",
      "    </button>\r",
      "    <div\r",
      "      ref=\"target\"\r",
      "      class=\"absolute w-full h-full top-0 left-0 bg-[#3eaf7c] flex items-center justify-center\"\r",
      "      :class=\"{ 'transition-all duration-200 ease-linear': !isSwiping }\"\r",
      "      :style=\"{ left, opacity }\"\r",
      "    >\r",
      "      <p class=\"flex text-white items-center\">\r",
      "        Swipe <mdi-arrow-right />\r",
      "      </p>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePreferredColorScheme - vueuse": {
    "prefix": "hvue usePreferredColorScheme - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# usePreferredColorScheme\r",
      "\r",
      "Reactive [prefers-color-scheme](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme) media query.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { usePreferredColorScheme } from '@vueuse/core'\r",
      "\r",
      "const preferredColor = usePreferredColorScheme()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UsePreferredColorScheme v-slot=\"{ colorScheme }\">\r",
      "  Preferred Color Scheme: {{ colorScheme }}\r",
      "</UsePreferredColorScheme>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed } from 'vue-demi'\r",
      "import { useMediaQuery } from '../useMediaQuery'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "\r",
      "export type ColorSchemeType = 'dark' | 'light' | 'no-preference'\r",
      "\r",
      "/**\r",
      " * Reactive prefers-color-scheme media query.\r",
      " *\r",
      " * @see https://vueuse.org/usePreferredColorScheme\r",
      " * @param [options]\r",
      " */\r",
      "export function usePreferredColorScheme(options?: ConfigurableWindow) {\r",
      "  const isLight = useMediaQuery('(prefers-color-scheme: light)', options)\r",
      "  const isDark = useMediaQuery('(prefers-color-scheme: dark)', options)\r",
      "\r",
      "  return computed<ColorSchemeType>(() => {\r",
      "    if (isDark.value)\r",
      "      return 'dark'\r",
      "    if (isLight.value)\r",
      "      return 'light'\r",
      "    return 'no-preference'\r",
      "  })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { usePreferredColorScheme } from '@vueuse/core'\r",
      "\r",
      "const colorScheme = usePreferredColorScheme()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    Preferred Color Scheme:\r",
      "  </note>\r",
      "  <code>{{ colorScheme }}</code>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePreferredContrast - vueuse": {
    "prefix": "hvue usePreferredContrast - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# usePreferredContrast\r",
      "\r",
      "Reactive [prefers-contrast](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-contrast) media query.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { usePreferredContrast } from '@vueuse/core'\r",
      "\r",
      "const preferredContrast = usePreferredContrast()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UsePreferredContrast v-slot=\"{ contrast }\">\r",
      "  Preferred Contrast: {{ contrast }}\r",
      "</UsePreferredContrast>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed } from 'vue-demi'\r",
      "import { useMediaQuery } from '../useMediaQuery'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "\r",
      "export type ContrastType = 'more' | 'less' | 'custom' | 'no-preference'\r",
      "\r",
      "/**\r",
      " * Reactive prefers-contrast media query.\r",
      " *\r",
      " * @see https://vueuse.org/usePreferredContrast\r",
      " * @param [options]\r",
      " */\r",
      "export function usePreferredContrast(options?: ConfigurableWindow) {\r",
      "  const isMore = useMediaQuery('(prefers-contrast: more)', options)\r",
      "  const isLess = useMediaQuery('(prefers-contrast: less)', options)\r",
      "  const isCustom = useMediaQuery('(prefers-contrast: custom)', options)\r",
      "\r",
      "  return computed<ContrastType>(() => {\r",
      "    if (isMore.value)\r",
      "      return 'more'\r",
      "    if (isLess.value)\r",
      "      return 'less'\r",
      "    if (isCustom.value)\r",
      "      return 'custom'\r",
      "    return 'no-preference'\r",
      "  })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { usePreferredContrast } from '@vueuse/core'\r",
      "\r",
      "const contrast = usePreferredContrast()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    Preferred contrast:\r",
      "  </note>\r",
      "  <code>{{ contrast }}</code>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePreferredDark - vueuse": {
    "prefix": "hvue usePreferredDark - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# usePreferredDark\r",
      "\r",
      "Reactive dark theme preference.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { usePreferredDark } from '@vueuse/core'\r",
      "\r",
      "const isDark = usePreferredDark()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UsePreferredDark v-slot=\"{ prefersDark }\">\r",
      "  Prefers Dark: {{ prefersDark }}\r",
      "</UsePreferredDark>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { useMediaQuery } from '../useMediaQuery'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Reactive dark theme preference.\r",
      " *\r",
      " * @see https://vueuse.org/usePreferredDark\r",
      " * @param [options]\r",
      " */\r",
      "export function usePreferredDark(options?: ConfigurableWindow) {\r",
      "  return useMediaQuery('(prefers-color-scheme: dark)', options)\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { usePreferredDark } from '@vueuse/core'\r",
      "\r",
      "const prefersDark = usePreferredDark()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    Prefers Dark:\r",
      "  </note>\r",
      "  <BooleanDisplay :value=\"prefersDark\" />\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePreferredLanguages - vueuse": {
    "prefix": "hvue usePreferredLanguages - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# usePreferredLanguages\r",
      "\r",
      "Reactive [Navigator Languages](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorLanguage/languages). It provides web developers with information about the user's preferred languages. For example, this may be useful to adjust the language of the user interface based on the user's preferred languages in order to provide better experience.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { usePreferredLanguages } from '@vueuse/core'\r",
      "\r",
      "const languages = usePreferredLanguages()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UsePreferredLanguages v-slot=\"{ languages }\">\r",
      "  Preferred Languages: {{ languages }}\r",
      "</UsePreferredLanguages>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Reactive Navigator Languages.\r",
      " *\r",
      " * @see https://vueuse.org/usePreferredLanguages\r",
      " * @param options\r",
      " */\r",
      "export function usePreferredLanguages(options: ConfigurableWindow = {}): Ref<readonly string[]> {\r",
      "  const { window = defaultWindow } = options\r",
      "  if (!window)\r",
      "    return ref(['en'])\r",
      "\r",
      "  const navigator = window.navigator\r",
      "  const value = ref<readonly string[]>(navigator.languages)\r",
      "\r",
      "  useEventListener(window, 'languagechange', () => {\r",
      "    value.value = navigator.languages\r",
      "  })\r",
      "\r",
      "  return value\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { usePreferredLanguages } from '@vueuse/core'\r",
      "\r",
      "const languages = usePreferredLanguages()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    Preferred Languages:\r",
      "  </note>\r",
      "  <div>\r",
      "    <code v-for=\"lang in languages\" :key=\"lang\" class=\"mr-2\">{{ lang }}</code>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue usePreferredReducedMotion - vueuse": {
    "prefix": "hvue usePreferredReducedMotion - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# usePreferredReducedMotion\r",
      "\r",
      "Reactive [prefers-reduced-motion](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-motion) media query.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { usePreferredReducedMotion } from '@vueuse/core'\r",
      "\r",
      "const preferredMotion = usePreferredReducedMotion()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UsePreferredReducedMotion v-slot=\"{ motion }\">\r",
      "  Preferred Reduced Motion: {{ motion }}\r",
      "</UsePreferredReducedMotion>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed } from 'vue-demi'\r",
      "import { useMediaQuery } from '../useMediaQuery'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "\r",
      "export type ReducedMotionType = 'reduce' | 'no-preference'\r",
      "\r",
      "/**\r",
      " * Reactive prefers-reduced-motion media query.\r",
      " *\r",
      " * @see https://vueuse.org/usePreferredReducedMotion\r",
      " * @param [options]\r",
      " */\r",
      "export function usePreferredReducedMotion(options?: ConfigurableWindow) {\r",
      "  const isReduced = useMediaQuery('(prefers-reduced-motion: reduce)', options)\r",
      "\r",
      "  return computed<ReducedMotionType>(() => {\r",
      "    if (isReduced.value)\r",
      "      return 'reduce'\r",
      "    return 'no-preference'\r",
      "  })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { usePreferredReducedMotion } from '@vueuse/core'\r",
      "\r",
      "const motion = usePreferredReducedMotion()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    Preferred Motion:\r",
      "  </note>\r",
      "  <code>{{ motion }}</code>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useRafFn - vueuse": {
    "prefix": "hvue useRafFn - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Animation\r",
      "---\r",
      "\r",
      "# useRafFn\r",
      "\r",
      "Call function on every `requestAnimationFrame`. With controls of pausing and resuming.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { ref } from 'vue'\r",
      "import { useRafFn } from '@vueuse/core'\r",
      "\r",
      "const count = ref(0)\r",
      "\r",
      "const { pause, resume } = useRafFn(() => {\r",
      "  count.value++\r",
      "  console.log(count.value)\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { readonly, ref } from 'vue-demi'\r",
      "import type { Pausable } from '@vueuse/shared'\r",
      "import { tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface UseRafFnCallbackArguments {\r",
      "  /**\r",
      "   * Time elapsed between this and the last frame.\r",
      "   */\r",
      "  delta: number\r",
      "\r",
      "  /**\r",
      "   * Time elapsed since the creation of the web page. See {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#the_time_origin Time origin}.\r",
      "   */\r",
      "  timestamp: DOMHighResTimeStamp\r",
      "}\r",
      "\r",
      "export interface UseRafFnOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Start the requestAnimationFrame loop immediately on creation\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Call function on every `requestAnimationFrame`. With controls of pausing and resuming.\r",
      " *\r",
      " * @see https://vueuse.org/useRafFn\r",
      " * @param fn\r",
      " * @param options\r",
      " */\r",
      "export function useRafFn(fn: (args: UseRafFnCallbackArguments) => void, options: UseRafFnOptions = {}): Pausable {\r",
      "  const {\r",
      "    immediate = true,\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const isActive = ref(false)\r",
      "  let previousFrameTimestamp = 0\r",
      "  let rafId: null | number = null\r",
      "\r",
      "  function loop(timestamp: DOMHighResTimeStamp) {\r",
      "    if (!isActive.value || !window)\r",
      "      return\r",
      "\r",
      "    const delta = timestamp - (previousFrameTimestamp || timestamp)\r",
      "\r",
      "    fn({ delta, timestamp })\r",
      "\r",
      "    previousFrameTimestamp = timestamp\r",
      "    rafId = window.requestAnimationFrame(loop)\r",
      "  }\r",
      "\r",
      "  function resume() {\r",
      "    if (!isActive.value && window) {\r",
      "      isActive.value = true\r",
      "      rafId = window.requestAnimationFrame(loop)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function pause() {\r",
      "    isActive.value = false\r",
      "    if (rafId != null && window) {\r",
      "      window.cancelAnimationFrame(rafId)\r",
      "      rafId = null\r",
      "    }\r",
      "  }\r",
      "\r",
      "  if (immediate)\r",
      "    resume()\r",
      "\r",
      "  tryOnScopeDispose(pause)\r",
      "\r",
      "  return {\r",
      "    isActive: readonly(isActive),\r",
      "    pause,\r",
      "    resume,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useRafFn } from '@vueuse/core'\r",
      "\r",
      "const count = ref(0)\r",
      "const { pause, resume } = useRafFn(() => count.value += 1)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Count: {{ count }}</div>\r",
      "  <button @click=\"pause\">\r",
      "    pause\r",
      "  </button>\r",
      "  <button @click=\"resume\">\r",
      "    resume\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useRefHistory - vueuse": {
    "prefix": "hvue useRefHistory - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: State\r",
      "related: useManualRefHistory\r",
      "---\r",
      "\r",
      "# useRefHistory\r",
      "\r",
      "Track the change history of a ref, also provides undo and redo functionality\r",
      "\r",
      "<CourseLink href=\"https://vueschool.io/lessons/ref-history-with-vueuse?friend=vueuse\">Learn useRefHistory with this FREE video lesson from Vue School!</CourseLink>\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts {5}\r",
      "import { ref } from 'vue'\r",
      "import { useRefHistory } from '@vueuse/core'\r",
      "\r",
      "const counter = ref(0)\r",
      "const { history, undo, redo } = useRefHistory(counter)\r",
      "```\r",
      "\r",
      "Internally, `watch` is used to trigger a history point when the ref value is modified. This means that history points are triggered asynchronously batching modifications in the same \"tick\".\r",
      "\r",
      "```ts\r",
      "counter.value += 1\r",
      "\r",
      "await nextTick()\r",
      "console.log(history.value)\r",
      "/* [\r",
      "  { snapshot: 1, timestamp: 1601912898062 },\r",
      "  { snapshot: 0, timestamp: 1601912898061 }\r",
      "] */\r",
      "```\r",
      "\r",
      "You can use `undo` to reset the ref value to the last history point.\r",
      "\r",
      "```ts\r",
      "console.log(counter.value) // 1\r",
      "undo()\r",
      "console.log(counter.value) // 0\r",
      "```\r",
      "\r",
      "### Objects / arrays\r",
      "\r",
      "When working with objects or arrays, since changing their attributes does not change the reference, it will not trigger the committing. To track attribute changes, you would need to pass `deep: true`. It will create clones for each history record.\r",
      "\r",
      "```ts\r",
      "const state = ref({\r",
      "  foo: 1,\r",
      "  bar: 'bar',\r",
      "})\r",
      "\r",
      "const { history, undo, redo } = useRefHistory(state, {\r",
      "  deep: true,\r",
      "})\r",
      "\r",
      "state.value.foo = 2\r",
      "\r",
      "await nextTick()\r",
      "console.log(history.value)\r",
      "/* [\r",
      "  { snapshot: { foo: 2, bar: 'bar' } },\r",
      "  { snapshot: { foo: 1, bar: 'bar' } }\r",
      "] */\r",
      "```\r",
      "\r",
      "#### Custom Clone Function\r",
      "\r",
      "`useRefHistory` only embeds the minimal clone function `x => JSON.parse(JSON.stringify(x))`. To use a full featured or custom clone function, you can set up via the `clone` options.\r",
      "\r",
      "For example, using [structuredClone](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone):\r",
      "\r",
      "```ts\r",
      "import { useRefHistory } from '@vueuse/core'\r",
      "\r",
      "const refHistory = useRefHistory(target, { clone: structuredClone })\r",
      "```\r",
      "\r",
      "Or by using [lodash's `cloneDeep`](https://lodash.com/docs/4.17.15#cloneDeep):\r",
      "\r",
      "```ts\r",
      "import { cloneDeep } from 'lodash-es'\r",
      "import { useRefHistory } from '@vueuse/core'\r",
      "\r",
      "const refHistory = useRefHistory(target, { clone: cloneDeep })\r",
      "```\r",
      "\r",
      "Or a more lightweight [`klona`](https://github.com/lukeed/klona):\r",
      "\r",
      "```ts\r",
      "import { klona } from 'klona'\r",
      "import { useRefHistory } from '@vueuse/core'\r",
      "\r",
      "const refHistory = useRefHistory(target, { clone: klona })\r",
      "```\r",
      "\r",
      "#### Custom Dump and Parse Function\r",
      "\r",
      "Instead of using the `clone` options, you can pass custom functions to control the serialization and parsing. In case you do not need history values to be objects, this can save an extra clone when undoing. It is also useful in case you want to have the snapshots already stringified to be saved to local storage for example.\r",
      "\r",
      "```ts\r",
      "import { useRefHistory } from '@vueuse/core'\r",
      "\r",
      "const refHistory = useRefHistory(target, {\r",
      "  dump: JSON.stringify,\r",
      "  parse: JSON.parse,\r",
      "})\r",
      "```\r",
      "\r",
      "### History Capacity\r",
      "\r",
      "We will keep all the history by default (unlimited) until you explicitly clear them up, you can set the maximal amount of history to be kept by `capacity` options.\r",
      "\r",
      "```ts\r",
      "const refHistory = useRefHistory(target, {\r",
      "  capacity: 15, // limit to 15 history records\r",
      "})\r",
      "\r",
      "refHistory.clear() // explicitly clear all the history\r",
      "```\r",
      "\r",
      "### History Flush Timing\r",
      "\r",
      "From [Vue's documentation](https://vuejs.org/guide/essentials/watchers.html#callback-flush-timing): Vue's reactivity system buffers invalidated effects and flush them asynchronously to avoid unnecessary duplicate invocation when there are many state mutations happening in the same \"tick\".\r",
      "\r",
      "In the same way as `watch`, you can modify the flush timing using the `flush` option.\r",
      "\r",
      "```ts\r",
      "const refHistory = useRefHistory(target, {\r",
      "  flush: 'sync', // options 'pre' (default), 'post' and 'sync'\r",
      "})\r",
      "```\r",
      "\r",
      "The default is `'pre'`, to align this composable with the default for Vue's watchers. This also helps to avoid common issues, like several history points generated as part of a multi-step update to a ref value that can break invariants of the app state. You can use `commit()` in case you need to create multiple history points in the same \"tick\"\r",
      "\r",
      "```ts\r",
      "const r = ref(0)\r",
      "const { history, commit } = useRefHistory(r)\r",
      "\r",
      "r.value = 1\r",
      "commit()\r",
      "\r",
      "r.value = 2\r",
      "commit()\r",
      "\r",
      "console.log(history.value)\r",
      "/* [\r",
      "  { snapshot: 2 },\r",
      "  { snapshot: 1 },\r",
      "  { snapshot: 0 },\r",
      "] */\r",
      "```\r",
      "\r",
      "On the other hand, when using flush `'sync'`, you can use `batch(fn)` to generate a single history point for several sync operations\r",
      "\r",
      "```ts\r",
      "const r = ref({ names: [], version: 1 })\r",
      "const { history, batch } = useRefHistory(r, { flush: 'sync' })\r",
      "\r",
      "batch(() => {\r",
      "  r.value.names.push('Lena')\r",
      "  r.value.version++\r",
      "})\r",
      "\r",
      "console.log(history.value)\r",
      "/* [\r",
      "  { snapshot: { names: [ 'Lena' ], version: 2 },\r",
      "  { snapshot: { names: [], version: 1 },\r",
      "] */\r",
      "```\r",
      "\r",
      "If `{ flush: 'sync', deep: true }` is used, `batch` is also useful when doing a mutable `splice` in an array. `splice` can generate up to three atomic operations that will be pushed to the ref history.\r",
      "\r",
      "```ts\r",
      "const arr = ref([1, 2, 3])\r",
      "const { history, batch } = useRefHistory(arr, { deep: true, flush: 'sync' })\r",
      "\r",
      "batch(() => {\r",
      "  arr.value.splice(1, 1) // batch ensures only one history point is generated\r",
      "})\r",
      "```\r",
      "\r",
      "Another option is to avoid mutating the original ref value using `arr.value = [...arr.value].splice(1,1)`.\r",
      "\r",
      "## Recommended Readings\r",
      "\r",
      "- [History and Persistence](https://patak.dev/vue/history-and-persistence.html) - by [@matias-capeletto](https://github.com/matias-capeletto)\r",
      "# Source TS",
      "```js",
      "import type { ConfigurableEventFilter, Fn } from '@vueuse/shared'\r",
      "import { pausableFilter, watchIgnorable } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import type { CloneFn } from '../useCloned'\r",
      "import type { UseManualRefHistoryReturn } from '../useManualRefHistory'\r",
      "import { useManualRefHistory } from '../useManualRefHistory'\r",
      "\r",
      "export interface UseRefHistoryOptions<Raw, Serialized = Raw> extends ConfigurableEventFilter {\r",
      "  /**\r",
      "   * Watch for deep changes, default to false\r",
      "   *\r",
      "   * When set to true, it will also create clones for values store in the history\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  deep?: boolean\r",
      "\r",
      "  /**\r",
      "   * The flush option allows for greater control over the timing of a history point, default to 'pre'\r",
      "   *\r",
      "   * Possible values: 'pre', 'post', 'sync'\r",
      "   * It works in the same way as the flush option in watch and watch effect in vue reactivity\r",
      "   *\r",
      "   * @default 'pre'\r",
      "   */\r",
      "  flush?: 'pre' | 'post' | 'sync'\r",
      "\r",
      "  /**\r",
      "   * Maximum number of history to be kept. Default to unlimited.\r",
      "   */\r",
      "  capacity?: number\r",
      "\r",
      "  /**\r",
      "   * Clone when taking a snapshot, shortcut for dump: JSON.parse(JSON.stringify(value)).\r",
      "   * Default to false\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  clone?: boolean | CloneFn<Raw>\r",
      "  /**\r",
      "   * Serialize data into the history\r",
      "   */\r",
      "  dump?: (v: Raw) => Serialized\r",
      "  /**\r",
      "   * Deserialize data from the history\r",
      "   */\r",
      "  parse?: (v: Serialized) => Raw\r",
      "}\r",
      "\r",
      "export interface UseRefHistoryReturn<Raw, Serialized> extends UseManualRefHistoryReturn<Raw, Serialized> {\r",
      "  /**\r",
      "   * A ref representing if the tracking is enabled\r",
      "   */\r",
      "  isTracking: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * Pause change tracking\r",
      "   */\r",
      "  pause(): void\r",
      "\r",
      "  /**\r",
      "   * Resume change tracking\r",
      "   *\r",
      "   * @param [commit] if true, a history record will be create after resuming\r",
      "   */\r",
      "  resume(commit?: boolean): void\r",
      "\r",
      "  /**\r",
      "   * A sugar for auto pause and auto resuming within a function scope\r",
      "   *\r",
      "   * @param fn\r",
      "   */\r",
      "  batch(fn: (cancel: Fn) => void): void\r",
      "\r",
      "  /**\r",
      "   * Clear the data and stop the watch\r",
      "   */\r",
      "  dispose(): void\r",
      "}\r",
      "\r",
      "/**\r",
      " * Track the change history of a ref, also provides undo and redo functionality.\r",
      " *\r",
      " * @see https://vueuse.org/useRefHistory\r",
      " * @param source\r",
      " * @param options\r",
      " */\r",
      "export function useRefHistory<Raw, Serialized = Raw>(\r",
      "  source: Ref<Raw>,\r",
      "  options: UseRefHistoryOptions<Raw, Serialized> = {},\r",
      "): UseRefHistoryReturn<Raw, Serialized> {\r",
      "  const {\r",
      "    deep = false,\r",
      "    flush = 'pre',\r",
      "    eventFilter,\r",
      "  } = options\r",
      "\r",
      "  const {\r",
      "    eventFilter: composedFilter,\r",
      "    pause,\r",
      "    resume: resumeTracking,\r",
      "    isActive: isTracking,\r",
      "  } = pausableFilter(eventFilter)\r",
      "\r",
      "  const {\r",
      "    ignoreUpdates,\r",
      "    ignorePrevAsyncUpdates,\r",
      "    stop,\r",
      "  } = watchIgnorable(\r",
      "    source,\r",
      "    commit,\r",
      "    { deep, flush, eventFilter: composedFilter },\r",
      "  )\r",
      "\r",
      "  function setSource(source: Ref<Raw>, value: Raw) {\r",
      "    // Support changes that are done after the last history operation\r",
      "    // examples:\r",
      "    //   undo, modify\r",
      "    //   undo, undo, modify\r",
      "    // If there were already changes in the state, they will be ignored\r",
      "    // examples:\r",
      "    //   modify, undo\r",
      "    //   undo, modify, undo\r",
      "    ignorePrevAsyncUpdates()\r",
      "\r",
      "    ignoreUpdates(() => {\r",
      "      source.value = value\r",
      "    })\r",
      "  }\r",
      "\r",
      "  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource })\r",
      "\r",
      "  const { clear, commit: manualCommit } = manualHistory\r",
      "\r",
      "  function commit() {\r",
      "    // This guard only applies for flush 'pre' and 'post'\r",
      "    // If the user triggers a commit manually, then reset the watcher\r",
      "    // so we do not trigger an extra commit in the async watcher\r",
      "    ignorePrevAsyncUpdates()\r",
      "\r",
      "    manualCommit()\r",
      "  }\r",
      "\r",
      "  function resume(commitNow?: boolean) {\r",
      "    resumeTracking()\r",
      "    if (commitNow)\r",
      "      commit()\r",
      "  }\r",
      "\r",
      "  function batch(fn: (cancel: Fn) => void) {\r",
      "    let canceled = false\r",
      "\r",
      "    const cancel = () => canceled = true\r",
      "\r",
      "    ignoreUpdates(() => {\r",
      "      fn(cancel)\r",
      "    })\r",
      "\r",
      "    if (!canceled)\r",
      "      commit()\r",
      "  }\r",
      "\r",
      "  function dispose() {\r",
      "    stop()\r",
      "    clear()\r",
      "  }\r",
      "  return {\r",
      "    ...manualHistory,\r",
      "    isTracking,\r",
      "    pause,\r",
      "    resume,\r",
      "    commit,\r",
      "    batch,\r",
      "    dispose,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useCounter } from '@vueuse/shared'\r",
      "import { formatDate, useRefHistory } from '@vueuse/core'\r",
      "\r",
      "function format(ts: number) {\r",
      "  return formatDate(new Date(ts), 'YYYY-MM-DD HH:mm:ss')\r",
      "}\r",
      "\r",
      "const { count, inc, dec } = useCounter()\r",
      "const { history, undo, redo, canUndo, canRedo } = useRefHistory(count, { capacity: 10 })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Count: {{ count }}</div>\r",
      "  <button @click=\"inc()\">\r",
      "    Increment\r",
      "  </button>\r",
      "  <button @click=\"dec()\">\r",
      "    Decrement\r",
      "  </button>\r",
      "  <span class=\"ml-2\">/</span>\r",
      "  <button :disabled=\"!canUndo\" @click=\"undo()\">\r",
      "    Undo\r",
      "  </button>\r",
      "  <button :disabled=\"!canRedo\" @click=\"redo()\">\r",
      "    Redo\r",
      "  </button>\r",
      "  <br>\r",
      "  <br>\r",
      "  <note>History (limited to 10 records for demo)</note>\r",
      "  <div class=\"code-block mt-4\">\r",
      "    <div v-for=\"i in history\" :key=\"i.timestamp\">\r",
      "      <span class=\"opacity-50 mr-2 font-mono\">{{ format(i.timestamp) }}</span>\r",
      "      <span class=\"font-mono\">{ value: {{ i.snapshot }} }</span>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useResizeObserver - vueuse": {
    "prefix": "hvue useResizeObserver - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useResizeObserver\r",
      "\r",
      "Reports changes to the dimensions of an Element's content or the border-box\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html {16-20}\r",
      "<template>\r",
      "  <div ref=\"el\">\r",
      "    {{text}}\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<script>\r",
      "import { ref } from 'vue'\r",
      "import { useResizeObserver } from '@vueuse/core'\r",
      "\r",
      "export default {\r",
      "  setup() {\r",
      "    const el = ref(null)\r",
      "    const text = ref('')\r",
      "\r",
      "    useResizeObserver(el, (entries) => {\r",
      "      const entry = entries[0]\r",
      "      const { width, height } = entry.contentRect\r",
      "      text.value = `width: ${width}, height: ${height}`\r",
      "    })\r",
      "\r",
      "    return {\r",
      "      el,\r",
      "      text,\r",
      "    }\r",
      "  }\r",
      "}\r",
      "</script>\r",
      "```\r",
      "\r",
      "[ResizeObserver MDN](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)\r",
      "# Source TS",
      "```js",
      "import { tryOnScopeDispose } from '@vueuse/shared'\r",
      "import { computed, watch } from 'vue-demi'\r",
      "import type { MaybeComputedElementRef } from '../unrefElement'\r",
      "import { unrefElement } from '../unrefElement'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface ResizeObserverSize {\r",
      "  readonly inlineSize: number\r",
      "  readonly blockSize: number\r",
      "}\r",
      "\r",
      "export interface ResizeObserverEntry {\r",
      "  readonly target: Element\r",
      "  readonly contentRect: DOMRectReadOnly\r",
      "  readonly borderBoxSize?: ReadonlyArray<ResizeObserverSize>\r",
      "  readonly contentBoxSize?: ReadonlyArray<ResizeObserverSize>\r",
      "  readonly devicePixelContentBoxSize?: ReadonlyArray<ResizeObserverSize>\r",
      "}\r",
      "\r",
      "export type ResizeObserverCallback = (entries: ReadonlyArray<ResizeObserverEntry>, observer: ResizeObserver) => void\r",
      "\r",
      "export interface UseResizeObserverOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Sets which box model the observer will observe changes to. Possible values\r",
      "   * are `content-box` (the default), `border-box` and `device-pixel-content-box`.\r",
      "   *\r",
      "   * @default 'content-box'\r",
      "   */\r",
      "  box?: ResizeObserverBoxOptions\r",
      "}\r",
      "\r",
      "declare class ResizeObserver {\r",
      "  constructor(callback: ResizeObserverCallback)\r",
      "  disconnect(): void\r",
      "  observe(target: Element, options?: UseResizeObserverOptions): void\r",
      "  unobserve(target: Element): void\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reports changes to the dimensions of an Element's content or the border-box\r",
      " *\r",
      " * @see https://vueuse.org/useResizeObserver\r",
      " * @param target\r",
      " * @param callback\r",
      " * @param options\r",
      " */\r",
      "export function useResizeObserver(\r",
      "  target: MaybeComputedElementRef | MaybeComputedElementRef[],\r",
      "  callback: ResizeObserverCallback,\r",
      "  options: UseResizeObserverOptions = {},\r",
      ") {\r",
      "  const { window = defaultWindow, ...observerOptions } = options\r",
      "  let observer: ResizeObserver | undefined\r",
      "  const isSupported = useSupported(() => window && 'ResizeObserver' in window)\r",
      "\r",
      "  const cleanup = () => {\r",
      "    if (observer) {\r",
      "      observer.disconnect()\r",
      "      observer = undefined\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const targets = computed(() =>\r",
      "    Array.isArray(target)\r",
      "      ? target.map(el => unrefElement(el))\r",
      "      : [unrefElement(target)],\r",
      "  )\r",
      "\r",
      "  const stopWatch = watch(\r",
      "    targets,\r",
      "    (els) => {\r",
      "      cleanup()\r",
      "      if (isSupported.value && window) {\r",
      "        observer = new ResizeObserver(callback)\r",
      "        for (const _el of els)\r",
      "          _el && observer!.observe(_el, observerOptions)\r",
      "      }\r",
      "    },\r",
      "    { immediate: true, flush: 'post', deep: true },\r",
      "  )\r",
      "\r",
      "  const stop = () => {\r",
      "    cleanup()\r",
      "    stopWatch()\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(stop)\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    stop,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseResizeObserverReturn = ReturnType<typeof useResizeObserver>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useResizeObserver } from '@vueuse/core'\r",
      "\r",
      "const el = ref(null)\r",
      "const text = ref('')\r",
      "\r",
      "useResizeObserver(el, (entries) => {\r",
      "  const [entry] = entries\r",
      "  const { width, height } = entry.contentRect\r",
      "  text.value = `width: ${width}\\nheight: ${height}`\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    Resize the box to see changes\r",
      "  </note>\r",
      "  <textarea ref=\"el\" class=\"resizer\" disabled v-text=\"text\" />\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useScreenOrientation - vueuse": {
    "prefix": "hvue useScreenOrientation - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useScreenOrientation\r",
      "\r",
      "Reactive [Screen Orientation API](https://developer.mozilla.org/en-US/docs/Web/API/Screen_Orientation_API). It provides web developers with information about the user's current screen orientation.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useScreenOrientation } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isSupported,\r",
      "  orientation,\r",
      "  angle,\r",
      "  lockOrientation,\r",
      "  unlockOrientation,\r",
      "} = useScreenOrientation()\r",
      "```\r",
      "\r",
      "To lock the orientation, you can pass an [OrientationLockType](https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation/type) to the lockOrientation function:\r",
      "\r",
      "```ts\r",
      "import { useScreenOrientation } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isSupported,\r",
      "  orientation,\r",
      "  angle,\r",
      "  lockOrientation,\r",
      "  unlockOrientation,\r",
      "} = useScreenOrientation()\r",
      "\r",
      "lockOrientation('portrait-primary')\r",
      "```\r",
      "\r",
      "and then unlock again, with the following:\r",
      "\r",
      "```ts\r",
      "unlockOrientation()\r",
      "```\r",
      "\r",
      "Accepted orientation types are one of `\"landscape-primary\"`, `\"landscape-secondary\"`, `\"portrait-primary\"`, `\"portrait-secondary\"`, `\"any\"`, `\"landscape\"`, `\"natural\"` and `\"portrait\"`.\r",
      "\r",
      "[Screen Orientation API MDN](https://developer.mozilla.org/en-US/docs/Web/API/Screen_Orientation_API)\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Reactive screen orientation\r",
      " *\r",
      " * @see https://vueuse.org/useScreenOrientation\r",
      " */\r",
      "export function useScreenOrientation(options: ConfigurableWindow = {}) {\r",
      "  const {\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const isSupported = useSupported(() => window && 'screen' in window && 'orientation' in window.screen)\r",
      "\r",
      "  const screenOrientation = isSupported.value ? window!.screen.orientation : {} as ScreenOrientation\r",
      "\r",
      "  const orientation = ref<OrientationType | undefined>(screenOrientation.type)\r",
      "  const angle = ref(screenOrientation.angle || 0)\r",
      "\r",
      "  if (isSupported.value) {\r",
      "    useEventListener(window, 'orientationchange', () => {\r",
      "      orientation.value = screenOrientation.type\r",
      "      angle.value = screenOrientation.angle\r",
      "    })\r",
      "  }\r",
      "\r",
      "  const lockOrientation = (type: OrientationLockType) => {\r",
      "    if (!isSupported.value)\r",
      "      return Promise.reject(new Error('Not supported'))\r",
      "\r",
      "    return screenOrientation.lock(type)\r",
      "  }\r",
      "\r",
      "  const unlockOrientation = () => {\r",
      "    if (isSupported.value)\r",
      "      screenOrientation.unlock()\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    orientation,\r",
      "    angle,\r",
      "    lockOrientation,\r",
      "    unlockOrientation,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseScreenOrientationReturn = ReturnType<typeof useScreenOrientation>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useScreenOrientation } from '.'\r",
      "\r",
      "const { isSupported, orientation, angle } = useScreenOrientation()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    For best results, please use a mobile or tablet device (or use your browser's native inspector to simulate an\r",
      "    orientation change)\r",
      "  </note>\r",
      "  <div>\r",
      "    isSupported: <boolean-display :value=\"isSupported\">\r",
      "      {{ isSupported }}\r",
      "    </boolean-display>\r",
      "  </div>\r",
      "  <div>Orientation Type: <b>{{ orientation }}</b></div>\r",
      "  <div>Orientation Angle: <b>{{ angle }}</b></div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useScreenSafeArea - vueuse": {
    "prefix": "hvue useScreenSafeArea - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useScreenSafeArea\r",
      "\r",
      "Reactive `env(safe-area-inset-*)`\r",
      "\r",
      "![image](https://webkit.org/wp-content/uploads/safe-areas-1.png)\r",
      "\r",
      "## Usage\r",
      "\r",
      "In order to make the page to be fully rendered in the screen, the additional attribute `viewport-fit=cover` within  `viewport` meta tag must be set firstly, the viewport meta tag may look like this:\r",
      "\r",
      "```html\r",
      "<meta name='viewport' content='initial-scale=1, viewport-fit=cover'>\r",
      "```\r",
      "\r",
      "Then we could use `useScreenSafeArea` in the component as shown below:\r",
      "\r",
      "```ts\r",
      "import { useScreenSafeArea } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  top,\r",
      "  right,\r",
      "  bottom,\r",
      "  left,\r",
      "} = useScreenSafeArea()\r",
      "```\r",
      "\r",
      "For further details, you may refer to this documentation: [Designing Websites for iPhone X](https://webkit.org/blog/7929/designing-websites-for-iphone-x/)\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseScreenSafeArea top right bottom left>content</UseScreenSafeArea>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import { isClient, useDebounceFn } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useCssVar } from '../useCssVar'\r",
      "\r",
      "const topVarName = '--vueuse-safe-area-top'\r",
      "const rightVarName = '--vueuse-safe-area-right'\r",
      "const bottomVarName = '--vueuse-safe-area-bottom'\r",
      "const leftVarName = '--vueuse-safe-area-left'\r",
      "\r",
      "/**\r",
      " * Reactive `env(safe-area-inset-*)`\r",
      " *\r",
      " * @see https://vueuse.org/useScreenSafeArea\r",
      " */\r",
      "export function useScreenSafeArea() {\r",
      "  const top = ref('')\r",
      "  const right = ref('')\r",
      "  const bottom = ref('')\r",
      "  const left = ref('')\r",
      "\r",
      "  if (isClient) {\r",
      "    const topCssVar = useCssVar(topVarName)\r",
      "    const rightCssVar = useCssVar(rightVarName)\r",
      "    const bottomCssVar = useCssVar(bottomVarName)\r",
      "    const leftCssVar = useCssVar(leftVarName)\r",
      "\r",
      "    topCssVar.value = 'env(safe-area-inset-top, 0px)'\r",
      "    rightCssVar.value = 'env(safe-area-inset-right, 0px)'\r",
      "    bottomCssVar.value = 'env(safe-area-inset-bottom, 0px)'\r",
      "    leftCssVar.value = 'env(safe-area-inset-left, 0px)'\r",
      "\r",
      "    update()\r",
      "\r",
      "    useEventListener('resize', useDebounceFn(update))\r",
      "  }\r",
      "\r",
      "  function update() {\r",
      "    top.value = getValue(topVarName)\r",
      "    right.value = getValue(rightVarName)\r",
      "    bottom.value = getValue(bottomVarName)\r",
      "    left.value = getValue(leftVarName)\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    top,\r",
      "    right,\r",
      "    bottom,\r",
      "    left,\r",
      "    update,\r",
      "  }\r",
      "}\r",
      "\r",
      "type VarName = '--vueuse-safe-area-top' | '--vueuse-safe-area-right' | '--vueuse-safe-area-bottom' | '--vueuse-safe-area-left'\r",
      "\r",
      "function getValue(position: VarName) {\r",
      "  return getComputedStyle(document.documentElement).getPropertyValue(position)\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useScreenSafeArea } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  top,\r",
      "  right,\r",
      "  bottom,\r",
      "  left,\r",
      "} = useScreenSafeArea()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"inline-grid grid-cols-2 gap-x-4 gap-y-2\">\r",
      "    <div opacity=\"50\">\r",
      "      top:\r",
      "    </div>\r",
      "    <div>{{ top }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      right:\r",
      "    </div>\r",
      "    <div>{{ right }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      bottom:\r",
      "    </div>\r",
      "    <div>{{ bottom }}</div>\r",
      "    <div opacity=\"50\">\r",
      "      left:\r",
      "    </div>\r",
      "    <div>{{ left }}</div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useScroll - vueuse": {
    "prefix": "hvue useScroll - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useScroll\r",
      "\r",
      "Reactive scroll position and state.\r",
      "\r",
      "## Usage\r",
      "\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { useScroll } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "const { x, y, isScrolling, arrivedState, directions } = useScroll(el)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\"></div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### With offsets\r",
      "```js\r",
      "const { x, y, isScrolling, arrivedState, directions } = useScroll(el, {\r",
      "  offset: { top: 30, bottom: 30, right: 30, left: 30 },\r",
      "})\r",
      "```\r",
      "\r",
      "### Setting scroll position\r",
      "\r",
      "Set the `x` and `y` values to make the element scroll to that position.\r",
      "```vue\r",
      "<script setup lang=\"ts\">\r",
      "import { useScroll } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "const { x, y } = useScroll(el)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\" />\r",
      "  <button @click=\"x += 10\">\r",
      "    Scroll right 10px\r",
      "  </button>\r",
      "  <button @click=\"y += 10\">\r",
      "    Scroll down 10px\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Smooth scrolling\r",
      "\r",
      "Set `behavior: smooth` to enable smooth scrolling. The `behavior` option defaults to `auto`, which means no smooth scrolling. See the `behavior` option on [`window.scrollTo()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo) for more information.\r",
      "```ts\r",
      "import { useScroll } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "const { x, y } = useScroll(el, { behavior: 'smooth' })\r",
      "\r",
      "// Or as a `ref`:\r",
      "const smooth = ref(false)\r",
      "const behavior = computed(() => smooth.value ? 'smooth' : 'auto')\r",
      "const { x, y } = useScroll(el, { behavior })\r",
      "```\r",
      "\r",
      "## Directive Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import type { UseScrollReturn } from '@vueuse/core'\r",
      "import { vScroll } from '@vueuse/components'\r",
      "\r",
      "const data = ref([1, 2, 3, 4, 5, 6])\r",
      "\r",
      "function onScroll(state: UseScrollReturn) {\r",
      "  console.log(state) // {x, y, isScrolling, arrivedState, directions}\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div v-scroll=\"onScroll\">\r",
      "    <div v-for=\"item in data\" :key=\"item\">\r",
      "      {{ item }}\r",
      "    </div>\r",
      "  </div>\r",
      "\r",
      "  <!-- with options -->\r",
      "  <div v-scroll=\"[onScroll, { 'throttle' : 10 }]\">\r",
      "    <div v-for=\"item in data\" :key=\"item\">\r",
      "      {{ item }}\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed, reactive, ref } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { noop, toValue, useDebounceFn, useThrottleFn } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface UseScrollOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Throttle time for scroll event, it‚Äôs disabled by default.\r",
      "   *\r",
      "   * @default 0\r",
      "   */\r",
      "  throttle?: number\r",
      "\r",
      "  /**\r",
      "   * The check time when scrolling ends.\r",
      "   * This configuration will be setting to (throttle + idle) when the `throttle` is configured.\r",
      "   *\r",
      "   * @default 200\r",
      "   */\r",
      "  idle?: number\r",
      "\r",
      "  /**\r",
      "   * Offset arrived states by x pixels\r",
      "   *\r",
      "   */\r",
      "  offset?: {\r",
      "    left?: number\r",
      "    right?: number\r",
      "    top?: number\r",
      "    bottom?: number\r",
      "  }\r",
      "\r",
      "  /**\r",
      "   * Trigger it when scrolling.\r",
      "   *\r",
      "   */\r",
      "  onScroll?: (e: Event) => void\r",
      "\r",
      "  /**\r",
      "   * Trigger it when scrolling ends.\r",
      "   *\r",
      "   */\r",
      "  onStop?: (e: Event) => void\r",
      "\r",
      "  /**\r",
      "   * Listener options for scroll event.\r",
      "   *\r",
      "   * @default {capture: false, passive: true}\r",
      "   */\r",
      "  eventListenerOptions?: boolean | AddEventListenerOptions\r",
      "\r",
      "  /**\r",
      "   * Optionally specify a scroll behavior of `auto` (default, not smooth scrolling) or\r",
      "   * `smooth` (for smooth scrolling) which takes effect when changing the `x` or `y` refs.\r",
      "   *\r",
      "   * @default 'auto'\r",
      "   */\r",
      "  behavior?: MaybeRefOrGetter<ScrollBehavior>\r",
      "}\r",
      "\r",
      "/**\r",
      " * We have to check if the scroll amount is close enough to some threshold in order to\r",
      " * more accurately calculate arrivedState. This is because scrollTop/scrollLeft are non-rounded\r",
      " * numbers, while scrollHeight/scrollWidth and clientHeight/clientWidth are rounded.\r",
      " * https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#determine_if_an_element_has_been_totally_scrolled\r",
      " */\r",
      "const ARRIVED_STATE_THRESHOLD_PIXELS = 1\r",
      "\r",
      "/**\r",
      " * Reactive scroll.\r",
      " *\r",
      " * @see https://vueuse.org/useScroll\r",
      " * @param element\r",
      " * @param options\r",
      " */\r",
      "\r",
      "export function useScroll(\r",
      "  element: MaybeRefOrGetter<HTMLElement | SVGElement | Window | Document | null | undefined>,\r",
      "  options: UseScrollOptions = {},\r",
      ") {\r",
      "  const {\r",
      "    throttle = 0,\r",
      "    idle = 200,\r",
      "    onStop = noop,\r",
      "    onScroll = noop,\r",
      "    offset = {\r",
      "      left: 0,\r",
      "      right: 0,\r",
      "      top: 0,\r",
      "      bottom: 0,\r",
      "    },\r",
      "    eventListenerOptions = {\r",
      "      capture: false,\r",
      "      passive: true,\r",
      "    },\r",
      "    behavior = 'auto',\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const internalX = ref(0)\r",
      "  const internalY = ref(0)\r",
      "\r",
      "  // Use a computed for x and y because we want to write the value to the refs\r",
      "  // during a `scrollTo()` without firing additional `scrollTo()`s in the process.\r",
      "  const x = computed({\r",
      "    get() {\r",
      "      return internalX.value\r",
      "    },\r",
      "    set(x) {\r",
      "      scrollTo(x, undefined)\r",
      "    },\r",
      "  })\r",
      "\r",
      "  const y = computed({\r",
      "    get() {\r",
      "      return internalY.value\r",
      "    },\r",
      "    set(y) {\r",
      "      scrollTo(undefined, y)\r",
      "    },\r",
      "  })\r",
      "\r",
      "  function scrollTo(_x: number | undefined, _y: number | undefined) {\r",
      "    if (!window)\r",
      "      return\r",
      "\r",
      "    const _element = toValue(element)\r",
      "    if (!_element)\r",
      "      return\r",
      "\r",
      "    (_element instanceof Document ? window.document.body : _element)?.scrollTo({\r",
      "      top: toValue(_y) ?? y.value,\r",
      "      left: toValue(_x) ?? x.value,\r",
      "      behavior: toValue(behavior),\r",
      "    })\r",
      "  }\r",
      "\r",
      "  const isScrolling = ref(false)\r",
      "  const arrivedState = reactive({\r",
      "    left: true,\r",
      "    right: false,\r",
      "    top: true,\r",
      "    bottom: false,\r",
      "  })\r",
      "  const directions = reactive({\r",
      "    left: false,\r",
      "    right: false,\r",
      "    top: false,\r",
      "    bottom: false,\r",
      "  })\r",
      "\r",
      "  const onScrollEnd = (e: Event) => {\r",
      "    // dedupe if support native scrollend event\r",
      "    if (!isScrolling.value)\r",
      "      return\r",
      "\r",
      "    isScrolling.value = false\r",
      "    directions.left = false\r",
      "    directions.right = false\r",
      "    directions.top = false\r",
      "    directions.bottom = false\r",
      "    onStop(e)\r",
      "  }\r",
      "  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle)\r",
      "\r",
      "  const setArrivedState = (target: HTMLElement | SVGElement | Window | Document | null | undefined) => {\r",
      "    if (!window)\r",
      "      return\r",
      "\r",
      "    const el = (\r",
      "      target === window\r",
      "        ? (target as Window).document.documentElement\r",
      "        : target === window.document ? (target as Document).documentElement : target\r",
      "    ) as HTMLElement\r",
      "\r",
      "    const { display, flexDirection } = getComputedStyle(el)\r",
      "\r",
      "    const scrollLeft = el.scrollLeft\r",
      "    directions.left = scrollLeft < internalX.value\r",
      "    directions.right = scrollLeft > internalX.value\r",
      "\r",
      "    const left = Math.abs(scrollLeft) <= 0 + (offset.left || 0)\r",
      "    const right = Math.abs(scrollLeft)\r",
      "      + el.clientWidth >= el.scrollWidth\r",
      "      - (offset.right || 0)\r",
      "      - ARRIVED_STATE_THRESHOLD_PIXELS\r",
      "\r",
      "    if (display === 'flex' && flexDirection === 'row-reverse') {\r",
      "      arrivedState.left = right\r",
      "      arrivedState.right = left\r",
      "    }\r",
      "    else {\r",
      "      arrivedState.left = left\r",
      "      arrivedState.right = right\r",
      "    }\r",
      "\r",
      "    internalX.value = scrollLeft\r",
      "\r",
      "    let scrollTop = el.scrollTop\r",
      "\r",
      "    // patch for mobile compatible\r",
      "    if (target === window.document && !scrollTop)\r",
      "      scrollTop = window.document.body.scrollTop\r",
      "\r",
      "    directions.top = scrollTop < internalY.value\r",
      "    directions.bottom = scrollTop > internalY.value\r",
      "    const top = Math.abs(scrollTop) <= 0 + (offset.top || 0)\r",
      "    const bottom = Math.abs(scrollTop)\r",
      "      + el.clientHeight >= el.scrollHeight\r",
      "      - (offset.bottom || 0)\r",
      "      - ARRIVED_STATE_THRESHOLD_PIXELS\r",
      "\r",
      "    /**\r",
      "     * reverse columns and rows behave exactly the other way around,\r",
      "     * bottom is treated as top and top is treated as the negative version of bottom\r",
      "     */\r",
      "    if (display === 'flex' && flexDirection === 'column-reverse') {\r",
      "      arrivedState.top = bottom\r",
      "      arrivedState.bottom = top\r",
      "    }\r",
      "    else {\r",
      "      arrivedState.top = top\r",
      "      arrivedState.bottom = bottom\r",
      "    }\r",
      "\r",
      "    internalY.value = scrollTop\r",
      "  }\r",
      "\r",
      "  const onScrollHandler = (e: Event) => {\r",
      "    if (!window)\r",
      "      return\r",
      "\r",
      "    const eventTarget = (\r",
      "      e.target === window.document ? (e.target as Document).documentElement : e.target\r",
      "    ) as HTMLElement\r",
      "\r",
      "    setArrivedState(eventTarget)\r",
      "\r",
      "    isScrolling.value = true\r",
      "    onScrollEndDebounced(e)\r",
      "    onScroll(e)\r",
      "  }\r",
      "\r",
      "  useEventListener(\r",
      "    element,\r",
      "    'scroll',\r",
      "    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\r",
      "    eventListenerOptions,\r",
      "  )\r",
      "\r",
      "  useEventListener(\r",
      "    element,\r",
      "    'scrollend',\r",
      "    onScrollEnd,\r",
      "    eventListenerOptions,\r",
      "  )\r",
      "\r",
      "  return {\r",
      "    x,\r",
      "    y,\r",
      "    isScrolling,\r",
      "    arrivedState,\r",
      "    directions,\r",
      "    measure() {\r",
      "      const _element = toValue(element)\r",
      "\r",
      "      if (window && _element)\r",
      "        setArrivedState(_element)\r",
      "    },\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseScrollReturn = ReturnType<typeof useScroll>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, ref, toRefs } from 'vue'\r",
      "import { useScroll } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "const smooth = ref(false)\r",
      "const behavior = computed(() => smooth.value ? 'smooth' : 'auto')\r",
      "const { x, y, isScrolling, arrivedState, directions } = useScroll(el, { behavior })\r",
      "const { left, right, top, bottom } = toRefs(arrivedState)\r",
      "const { left: toLeft, right: toRight, top: toTop, bottom: toBottom } = toRefs(directions)\r",
      "\r",
      "// Format the numbers with toFixed() to make them\r",
      "// nicer to display\r",
      "const displayX = computed({\r",
      "  get() {\r",
      "    return x.value.toFixed(1)\r",
      "  },\r",
      "  set(val) {\r",
      "    x.value = Number.parseFloat(val)\r",
      "  },\r",
      "})\r",
      "const displayY = computed({\r",
      "  get() {\r",
      "    return y.value.toFixed(1)\r",
      "  },\r",
      "  set(val) {\r",
      "    y.value = Number.parseFloat(val)\r",
      "  },\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"flex\">\r",
      "    <div ref=\"el\" class=\"w-300px h-300px m-auto overflow-scroll bg-gray-500/5 rounded\">\r",
      "      <div class=\"w-500px h-400px relative\">\r",
      "        <div position=\"absolute left-0 top-0\" bg=\"gray-500/5\" p=\"x-2 y-1\">\r",
      "          TopLeft\r",
      "        </div>\r",
      "        <div position=\"absolute left-0 bottom-0\" bg=\"gray-500/5\" p=\"x-2 y-1\">\r",
      "          BottomLeft\r",
      "        </div>\r",
      "        <div position=\"absolute right-0 top-0\" bg=\"gray-500/5\" p=\"x-2 y-1\">\r",
      "          TopRight\r",
      "        </div>\r",
      "        <div position=\"absolute right-0 bottom-0\" bg=\"gray-500/5\" p=\"x-2 y-1\">\r",
      "          BottomRight\r",
      "        </div>\r",
      "        <div position=\"absolute left-1/3 top-1/3\" bg=\"gray-500/5\" p=\"x-2 y-1\">\r",
      "          Scroll Me\r",
      "        </div>\r",
      "      </div>\r",
      "    </div>\r",
      "    <div class=\"m-auto w-280px pl-4\">\r",
      "      <div class=\"px-6 py-4 rounded grid grid-cols-[120px_auto] gap-2 bg-gray-500/5\">\r",
      "        <span text=\"right\" opacity=\"75\" class=\"py-4\">X Position</span>\r",
      "        <div class=\"text-primary\">\r",
      "          <div>\r",
      "            <input v-model=\"displayX\" type=\"number\" min=\"0\" max=\"200\" step=\"10\" class=\"w-full !min-w-0\">\r",
      "          </div>\r",
      "        </div>\r",
      "        <span text=\"right\" opacity=\"75\" class=\"py-4\">Y Position</span>\r",
      "        <div class=\"text-primary\">\r",
      "          <div>\r",
      "            <input v-model=\"displayY\" type=\"number\" min=\"0\" max=\"100\" step=\"10\" class=\"w-full !min-w-0\">\r",
      "          </div>\r",
      "        </div>\r",
      "        <label for=\"smooth-scrolling-option\" text=\"right\" opacity=\"75\">Smooth scrolling</label>\r",
      "        <span><input id=\"smooth-scrolling-option\" v-model=\"smooth\" type=\"checkbox\"></span>\r",
      "        <span text=\"right\" opacity=\"75\">isScrolling</span>\r",
      "        <BooleanDisplay :value=\"isScrolling\" />\r",
      "        <div text=\"right\" opacity=\"75\">\r",
      "          Top Arrived\r",
      "        </div>\r",
      "        <BooleanDisplay :value=\"top\" />\r",
      "        <div text=\"right\" opacity=\"75\">\r",
      "          Right Arrived\r",
      "        </div>\r",
      "        <BooleanDisplay :value=\"right\" />\r",
      "        <div text=\"right\" opacity=\"75\">\r",
      "          Bottom Arrived\r",
      "        </div>\r",
      "        <BooleanDisplay :value=\"bottom\" />\r",
      "        <div text=\"right\" opacity=\"75\">\r",
      "          Left Arrived\r",
      "        </div>\r",
      "        <BooleanDisplay :value=\"left\" />\r",
      "        <div text=\"right\" opacity=\"75\">\r",
      "          Scrolling Up\r",
      "        </div>\r",
      "        <BooleanDisplay :value=\"toTop\" />\r",
      "        <div text=\"right\" opacity=\"75\">\r",
      "          Scrolling Right\r",
      "        </div>\r",
      "        <BooleanDisplay :value=\"toRight\" />\r",
      "        <div text=\"right\" opacity=\"75\">\r",
      "          Scrolling Down\r",
      "        </div>\r",
      "        <BooleanDisplay :value=\"toBottom\" />\r",
      "        <div text=\"right\" opacity=\"75\">\r",
      "          Scrolling Left\r",
      "        </div>\r",
      "        <BooleanDisplay :value=\"toLeft\" />\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useScrollLock - vueuse": {
    "prefix": "hvue useScrollLock - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useScrollLock\r",
      "\r",
      "Lock scrolling of the element. \r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { useScrollLock } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "const isLocked = useScrollLock(el)\r",
      "\r",
      "isLocked.value = true // lock\r",
      "isLocked.value = false // unlock\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\"></div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Directive Usage\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "import { vScrollLock } from '@vueuse/components'\r",
      "const data = ref([1, 2, 3, 4, 5, 6])\r",
      "const isLocked = ref(false)\r",
      "const toggleLock = useToggle(isLocked)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div v-scroll-lock=\"isLocked\">\r",
      "    <div v-for=\"item in data\" :key=\"item\">\r",
      "      {{ item }}\r",
      "    </div>\r",
      "  </div>\r",
      "  <button @click=\"toggleLock()\">\r",
      "    Toggle lock state\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed, ref, watch } from 'vue-demi'\r",
      "import type { Fn, MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { isIOS, toRef, toValue, tryOnScopeDispose } from '@vueuse/shared'\r",
      "\r",
      "import { useEventListener } from '../useEventListener'\r",
      "\r",
      "function checkOverflowScroll(ele: Element): boolean {\r",
      "  const style = window.getComputedStyle(ele)\r",
      "  if (\r",
      "    style.overflowX === 'scroll'\r",
      "    || style.overflowY === 'scroll'\r",
      "    || (style.overflowX === 'auto' && ele.clientWidth < ele.scrollWidth)\r",
      "    || (style.overflowY === 'auto' && ele.clientHeight < ele.scrollHeight)\r",
      "  ) {\r",
      "    return true\r",
      "  }\r",
      "  else {\r",
      "    const parent = ele.parentNode as Element\r",
      "\r",
      "    if (!parent || parent.tagName === 'BODY')\r",
      "      return false\r",
      "\r",
      "    return checkOverflowScroll(parent)\r",
      "  }\r",
      "}\r",
      "\r",
      "function preventDefault(rawEvent: TouchEvent): boolean {\r",
      "  const e = rawEvent || window.event\r",
      "\r",
      "  const _target = e.target as Element\r",
      "\r",
      "  // Do not prevent if element or parentNodes have overflow: scroll set.\r",
      "  if (checkOverflowScroll(_target))\r",
      "    return false\r",
      "\r",
      "  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\r",
      "  if (e.touches.length > 1)\r",
      "    return true\r",
      "\r",
      "  if (e.preventDefault)\r",
      "    e.preventDefault()\r",
      "\r",
      "  return false\r",
      "}\r",
      "\r",
      "/**\r",
      " * Lock scrolling of the element.\r",
      " *\r",
      " * @see https://vueuse.org/useScrollLock\r",
      " * @param element\r",
      " */\r",
      "export function useScrollLock(\r",
      "  element: MaybeRefOrGetter<HTMLElement | SVGElement | Window | Document | null | undefined>,\r",
      "  initialState = false,\r",
      ") {\r",
      "  const isLocked = ref(initialState)\r",
      "  let stopTouchMoveListener: Fn | null = null\r",
      "  let initialOverflow: CSSStyleDeclaration['overflow']\r",
      "\r",
      "  watch(toRef(element), (el) => {\r",
      "    if (el) {\r",
      "      const ele = el as HTMLElement\r",
      "      initialOverflow = ele.style.overflow\r",
      "      if (isLocked.value)\r",
      "        ele.style.overflow = 'hidden'\r",
      "    }\r",
      "  }, {\r",
      "    immediate: true,\r",
      "  })\r",
      "\r",
      "  const lock = () => {\r",
      "    const ele = (toValue(element) as HTMLElement)\r",
      "    if (!ele || isLocked.value)\r",
      "      return\r",
      "    if (isIOS) {\r",
      "      stopTouchMoveListener = useEventListener(\r",
      "        ele,\r",
      "        'touchmove',\r",
      "        (e) => { preventDefault(e as TouchEvent) },\r",
      "        { passive: false },\r",
      "      )\r",
      "    }\r",
      "    ele.style.overflow = 'hidden'\r",
      "    isLocked.value = true\r",
      "  }\r",
      "\r",
      "  const unlock = () => {\r",
      "    const ele = (toValue(element) as HTMLElement)\r",
      "    if (!ele || !isLocked.value)\r",
      "      return\r",
      "    isIOS && stopTouchMoveListener?.()\r",
      "    ele.style.overflow = initialOverflow\r",
      "    isLocked.value = false\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(unlock)\r",
      "\r",
      "  return computed<boolean>({\r",
      "    get() {\r",
      "      return isLocked.value\r",
      "    },\r",
      "    set(v) {\r",
      "      if (v)\r",
      "        lock()\r",
      "      else unlock()\r",
      "    },\r",
      "  })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useToggle } from '@vueuse/shared'\r",
      "import { useScroll, useScrollLock } from '@vueuse/core'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "useScroll(el)\r",
      "const isLocked = useScrollLock(el)\r",
      "const toggleLock = useToggle(isLocked)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"flex flex-wrap gap-4\">\r",
      "    <div ref=\"el\" class=\"w-300px h-300px m-auto overflow-scroll bg-gray-500/5 rounded\">\r",
      "      <div class=\"w-500px h-400px relative\">\r",
      "        <div position=\"absolute left-0 top-0\" bg=\"gray-500/5\" p=\"x-2 y-1\">\r",
      "          TopLeft\r",
      "        </div>\r",
      "        <div position=\"absolute left-0 bottom-0\" bg=\"gray-500/5\" p=\"x-2 y-1\">\r",
      "          BottomLeft\r",
      "        </div>\r",
      "        <div position=\"absolute right-0 top-0\" bg=\"gray-500/5\" p=\"x-2 y-1\">\r",
      "          TopRight\r",
      "        </div>\r",
      "        <div position=\"absolute right-0 bottom-0\" bg=\"gray-500/5\" p=\"x-2 y-1\">\r",
      "          BottomRight\r",
      "        </div>\r",
      "        <div position=\"absolute left-1/3 top-1/3\" bg=\"gray-500/5\" p=\"x-2 y-1\">\r",
      "          Scroll Me\r",
      "        </div>\r",
      "      </div>\r",
      "    </div>\r",
      "    <div class=\"m-auto px-6 py-4 rounded flex flex-col w-60 gap-2 bg-gray-500/5\">\r",
      "      <div>\r",
      "        <span opacity=\"75\">\r",
      "          isLocked\r",
      "        </span>\r",
      "        <BooleanDisplay :value=\"isLocked\" />\r",
      "      </div>\r",
      "      <button opacity=\"75\" @click=\"toggleLock()\">\r",
      "        {{ isLocked ? 'Unlock' : 'Lock' }}\r",
      "      </button>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useSorted - vueuse": {
    "prefix": "hvue useSorted - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Array\r",
      "---\r",
      "\r",
      "# useSorted\r",
      "\r",
      "reactive sort array\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useSorted } from '@vueuse/core'\r",
      "\r",
      "// general sort\r",
      "const source = [10, 3, 5, 7, 2, 1, 8, 6, 9, 4]\r",
      "const sorted = useSorted(source)\r",
      "console.log(sorted.value) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r",
      "console.log(source) // [10, 3, 5, 7, 2, 1, 8, 6, 9, 4]\r",
      "\r",
      "// object sort\r",
      "const objArr = [{\r",
      "  name: 'John',\r",
      "  age: 40,\r",
      "}, {\r",
      "  name: 'Jane',\r",
      "  age: 20,\r",
      "}, {\r",
      "  name: 'Joe',\r",
      "  age: 30,\r",
      "}, {\r",
      "  name: 'Jenny',\r",
      "  age: 22,\r",
      "}]\r",
      "const objSorted = useSorted(objArr, (a, b) => a.age - b.age)\r",
      "```\r",
      "### dirty mode\r",
      "\r",
      "dirty mode will change the source array.\r",
      "```ts\r",
      "const source = ref([10, 3, 5, 7, 2, 1, 8, 6, 9, 4])\r",
      "const sorted = useSorted(source, (a, b) => a - b, {\r",
      "  dirty: true,\r",
      "})\r",
      "console.log(source)// output: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import { computed, isRef, watchEffect } from 'vue-demi'\r",
      "\r",
      "export type UseSortedCompareFn<T = any> = (a: T, b: T) => number\r",
      "\r",
      "export type UseSortedFn<T = any> = (arr: T[], compareFn: UseSortedCompareFn<T>) => T[]\r",
      "\r",
      "export interface UseSortedOptions<T = any> {\r",
      "  /**\r",
      "   * sort algorithm\r",
      "   */\r",
      "  sortFn?: UseSortedFn<T>\r",
      "  /**\r",
      "   * compare function\r",
      "   */\r",
      "  compareFn?: UseSortedCompareFn<T>\r",
      "  /**\r",
      "   * change the value of the source array\r",
      "   * @default false\r",
      "   */\r",
      "  dirty?: boolean\r",
      "}\r",
      "\r",
      "const defaultSortFn: UseSortedFn = <T>(source: T[], compareFn: UseSortedCompareFn<T>): T[] => source.sort(compareFn)\r",
      "const defaultCompare: UseSortedCompareFn<number> = (a, b) => a - b\r",
      "\r",
      "export function useSorted<T = any>(source: MaybeRefOrGetter<T[]>, compareFn?: UseSortedCompareFn<T>): Ref<T[]>\r",
      "export function useSorted<T = any>(source: MaybeRefOrGetter<T[]>, options?: UseSortedOptions<T>): Ref<T[]>\r",
      "export function useSorted<T = any>(source: MaybeRefOrGetter<T[]>, compareFn?: UseSortedCompareFn<T>, options?: Omit<UseSortedOptions<T>, 'compareFn'>): Ref<T[]>\r",
      "/**\r",
      " * reactive sort array\r",
      " *\r",
      " * @see https://vueuse.org/useSorted\r",
      " * @param source source array\r",
      " * @param options\r",
      " */\r",
      "export function useSorted(...args: any[]) {\r",
      "  const [source] = args\r",
      "  let compareFn: UseSortedCompareFn = defaultCompare\r",
      "  let options: UseSortedOptions = {}\r",
      "\r",
      "  if (args.length === 2) {\r",
      "    if (typeof args[1] === 'object') {\r",
      "      options = args[1]\r",
      "      compareFn = options.compareFn ?? defaultCompare\r",
      "    }\r",
      "    else {\r",
      "      compareFn = args[1] ?? defaultCompare\r",
      "    }\r",
      "  }\r",
      "  else if (args.length > 2) {\r",
      "    compareFn = args[1] ?? defaultCompare\r",
      "    options = args[2] ?? {}\r",
      "  }\r",
      "\r",
      "  const {\r",
      "    dirty = false,\r",
      "    sortFn = defaultSortFn,\r",
      "  } = options\r",
      "\r",
      "  if (!dirty)\r",
      "    return computed(() => sortFn([...toValue(source)], compareFn))\r",
      "\r",
      "  // dirty\r",
      "  watchEffect(() => {\r",
      "    const result = sortFn(toValue(source), compareFn)\r",
      "    if (isRef(source))\r",
      "      source.value = result\r",
      "    else\r",
      "      source.splice(0, source.length, ...result)\r",
      "  })\r",
      "\r",
      "  return source\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { rand } from '@vueuse/shared'\r",
      "import { computed, ref } from 'vue'\r",
      "import { useSorted } from '.'\r",
      "\r",
      "const objArr = [{\r",
      "  name: 'John',\r",
      "  age: 40,\r",
      "}, {\r",
      "  name: 'Jane',\r",
      "  age: 20,\r",
      "}, {\r",
      "  name: 'Joe',\r",
      "  age: 30,\r",
      "}, {\r",
      "  name: 'Jenny',\r",
      "  age: 22,\r",
      "}]\r",
      "const result2 = useSorted(objArr, (a, b) => a.age - b.age)\r",
      "\r",
      "const arrText = ref('')\r",
      "const inputArr = computed(() => arrText.value.split(','))\r",
      "const inputOut = useSorted(inputArr)\r",
      "\r",
      "function randomArr() {\r",
      "  const arr = []\r",
      "  for (let i = 0; i < rand(10, 20); i++)\r",
      "    arr.push(rand(0, 100))\r",
      "  arrText.value = arr.join(',')\r",
      "}\r",
      "\r",
      "randomArr()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div class=\"flex items-center\">\r",
      "      input:\r",
      "      <input v-model=\"arrText\" type=\"text\">\r",
      "    </div>\r",
      "    <div>\r",
      "      <button @click=\"randomArr\">\r",
      "        random\r",
      "      </button>\r",
      "    </div>\r",
      "    output: {{ inputOut }}\r",
      "  </div>\r",
      "\r",
      "  <div class=\"mt-10\">\r",
      "    <div>object property sort:</div>\r",
      "    <div>input:</div>\r",
      "    <div>{{ objArr }}</div>\r",
      "    <div class=\"mt-5\">\r",
      "      output:\r",
      "    </div>\r",
      "    <div>{{ result2 }}</div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useSpeechRecognition - vueuse": {
    "prefix": "hvue useSpeechRecognition - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useSpeechRecognition\r",
      "\r",
      "Reactive [SpeechRecognition](https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition).\r",
      "\r",
      "> [Can I use?](https://caniuse.com/mdn-api_speechrecognitionevent)\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useSpeechRecognition } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isSupported,\r",
      "  isListening,\r",
      "  isFinal,\r",
      "  result,\r",
      "  start,\r",
      "  stop,\r",
      "} = useSpeechRecognition()\r",
      "```\r",
      "\r",
      "### Options\r",
      "\r",
      "The following shows the default values of the options, they will be directly passed to [SpeechRecognition API](https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition).\r",
      "\r",
      "```ts\r",
      "useSpeechRecognition({\r",
      "  lang: 'en-US',\r",
      "  interimResults: true,\r",
      "  continuous: true,\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "// ported from https://www.reddit.com/r/vuejs/comments/jksizl/speech_recognition_as_a_vue_3_hook\r",
      "// by https://github.com/wobsoriano\r",
      "\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toRef, toValue, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref, shallowRef, watch } from 'vue-demi'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import type { SpeechRecognition, SpeechRecognitionErrorEvent } from './types'\r",
      "\r",
      "export interface UseSpeechRecognitionOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Controls whether continuous results are returned for each recognition, or only a single result.\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  continuous?: boolean\r",
      "  /**\r",
      "   * Controls whether interim results should be returned (true) or not (false.) Interim results are results that are not yet final\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  interimResults?: boolean\r",
      "  /**\r",
      "   * Language for SpeechRecognition\r",
      "   *\r",
      "   * @default 'en-US'\r",
      "   */\r",
      "  lang?: MaybeRefOrGetter<string>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive SpeechRecognition.\r",
      " *\r",
      " * @see https://vueuse.org/useSpeechRecognition\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition SpeechRecognition\r",
      " * @param options\r",
      " */\r",
      "export function useSpeechRecognition(options: UseSpeechRecognitionOptions = {}) {\r",
      "  const {\r",
      "    interimResults = true,\r",
      "    continuous = true,\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const lang = toRef(options.lang || 'en-US')\r",
      "  const isListening = ref(false)\r",
      "  const isFinal = ref(false)\r",
      "  const result = ref('')\r",
      "  const error = shallowRef(undefined) as Ref<SpeechRecognitionErrorEvent | undefined>\r",
      "\r",
      "  const toggle = (value = !isListening.value) => {\r",
      "    isListening.value = value\r",
      "  }\r",
      "\r",
      "  const start = () => {\r",
      "    isListening.value = true\r",
      "  }\r",
      "\r",
      "  const stop = () => {\r",
      "    isListening.value = false\r",
      "  }\r",
      "\r",
      "  const SpeechRecognition = window && ((window as any).SpeechRecognition || (window as any).webkitSpeechRecognition)\r",
      "  const isSupported = useSupported(() => SpeechRecognition)\r",
      "\r",
      "  let recognition: SpeechRecognition | undefined\r",
      "\r",
      "  if (isSupported.value) {\r",
      "    recognition = new SpeechRecognition() as SpeechRecognition\r",
      "\r",
      "    recognition.continuous = continuous\r",
      "    recognition.interimResults = interimResults\r",
      "    recognition.lang = toValue(lang)\r",
      "\r",
      "    recognition.onstart = () => {\r",
      "      isFinal.value = false\r",
      "    }\r",
      "\r",
      "    watch(lang, (lang) => {\r",
      "      if (recognition && !isListening.value)\r",
      "        recognition.lang = lang\r",
      "    })\r",
      "\r",
      "    recognition.onresult = (event) => {\r",
      "      const transcript = Array.from(event.results)\r",
      "        .map((result) => {\r",
      "          isFinal.value = result.isFinal\r",
      "          return result[0]\r",
      "        })\r",
      "        .map(result => result.transcript)\r",
      "        .join('')\r",
      "\r",
      "      result.value = transcript\r",
      "      error.value = undefined\r",
      "    }\r",
      "\r",
      "    recognition.onerror = (event) => {\r",
      "      error.value = event\r",
      "    }\r",
      "\r",
      "    recognition.onend = () => {\r",
      "      isListening.value = false\r",
      "      recognition!.lang = toValue(lang)\r",
      "    }\r",
      "\r",
      "    watch(isListening, () => {\r",
      "      if (isListening.value)\r",
      "        recognition!.start()\r",
      "      else\r",
      "        recognition!.stop()\r",
      "    })\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(() => {\r",
      "    isListening.value = false\r",
      "  })\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    isListening,\r",
      "    isFinal,\r",
      "    recognition,\r",
      "    result,\r",
      "    error,\r",
      "\r",
      "    toggle,\r",
      "    start,\r",
      "    stop,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseSpeechRecognitionReturn = ReturnType<typeof useSpeechRecognition>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref, watch } from 'vue'\r",
      "import { useSpeechRecognition } from '@vueuse/core'\r",
      "\r",
      "const lang = ref('en-US')\r",
      "\r",
      "function sample<T>(arr: T[], size: number) {\r",
      "  const shuffled = arr.slice(0)\r",
      "  let i = arr.length\r",
      "  let temp: T\r",
      "  let index: number\r",
      "  while (i--) {\r",
      "    index = Math.floor((i + 1) * Math.random())\r",
      "    temp = shuffled[index]\r",
      "    shuffled[index] = shuffled[i]\r",
      "    shuffled[i] = temp\r",
      "  }\r",
      "  return shuffled.slice(0, size)\r",
      "}\r",
      "\r",
      "const colors = ['aqua', 'azure', 'beige', 'bisque', 'black', 'blue', 'brown', 'chocolate', 'coral', 'crimson', 'cyan', 'fuchsia', 'ghostwhite', 'gold', 'goldenrod', 'gray', 'green', 'indigo', 'ivory', 'khaki', 'lavender', 'lime', 'linen', 'magenta', 'maroon', 'moccasin', 'navy', 'olive', 'orange', 'orchid', 'peru', 'pink', 'plum', 'purple', 'red', 'salmon', 'sienna', 'silver', 'snow', 'tan', 'teal', 'thistle', 'tomato', 'turquoise', 'violet', 'white', 'yellow', 'transparent']\r",
      "const grammar = `#JSGF V1.0; grammar colors; public <color> = ${colors.join(' | ')} ;`\r",
      "\r",
      "const speech = useSpeechRecognition({\r",
      "  lang,\r",
      "  continuous: true,\r",
      "})\r",
      "\r",
      "const color = ref('transparent')\r",
      "\r",
      "if (speech.isSupported.value) {\r",
      "  // @ts-expect-error missing types\r",
      "  const SpeechGrammarList = window.SpeechGrammarList || window.webkitSpeechGrammarList\r",
      "  const speechRecognitionList = new SpeechGrammarList()\r",
      "  speechRecognitionList.addFromString(grammar, 1)\r",
      "  speech.recognition!.grammars = speechRecognitionList\r",
      "\r",
      "  watch(speech.result, () => {\r",
      "    for (const i of speech.result.value.toLowerCase().split(' ').reverse()) {\r",
      "      if (colors.includes(i)) {\r",
      "        color.value = i\r",
      "        break\r",
      "      }\r",
      "    }\r",
      "  })\r",
      "}\r",
      "\r",
      "const sampled = ref<string[]>([])\r",
      "\r",
      "function start() {\r",
      "  color.value = 'transparent'\r",
      "  speech.result.value = ''\r",
      "  sampled.value = sample(colors, 5)\r",
      "  speech.start()\r",
      "}\r",
      "\r",
      "const { isListening, isSupported, stop, result } = speech\r",
      "\r",
      "const selectedLanguage = ref(lang.value)\r",
      "watch(lang, lang => isListening.value ? null : selectedLanguage.value = lang)\r",
      "watch(isListening, isListening => isListening ? null : selectedLanguage.value = lang.value)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div v-if=\"!isSupported\">\r",
      "      Your browser does not support SpeechRecognition API,\r",
      "      <a\r",
      "        href=\"https://caniuse.com/mdn-api_speechrecognition\"\r",
      "        target=\"_blank\"\r",
      "      >more details</a>\r",
      "    </div>\r",
      "    <div v-else>\r",
      "      <div space-x-4>\r",
      "        <label class=\"radio\">\r",
      "          <input v-model=\"lang\" value=\"en-US\" type=\"radio\">\r",
      "          <span>English (US)</span>\r",
      "        </label>\r",
      "        <label class=\"radio\">\r",
      "          <input v-model=\"lang\" value=\"fr\" type=\"radio\">\r",
      "          <span>French</span>\r",
      "        </label>\r",
      "        <label class=\"radio\">\r",
      "          <input v-model=\"lang\" value=\"es\" type=\"radio\">\r",
      "          <span>Spanish</span>\r",
      "        </label>\r",
      "      </div>\r",
      "      <button v-if=\"!isListening\" @click=\"start\">\r",
      "        Press and talk\r",
      "      </button>\r",
      "      <button v-if=\"isListening\" class=\"orange\" @click=\"stop\">\r",
      "        Stop\r",
      "      </button>\r",
      "      <div v-if=\"isListening\" class=\"mt-4\">\r",
      "        <template v-if=\"selectedLanguage === 'en-US'\">\r",
      "          <note class=\"mb-2\">\r",
      "            <b>Please say a color</b>\r",
      "          </note>\r",
      "          <note class=\"mb-2\">\r",
      "            try: {{ sampled.join(', ') }}\r",
      "          </note>\r",
      "        </template>\r",
      "\r",
      "        <p v-else-if=\"selectedLanguage === 'es'\">\r",
      "          Speak some Spanish!\r",
      "        </p>\r",
      "\r",
      "        <p v-else-if=\"selectedLanguage === 'fr'\">\r",
      "          Speak some French!\r",
      "        </p>\r",
      "\r",
      "        <p\r",
      "          class=\"tag\"\r",
      "          :style=\"selectedLanguage === 'en-US' ? { background: color } : {}\"\r",
      "        >\r",
      "          {{ result }}\r",
      "        </p>\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<!-- <style scoped>\r",
      ".tag {\r",
      "  padding: 0.3rem 0.6rem;\r",
      "  margin-right: 0.5rem;\r",
      "  border-radius: 4px;\r",
      "}\r",
      "</style> -->\r",
      "\r",
      "<style scoped lang=\"postcss\">\r",
      "input {\r",
      "  --tw-ring-offset-width: 1px !important;\r",
      "  --tw-ring-color: #8885 !important;\r",
      "  --tw-ring-offset-color: transparent !important;\r",
      "}\r",
      "\r",
      ".radio {\r",
      "  @apply inline-flex items-center my-auto cursor-pointer select-none;\r",
      "}\r",
      "\r",
      ".radio input {\r",
      "  appearance: none;\r",
      "  padding: 0;\r",
      "  -webkit-print-color-adjust: exact;\r",
      "  color-adjust: exact;\r",
      "  display: inline-block;\r",
      "  vertical-align: middle;\r",
      "  background-origin: border-box;\r",
      "  user-select: none;\r",
      "  flex-shrink: 0;\r",
      "  height: 1rem;\r",
      "  width: 1rem;\r",
      "  @apply bg-gray-400/30;\r",
      "  @apply rounded-full h-4 w-4 select-none relative;\r",
      "  @apply mr-1;\r",
      "}\r",
      "\r",
      ".radio input:checked::after {\r",
      "  content: '';\r",
      "  @apply absolute inset-[3px] rounded-full bg-primary;\r",
      "}\r",
      "\r",
      ".checkbox span {\r",
      "  @apply ml-1.5 text-13px opacity-70;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useSpeechSynthesis - vueuse": {
    "prefix": "hvue useSpeechSynthesis - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useSpeechSynthesis\r",
      "\r",
      "Reactive [SpeechSynthesis](https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis).\r",
      "\r",
      "> [Can I use?](https://caniuse.com/mdn-api_speechsynthesis)\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useSpeechSynthesis } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  isSupported,\r",
      "  isPlaying,\r",
      "  status,\r",
      "  voiceInfo,\r",
      "  utterance,\r",
      "  error,\r",
      "  stop,\r",
      "\r",
      "  toggle,\r",
      "  speak,\r",
      "} = useSpeechSynthesis()\r",
      "```\r",
      "\r",
      "### Options\r",
      "\r",
      "The following shows the default values of the options, they will be directly passed to [SpeechSynthesis API](https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis).\r",
      "\r",
      "```ts\r",
      "useSpeechSynthesis({\r",
      "  lang: 'en-US',\r",
      "  pitch: 1,\r",
      "  rate: 1,\r",
      "  volume: 1,\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRef, MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toRef, toValue, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { computed, ref, shallowRef, watch } from 'vue-demi'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export type UseSpeechSynthesisStatus = 'init' | 'play' | 'pause' | 'end'\r",
      "\r",
      "export interface UseSpeechSynthesisOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Language for SpeechSynthesis\r",
      "   *\r",
      "   * @default 'en-US'\r",
      "   */\r",
      "  lang?: MaybeRefOrGetter<string>\r",
      "  /**\r",
      "   * Gets and sets the pitch at which the utterance will be spoken at.\r",
      "   *\r",
      "   * @default 1\r",
      "   */\r",
      "  pitch?: MaybeRefOrGetter<SpeechSynthesisUtterance['pitch']>\r",
      "  /**\r",
      "   * Gets and sets the speed at which the utterance will be spoken at.\r",
      "   *\r",
      "   * @default 1\r",
      "   */\r",
      "  rate?: MaybeRefOrGetter<SpeechSynthesisUtterance['rate']>\r",
      "  /**\r",
      "   * Gets and sets the voice that will be used to speak the utterance.\r",
      "   */\r",
      "  voice?: MaybeRef<SpeechSynthesisVoice>\r",
      "  /**\r",
      "   * Gets and sets the volume that the utterance will be spoken at.\r",
      "   *\r",
      "   * @default 1\r",
      "   */\r",
      "  volume?: SpeechSynthesisUtterance['volume']\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive SpeechSynthesis.\r",
      " *\r",
      " * @see https://vueuse.org/useSpeechSynthesis\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis SpeechSynthesis\r",
      " * @param options\r",
      " */\r",
      "export function useSpeechSynthesis(text: MaybeRefOrGetter<string>, options: UseSpeechSynthesisOptions = {}) {\r",
      "  const {\r",
      "    pitch = 1,\r",
      "    rate = 1,\r",
      "    volume = 1,\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const synth = window && (window as any).speechSynthesis as SpeechSynthesis\r",
      "  const isSupported = useSupported(() => synth)\r",
      "\r",
      "  const isPlaying = ref(false)\r",
      "  const status = ref<UseSpeechSynthesisStatus>('init')\r",
      "\r",
      "  const spokenText = toRef(text || '')\r",
      "  const lang = toRef(options.lang || 'en-US')\r",
      "  const error = shallowRef(undefined) as Ref<SpeechSynthesisErrorEvent | undefined>\r",
      "\r",
      "  const toggle = (value = !isPlaying.value) => {\r",
      "    isPlaying.value = value\r",
      "  }\r",
      "\r",
      "  const bindEventsForUtterance = (utterance: SpeechSynthesisUtterance) => {\r",
      "    utterance.lang = toValue(lang)\r",
      "    utterance.voice = toValue(options.voice) || null\r",
      "    utterance.pitch = toValue(pitch)\r",
      "    utterance.rate = toValue(rate)\r",
      "    utterance.volume = volume\r",
      "\r",
      "    utterance.onstart = () => {\r",
      "      isPlaying.value = true\r",
      "      status.value = 'play'\r",
      "    }\r",
      "\r",
      "    utterance.onpause = () => {\r",
      "      isPlaying.value = false\r",
      "      status.value = 'pause'\r",
      "    }\r",
      "\r",
      "    utterance.onresume = () => {\r",
      "      isPlaying.value = true\r",
      "      status.value = 'play'\r",
      "    }\r",
      "\r",
      "    utterance.onend = () => {\r",
      "      isPlaying.value = false\r",
      "      status.value = 'end'\r",
      "    }\r",
      "\r",
      "    utterance.onerror = (event) => {\r",
      "      error.value = event\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const utterance = computed(() => {\r",
      "    isPlaying.value = false\r",
      "    status.value = 'init'\r",
      "    const newUtterance = new SpeechSynthesisUtterance(spokenText.value)\r",
      "    bindEventsForUtterance(newUtterance)\r",
      "    return newUtterance\r",
      "  })\r",
      "\r",
      "  const speak = () => {\r",
      "    synth!.cancel()\r",
      "    utterance && synth!.speak(utterance.value)\r",
      "  }\r",
      "\r",
      "  const stop = () => {\r",
      "    synth!.cancel()\r",
      "    isPlaying.value = false\r",
      "  }\r",
      "\r",
      "  if (isSupported.value) {\r",
      "    bindEventsForUtterance(utterance.value)\r",
      "\r",
      "    watch(lang, (lang) => {\r",
      "      if (utterance.value && !isPlaying.value)\r",
      "        utterance.value.lang = lang\r",
      "    })\r",
      "\r",
      "    if (options.voice) {\r",
      "      watch(options.voice, () => {\r",
      "        synth!.cancel()\r",
      "      })\r",
      "    }\r",
      "\r",
      "    watch(isPlaying, () => {\r",
      "      if (isPlaying.value)\r",
      "        synth!.resume()\r",
      "      else\r",
      "        synth!.pause()\r",
      "    })\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(() => {\r",
      "    isPlaying.value = false\r",
      "  })\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    isPlaying,\r",
      "    status,\r",
      "    utterance,\r",
      "    error,\r",
      "\r",
      "    stop,\r",
      "    toggle,\r",
      "    speak,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseSpeechSynthesisReturn = ReturnType<typeof useSpeechSynthesis>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { onMounted, ref } from 'vue'\r",
      "import { useSpeechSynthesis } from '@vueuse/core'\r",
      "\r",
      "const voice = ref<SpeechSynthesisVoice>(undefined as unknown as SpeechSynthesisVoice)\r",
      "const text = ref('Hello, everyone! Good morning!')\r",
      "const pitch = ref(1)\r",
      "const rate = ref(1)\r",
      "\r",
      "const speech = useSpeechSynthesis(text, {\r",
      "  voice,\r",
      "  pitch,\r",
      "  rate,\r",
      "})\r",
      "\r",
      "let synth: SpeechSynthesis\r",
      "\r",
      "const voices = ref<SpeechSynthesisVoice[]>([])\r",
      "\r",
      "onMounted(() => {\r",
      "  if (speech.isSupported.value) {\r",
      "  // load at last\r",
      "    setTimeout(() => {\r",
      "      synth = window.speechSynthesis\r",
      "      voices.value = synth.getVoices()\r",
      "      voice.value = voices.value[0]\r",
      "    })\r",
      "  }\r",
      "})\r",
      "\r",
      "function play() {\r",
      "  if (speech.status.value === 'pause') {\r",
      "    console.log('resume')\r",
      "    window.speechSynthesis.resume()\r",
      "  }\r",
      "  else {\r",
      "    speech.speak()\r",
      "  }\r",
      "}\r",
      "\r",
      "function pause() {\r",
      "  window.speechSynthesis.pause()\r",
      "}\r",
      "\r",
      "function stop() {\r",
      "  speech.stop()\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div v-if=\"!speech.isSupported\">\r",
      "      Your browser does not support SpeechSynthesis API,\r",
      "      <a\r",
      "        href=\"https://caniuse.com/mdn-api_speechsynthesis\"\r",
      "        target=\"_blank\"\r",
      "      >more details</a>\r",
      "    </div>\r",
      "    <div v-else>\r",
      "      <label class=\"font-bold mr-2\">Spoken Text</label>\r",
      "      <input v-model=\"text\" class=\"!inline-block\" type=\"text\">\r",
      "\r",
      "      <br>\r",
      "      <label class=\"font-bold mr-2\">Language</label>\r",
      "      <div bg=\"$vp-c-bg\" border=\"$vp-c-divider 1\" inline-flex items-center relative rounded>\r",
      "        <i i-carbon-language absolute left-2 opacity-80 pointer-events-none />\r",
      "        <select v-model=\"voice\" px-8 border-0 bg-transparent h-9 rounded appearance-none>\r",
      "          <option bg=\"$vp-c-bg\" disabled>\r",
      "            Select Language\r",
      "          </option>\r",
      "          <option\r",
      "            v-for=\"(voice, i) in voices\"\r",
      "            :key=\"i\"\r",
      "            bg=\"$vp-c-bg\"\r",
      "            :value=\"voice\"\r",
      "          >\r",
      "            {{ `${voice.name} (${voice.lang})` }}\r",
      "          </option>\r",
      "        </select>\r",
      "        <i i-carbon-chevron-down absolute right-2 opacity-80 pointer-events-none />\r",
      "      </div>\r",
      "\r",
      "      <br>\r",
      "      <div inline-flex items-center>\r",
      "        <label class=\"font-bold mr-2\">Pitch</label>\r",
      "        <div class=\"mt-1\" inline-flex>\r",
      "          <input v-model=\"pitch\" type=\"range\" min=\"0.5\" max=\"2\" step=\"0.1\">\r",
      "        </div>\r",
      "      </div>\r",
      "\r",
      "      <br>\r",
      "      <div inline-flex items-center>\r",
      "        <label class=\"font-bold mr-3\">Rate</label>\r",
      "        <div class=\"mt-1\" inline-flex>\r",
      "          <input v-model=\"rate\" type=\"range\" min=\"0.5\" max=\"2\" step=\"0.1\">\r",
      "        </div>\r",
      "      </div>\r",
      "\r",
      "      <div class=\"mt-2\">\r",
      "        <button\r",
      "          :disabled=\"speech.isPlaying.value\"\r",
      "          @click=\"play\"\r",
      "        >\r",
      "          {{ speech.status.value === 'pause' ? 'Resume' : 'Speak' }}\r",
      "        </button>\r",
      "        <button :disabled=\"!speech.isPlaying.value\" class=\"orange\" @click=\"pause\">\r",
      "          Pause\r",
      "        </button>\r",
      "        <button :disabled=\"!speech.isPlaying.value\" class=\"red\" @click=\"stop\">\r",
      "          Stop\r",
      "        </button>\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useStepper - vueuse": {
    "prefix": "hvue useStepper - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useStepper\r",
      "\r",
      "Provides helpers for building a multi-step wizard interface.\r",
      "\r",
      "## Usage\r",
      "\r",
      "### Steps as array\r",
      "\r",
      "```js\r",
      "import { useStepper } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  steps,\r",
      "  stepNames,\r",
      "  index,\r",
      "  current,\r",
      "  next,\r",
      "  previous,\r",
      "  isFirst,\r",
      "  isLast,\r",
      "  goTo,\r",
      "  goToNext,\r",
      "  goToPrevious,\r",
      "  goBackTo,\r",
      "  isNext,\r",
      "  isPrevious,\r",
      "  isCurrent,\r",
      "  isBefore,\r",
      "  isAfter,\r",
      "} = useStepper([\r",
      "  'billing-address',\r",
      "  'terms',\r",
      "  'payment',\r",
      "])\r",
      "\r",
      "// Access the step through `current`\r",
      "console.log(current.value) // 'billing-address'\r",
      "```\r",
      "\r",
      "### Steps as object\r",
      "\r",
      "```js\r",
      "import { useStepper } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  steps,\r",
      "  stepNames,\r",
      "  index,\r",
      "  current,\r",
      "  next,\r",
      "  previous,\r",
      "  isFirst,\r",
      "  isLast,\r",
      "  goTo,\r",
      "  goToNext,\r",
      "  goToPrevious,\r",
      "  goBackTo,\r",
      "  isNext,\r",
      "  isPrevious,\r",
      "  isCurrent,\r",
      "  isBefore,\r",
      "  isAfter,\r",
      "} = useStepper({\r",
      "  'user-information': {\r",
      "    title: 'User information',\r",
      "  },\r",
      "  'billing-address': {\r",
      "    title: 'Billing address',\r",
      "  },\r",
      "  'terms': {\r",
      "    title: 'Terms',\r",
      "  },\r",
      "  'payment': {\r",
      "    title: 'Payment',\r",
      "  },\r",
      "})\r",
      "\r",
      "// Access the step object through `current`\r",
      "console.log(current.value.title) // 'User information'\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRef } from '@vueuse/shared'\r",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { computed, ref } from 'vue-demi'\r",
      "\r",
      "export interface UseStepperReturn<StepName, Steps, Step> {\r",
      "  /** List of steps. */\r",
      "  steps: Readonly<Ref<Steps>>\r",
      "  /** List of step names. */\r",
      "  stepNames: Readonly<Ref<StepName[]>>\r",
      "  /** Index of the current step. */\r",
      "  index: Ref<number>\r",
      "  /** Current step. */\r",
      "  current: ComputedRef<Step>\r",
      "  /** Next step, or undefined if the current step is the last one. */\r",
      "  next: ComputedRef<StepName | undefined>\r",
      "  /** Previous step, or undefined if the current step is the first one. */\r",
      "  previous: ComputedRef<StepName | undefined>\r",
      "  /** Whether the current step is the first one. */\r",
      "  isFirst: ComputedRef<boolean>\r",
      "  /** Whether the current step is the last one. */\r",
      "  isLast: ComputedRef<boolean>\r",
      "  /** Get the step at the specified index. */\r",
      "  at: (index: number) => Step | undefined\r",
      "  /** Get a step by the specified name. */\r",
      "  get: (step: StepName) => Step | undefined\r",
      "  /** Go to the specified step. */\r",
      "  goTo: (step: StepName) => void\r",
      "  /** Go to the next step. Does nothing if the current step is the last one. */\r",
      "  goToNext: () => void\r",
      "  /** Go to the previous step. Does nothing if the current step is the previous one. */\r",
      "  goToPrevious: () => void\r",
      "  /** Go back to the given step, only if the current step is after. */\r",
      "  goBackTo: (step: StepName) => void\r",
      "  /** Checks whether the given step is the next step. */\r",
      "  isNext: (step: StepName) => boolean\r",
      "  /** Checks whether the given step is the previous step. */\r",
      "  isPrevious: (step: StepName) => boolean\r",
      "  /** Checks whether the given step is the current step. */\r",
      "  isCurrent: (step: StepName) => boolean\r",
      "  /** Checks if the current step is before the given step. */\r",
      "  isBefore: (step: StepName) => boolean\r",
      "  /** Checks if the current step is after the given step. */\r",
      "  isAfter: (step: StepName) => boolean\r",
      "}\r",
      "\r",
      "export function useStepper<T extends string | number>(steps: MaybeRef<T[]>, initialStep?: T): UseStepperReturn<T, T[], T>\r",
      "export function useStepper<T extends Record<string, any>>(steps: MaybeRef<T>, initialStep?: keyof T): UseStepperReturn<Exclude<keyof T, symbol>, T, T[keyof T]>\r",
      "export function useStepper(steps: any, initialStep?: any): UseStepperReturn<any, any, any> {\r",
      "  const stepsRef = ref<any[]>(steps)\r",
      "  const stepNames = computed<any[]>(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value))\r",
      "  const index = ref(stepNames.value.indexOf(initialStep ?? stepNames.value[0]))\r",
      "  const current = computed(() => at(index.value))\r",
      "  const isFirst = computed(() => index.value === 0)\r",
      "  const isLast = computed(() => index.value === stepNames.value.length - 1)\r",
      "  const next = computed(() => stepNames.value[index.value + 1])\r",
      "  const previous = computed(() => stepNames.value[index.value - 1])\r",
      "\r",
      "  function at(index: number) {\r",
      "    if (Array.isArray(stepsRef.value))\r",
      "      return stepsRef.value[index]\r",
      "\r",
      "    return stepsRef.value[stepNames.value[index]]\r",
      "  }\r",
      "\r",
      "  function get(step: any) {\r",
      "    if (!stepNames.value.includes(step))\r",
      "      return\r",
      "\r",
      "    return at(stepNames.value.indexOf(step))\r",
      "  }\r",
      "\r",
      "  function goTo(step: any) {\r",
      "    if (stepNames.value.includes(step))\r",
      "      index.value = stepNames.value.indexOf(step)\r",
      "  }\r",
      "\r",
      "  function goToNext() {\r",
      "    if (isLast.value)\r",
      "      return\r",
      "\r",
      "    index.value++\r",
      "  }\r",
      "\r",
      "  function goToPrevious() {\r",
      "    if (isFirst.value)\r",
      "      return\r",
      "\r",
      "    index.value--\r",
      "  }\r",
      "\r",
      "  function goBackTo(step: any) {\r",
      "    if (isAfter(step))\r",
      "      goTo(step)\r",
      "  }\r",
      "\r",
      "  function isNext(step: any) {\r",
      "    return stepNames.value.indexOf(step) === index.value + 1\r",
      "  }\r",
      "\r",
      "  function isPrevious(step: any) {\r",
      "    return stepNames.value.indexOf(step) === index.value - 1\r",
      "  }\r",
      "\r",
      "  function isCurrent(step: any) {\r",
      "    return stepNames.value.indexOf(step) === index.value\r",
      "  }\r",
      "\r",
      "  function isBefore(step: any) {\r",
      "    return index.value < stepNames.value.indexOf(step)\r",
      "  }\r",
      "\r",
      "  function isAfter(step: any) {\r",
      "    return index.value > stepNames.value.indexOf(step)\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    steps: stepsRef,\r",
      "    stepNames,\r",
      "    index,\r",
      "    current,\r",
      "    next,\r",
      "    previous,\r",
      "    isFirst,\r",
      "    isLast,\r",
      "    at,\r",
      "    get,\r",
      "    goTo,\r",
      "    goToNext,\r",
      "    goToPrevious,\r",
      "    goBackTo,\r",
      "    isNext,\r",
      "    isPrevious,\r",
      "    isCurrent,\r",
      "    isBefore,\r",
      "    isAfter,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useStepper } from '@vueuse/core'\r",
      "import { reactive } from 'vue'\r",
      "\r",
      "const form = reactive({\r",
      "  firstName: 'Jon',\r",
      "  lastName: '',\r",
      "  billingAddress: '',\r",
      "  contractAccepted: false,\r",
      "  carbonOffsetting: false,\r",
      "  payment: 'credit-card' as 'paypal' | 'credit-card',\r",
      "})\r",
      "\r",
      "const stepper = useStepper({\r",
      "  'user-information': {\r",
      "    title: 'User information',\r",
      "    isValid: () => form.firstName && form.lastName,\r",
      "  },\r",
      "  'billing-address': {\r",
      "    title: 'Billing address',\r",
      "    isValid: () => form.billingAddress?.trim() !== '',\r",
      "  },\r",
      "  'terms': {\r",
      "    title: 'Terms',\r",
      "    isValid: () => form.contractAccepted === true,\r",
      "  },\r",
      "  'payment': {\r",
      "    title: 'Payment',\r",
      "    isValid: () => ['credit-card', 'paypal'].includes(form.payment),\r",
      "  },\r",
      "})\r",
      "\r",
      "function submit() {\r",
      "  if (stepper.current.value.isValid())\r",
      "    stepper.goToNext()\r",
      "}\r",
      "\r",
      "function allStepsBeforeAreValid(index: number): boolean {\r",
      "  return !Array(index)\r",
      "    .fill(null)\r",
      "    .some((_, i) => !stepper.at(i)?.isValid())\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div class=\"flex gap-2 justify-center\">\r",
      "      <div v-for=\"(step, id, i) in stepper.steps.value\" :key=\"id\" class=\"\">\r",
      "        <button\r",
      "          :disabled=\"!allStepsBeforeAreValid(i) && stepper.isBefore(id)\"\r",
      "          @click=\"stepper.goTo(id)\"\r",
      "          v-text=\"step.title\"\r",
      "        />\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <form class=\"mt-10\" @submit.prevent=\"submit\">\r",
      "      <span class=\"text-lg font-bold\" v-text=\"stepper.current.value.title\" />\r",
      "      <div class=\"flex flex-col justify-center gap-2 mt-2\">\r",
      "        <div>\r",
      "          <div v-if=\"stepper.isCurrent('user-information')\">\r",
      "            <span>First name:</span>\r",
      "            <input v-model=\"form.firstName\" class=\"!mt-0.5\" type=\"text\">\r",
      "            <span>Last name:</span>\r",
      "            <input v-model=\"form.lastName\" class=\"!mt-0.5\" type=\"text\">\r",
      "          </div>\r",
      "\r",
      "          <div v-if=\"stepper.isCurrent('billing-address')\">\r",
      "            <input v-model=\"form.billingAddress\" type=\"text\">\r",
      "          </div>\r",
      "\r",
      "          <div v-if=\"stepper.isCurrent('terms')\">\r",
      "            <div>\r",
      "              <input id=\"carbon-offsetting\" v-model=\"form.carbonOffsetting\" type=\"checkbox\" class=\"mr-2\">\r",
      "              <label for=\"carbon-offsetting\">I accept to deposit a carbon offsetting fee</label>\r",
      "            </div>\r",
      "            <div>\r",
      "              <input id=\"contract\" v-model=\"form.contractAccepted\" type=\"checkbox\" class=\"mr-2\">\r",
      "              <label for=\"contract\">I accept the terms of the contract</label>\r",
      "            </div>\r",
      "          </div>\r",
      "\r",
      "          <div v-if=\"stepper.isCurrent('payment')\">\r",
      "            <div>\r",
      "              <input id=\"credit-card\" v-model=\"form.payment\" type=\"radio\" class=\"mr-2\" value=\"credit-card\">\r",
      "              <label for=\"credit-card\">Credit card</label>\r",
      "            </div>\r",
      "            <div>\r",
      "              <input id=\"paypal\" v-model=\"form.payment\" type=\"radio\" class=\"mr-2\" value=\"paypal\">\r",
      "              <label for=\"paypal\">PayPal</label>\r",
      "            </div>\r",
      "          </div>\r",
      "        </div>\r",
      "\r",
      "        <div>\r",
      "          <button v-if=\"!stepper.isLast.value\" :disabled=\"!stepper.current.value.isValid()\">\r",
      "            Next\r",
      "          </button>\r",
      "          <button v-if=\"stepper.isLast.value\" :disabled=\"!stepper.current.value.isValid()\">\r",
      "            Submit\r",
      "          </button>\r",
      "        </div>\r",
      "      </div>\r",
      "    </form>\r",
      "\r",
      "    <div class=\"flex flex-col gap-4 mt-12\">\r",
      "      <div class=\"w-full px-4 py-2 rounded border border-main space-y-2 overflow-auto h-full\">\r",
      "        <span class=\"font-bold\">Form</span>\r",
      "        <pre v-text=\"form\" />\r",
      "      </div>\r",
      "\r",
      "      <div class=\"w-full px-4 py-2 rounded border border-main space-y-2 overflow-auto h-full\">\r",
      "        <span class=\"font-bold\">Wizard</span>\r",
      "        <pre v-text=\"stepper\" />\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useStorage - vueuse": {
    "prefix": "hvue useStorage - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: State\r",
      "related: useLocalStorage, useSessionStorage, useStorageAsync\r",
      "---\r",
      "\r",
      "# useStorage\r",
      "\r",
      "Reactive [LocalStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)/[SessionStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage)\r",
      "\r",
      "## Usage\r",
      "\r",
      "::: tip\r",
      "When using with Nuxt 3, this functions will **NOT** be auto imported in favor of Nitro's built-in [`useStorage()`](https://nitro.unjs.io/guide/storage). Use explicit import if you want to use the function from VueUse.\r",
      ":::\r",
      "\r",
      "```js\r",
      "import { useStorage } from '@vueuse/core'\r",
      "\r",
      "// bind object\r",
      "const state = useStorage('my-store', { hello: 'hi', greeting: 'Hello' })\r",
      "\r",
      "// bind boolean\r",
      "const flag = useStorage('my-flag', true) // returns Ref<boolean>\r",
      "\r",
      "// bind number\r",
      "const count = useStorage('my-count', 0) // returns Ref<number>\r",
      "\r",
      "// bind string with SessionStorage\r",
      "const id = useStorage('my-id', 'some-string-id', sessionStorage) // returns Ref<string>\r",
      "\r",
      "// delete data from storage\r",
      "state.value = null\r",
      "```\r",
      "\r",
      "## Merge Defaults\r",
      "\r",
      "By default, `useStorage` will use the value from storage if it presents and ignores the default value. Be aware that when you adding more properties to the default value, the key might be undefined if client's storage does not have that key.\r",
      "\r",
      "```ts\r",
      "localStorage.setItem('my-store', '{\"hello\": \"hello\"}')\r",
      "\r",
      "const state = useStorage('my-store', { hello: 'hi', greeting: 'hello' }, localStorage)\r",
      "\r",
      "console.log(state.value.greeting) // undefined, since the value is not presented in storage\r",
      "```\r",
      "\r",
      "To solve that, you can enable `mergeDefaults` option.\r",
      "\r",
      "```ts\r",
      "localStorage.setItem('my-store', '{\"hello\": \"nihao\"}')\r",
      "\r",
      "const state = useStorage(\r",
      "  'my-store',\r",
      "  { hello: 'hi', greeting: 'hello' },\r",
      "  localStorage,\r",
      "  { mergeDefaults: true } // <--\r",
      ")\r",
      "\r",
      "console.log(state.hello) // 'nihao', from storage\r",
      "console.log(state.greeting) // 'hello', from merged default value\r",
      "```\r",
      "\r",
      "When setting it to true, it will perform a **shallow merge** for objects. You can pass a function to perform custom merge (e.g. deep merge), for example:\r",
      "\r",
      "```ts\r",
      "const state = useStorage(\r",
      "  'my-store',\r",
      "  { hello: 'hi', greeting: 'hello' },\r",
      "  localStorage,\r",
      "  { mergeDefaults: (storageValue, defaults) => deepMerge(defaults, storageValue) } // <--\r",
      ")\r",
      "```\r",
      "\r",
      "## Custom Serialization\r",
      "\r",
      "By default, `useStorage` will smartly use the corresponding serializer based on the data type of provided default value. For example, `JSON.stringify` / `JSON.parse` will be used for objects, `Number.toString` / `parseFloat` for numbers, etc.\r",
      "\r",
      "You can also provide your own serialization function to `useStorage`:\r",
      "\r",
      "```ts\r",
      "import { useStorage } from '@vueuse/core'\r",
      "\r",
      "useStorage(\r",
      "  'key',\r",
      "  {},\r",
      "  undefined,\r",
      "  {\r",
      "    serializer: {\r",
      "      read: (v: any) => v ? JSON.parse(v) : null,\r",
      "      write: (v: any) => JSON.stringify(v),\r",
      "    },\r",
      "  },\r",
      ")\r",
      "```\r",
      "\r",
      "Please note when you provide `null` as the default value, `useStorage` can't assume the data type from it. In this case, you can provide a custom serializer or reuse the built-in ones explicitly.\r",
      "\r",
      "```ts\r",
      "import { StorageSerializers, useStorage } from '@vueuse/core'\r",
      "\r",
      "const objectLike = useStorage('key', null, undefined, { serializer: StorageSerializers.object })\r",
      "objectLike.value = { foo: 'bar' }\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { nextTick, ref, shallowRef } from 'vue-demi'\r",
      "import type { Awaitable, ConfigurableEventFilter, ConfigurableFlush, MaybeRefOrGetter, RemovableRef } from '@vueuse/shared'\r",
      "import { pausableWatch, toValue } from '@vueuse/shared'\r",
      "import type { StorageLike } from '../ssr-handlers'\r",
      "import { getSSRHandler } from '../ssr-handlers'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import { guessSerializerType } from './guess'\r",
      "\r",
      "export interface Serializer<T> {\r",
      "  read(raw: string): T\r",
      "  write(value: T): string\r",
      "}\r",
      "\r",
      "export interface SerializerAsync<T> {\r",
      "  read(raw: string): Awaitable<T>\r",
      "  write(value: T): Awaitable<string>\r",
      "}\r",
      "\r",
      "export const StorageSerializers: Record<'boolean' | 'object' | 'number' | 'any' | 'string' | 'map' | 'set' | 'date', Serializer<any>> = {\r",
      "  boolean: {\r",
      "    read: (v: any) => v === 'true',\r",
      "    write: (v: any) => String(v),\r",
      "  },\r",
      "  object: {\r",
      "    read: (v: any) => JSON.parse(v),\r",
      "    write: (v: any) => JSON.stringify(v),\r",
      "  },\r",
      "  number: {\r",
      "    read: (v: any) => Number.parseFloat(v),\r",
      "    write: (v: any) => String(v),\r",
      "  },\r",
      "  any: {\r",
      "    read: (v: any) => v,\r",
      "    write: (v: any) => String(v),\r",
      "  },\r",
      "  string: {\r",
      "    read: (v: any) => v,\r",
      "    write: (v: any) => String(v),\r",
      "  },\r",
      "  map: {\r",
      "    read: (v: any) => new Map(JSON.parse(v)),\r",
      "    write: (v: any) => JSON.stringify(Array.from((v as Map<any, any>).entries())),\r",
      "  },\r",
      "  set: {\r",
      "    read: (v: any) => new Set(JSON.parse(v)),\r",
      "    write: (v: any) => JSON.stringify(Array.from(v as Set<any>)),\r",
      "  },\r",
      "  date: {\r",
      "    read: (v: any) => new Date(v),\r",
      "    write: (v: any) => v.toISOString(),\r",
      "  },\r",
      "}\r",
      "\r",
      "export const customStorageEventName = 'vueuse-storage'\r",
      "\r",
      "export interface StorageEventLike {\r",
      "  storageArea: StorageLike | null\r",
      "  key: StorageEvent['key']\r",
      "  oldValue: StorageEvent['oldValue']\r",
      "  newValue: StorageEvent['newValue']\r",
      "}\r",
      "\r",
      "export interface UseStorageOptions<T> extends ConfigurableEventFilter, ConfigurableWindow, ConfigurableFlush {\r",
      "  /**\r",
      "   * Watch for deep changes\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  deep?: boolean\r",
      "\r",
      "  /**\r",
      "   * Listen to storage changes, useful for multiple tabs application\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  listenToStorageChanges?: boolean\r",
      "\r",
      "  /**\r",
      "   * Write the default value to the storage when it does not exist\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  writeDefaults?: boolean\r",
      "\r",
      "  /**\r",
      "   * Merge the default value with the value read from the storage.\r",
      "   *\r",
      "   * When setting it to true, it will perform a **shallow merge** for objects.\r",
      "   * You can pass a function to perform custom merge (e.g. deep merge), for example:\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  mergeDefaults?: boolean | ((storageValue: T, defaults: T) => T)\r",
      "\r",
      "  /**\r",
      "   * Custom data serialization\r",
      "   */\r",
      "  serializer?: Serializer<T>\r",
      "\r",
      "  /**\r",
      "   * On error callback\r",
      "   *\r",
      "   * Default log error to `console.error`\r",
      "   */\r",
      "  onError?: (error: unknown) => void\r",
      "\r",
      "  /**\r",
      "   * Use shallow ref as reference\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  shallow?: boolean\r",
      "}\r",
      "\r",
      "export function useStorage(key: string, defaults: MaybeRefOrGetter<string>, storage?: StorageLike, options?: UseStorageOptions<string>): RemovableRef<string>\r",
      "export function useStorage(key: string, defaults: MaybeRefOrGetter<boolean>, storage?: StorageLike, options?: UseStorageOptions<boolean>): RemovableRef<boolean>\r",
      "export function useStorage(key: string, defaults: MaybeRefOrGetter<number>, storage?: StorageLike, options?: UseStorageOptions<number>): RemovableRef<number>\r",
      "export function useStorage<T>(key: string, defaults: MaybeRefOrGetter<T>, storage?: StorageLike, options?: UseStorageOptions<T>): RemovableRef<T>\r",
      "export function useStorage<T = unknown>(key: string, defaults: MaybeRefOrGetter<null>, storage?: StorageLike, options?: UseStorageOptions<T>): RemovableRef<T>\r",
      "\r",
      "/**\r",
      " * Reactive LocalStorage/SessionStorage.\r",
      " *\r",
      " * @see https://vueuse.org/useStorage\r",
      " */\r",
      "export function useStorage<T extends(string | number | boolean | object | null)>(\r",
      "  key: string,\r",
      "  defaults: MaybeRefOrGetter<T>,\r",
      "  storage: StorageLike | undefined,\r",
      "  options: UseStorageOptions<T> = {},\r",
      "): RemovableRef<T> {\r",
      "  const {\r",
      "    flush = 'pre',\r",
      "    deep = true,\r",
      "    listenToStorageChanges = true,\r",
      "    writeDefaults = true,\r",
      "    mergeDefaults = false,\r",
      "    shallow,\r",
      "    window = defaultWindow,\r",
      "    eventFilter,\r",
      "    onError = (e) => {\r",
      "      console.error(e)\r",
      "    },\r",
      "  } = options\r",
      "\r",
      "  const data = (shallow ? shallowRef : ref)(defaults) as RemovableRef<T>\r",
      "\r",
      "  if (!storage) {\r",
      "    try {\r",
      "      storage = getSSRHandler('getDefaultStorage', () => defaultWindow?.localStorage)()\r",
      "    }\r",
      "    catch (e) {\r",
      "      onError(e)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  if (!storage)\r",
      "    return data\r",
      "\r",
      "  const rawInit: T = toValue(defaults)\r",
      "  const type = guessSerializerType<T>(rawInit)\r",
      "  const serializer = options.serializer ?? StorageSerializers[type]\r",
      "\r",
      "  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\r",
      "    data,\r",
      "    () => write(data.value),\r",
      "    { flush, deep, eventFilter },\r",
      "  )\r",
      "\r",
      "  if (window && listenToStorageChanges) {\r",
      "    useEventListener(window, 'storage', update)\r",
      "    useEventListener(window, customStorageEventName, updateFromCustomEvent)\r",
      "  }\r",
      "\r",
      "  update()\r",
      "\r",
      "  return data\r",
      "\r",
      "  function write(v: unknown) {\r",
      "    try {\r",
      "      if (v == null) {\r",
      "        storage!.removeItem(key)\r",
      "      }\r",
      "      else {\r",
      "        const serialized = serializer.write(v)\r",
      "        const oldValue = storage!.getItem(key)\r",
      "        if (oldValue !== serialized) {\r",
      "          storage!.setItem(key, serialized)\r",
      "\r",
      "          // send custom event to communicate within same page\r",
      "          // importantly this should _not_ be a StorageEvent since those cannot\r",
      "          // be constructed with a non-built-in storage area\r",
      "          if (window) {\r",
      "            window.dispatchEvent(new CustomEvent<StorageEventLike>(customStorageEventName, {\r",
      "              detail: {\r",
      "                key,\r",
      "                oldValue,\r",
      "                newValue: serialized,\r",
      "                storageArea: storage!,\r",
      "              },\r",
      "            }))\r",
      "          }\r",
      "        }\r",
      "      }\r",
      "    }\r",
      "    catch (e) {\r",
      "      onError(e)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function read(event?: StorageEventLike) {\r",
      "    const rawValue = event\r",
      "      ? event.newValue\r",
      "      : storage!.getItem(key)\r",
      "\r",
      "    if (rawValue == null) {\r",
      "      if (writeDefaults && rawInit !== null)\r",
      "        storage!.setItem(key, serializer.write(rawInit))\r",
      "      return rawInit\r",
      "    }\r",
      "    else if (!event && mergeDefaults) {\r",
      "      const value = serializer.read(rawValue)\r",
      "      if (typeof mergeDefaults === 'function')\r",
      "        return mergeDefaults(value, rawInit)\r",
      "      else if (type === 'object' && !Array.isArray(value))\r",
      "        return { ...rawInit as any, ...value }\r",
      "      return value\r",
      "    }\r",
      "    else if (typeof rawValue !== 'string') {\r",
      "      return rawValue\r",
      "    }\r",
      "    else {\r",
      "      return serializer.read(rawValue)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function updateFromCustomEvent(event: CustomEvent<StorageEventLike>) {\r",
      "    update(event.detail)\r",
      "  }\r",
      "\r",
      "  function update(event?: StorageEventLike) {\r",
      "    if (event && event.storageArea !== storage)\r",
      "      return\r",
      "\r",
      "    if (event && event.key == null) {\r",
      "      data.value = rawInit\r",
      "      return\r",
      "    }\r",
      "\r",
      "    if (event && event.key !== key)\r",
      "      return\r",
      "\r",
      "    pauseWatch()\r",
      "    try {\r",
      "      data.value = read(event)\r",
      "    }\r",
      "    catch (e) {\r",
      "      onError(e)\r",
      "    }\r",
      "    finally {\r",
      "      // use nextTick to avoid infinite loop\r",
      "      if (event)\r",
      "        nextTick(resumeWatch)\r",
      "      else\r",
      "        resumeWatch()\r",
      "    }\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useStorage } from '@vueuse/core'\r",
      "\r",
      "const theDefault = {\r",
      "  name: 'Banana',\r",
      "  color: 'Yellow',\r",
      "  size: 'Medium',\r",
      "  count: 0,\r",
      "}\r",
      "const state = useStorage('vue-use-local-storage', theDefault)\r",
      "const state2 = useStorage('vue-use-local-storage', theDefault)\r",
      "\r",
      "const text = stringify(state2)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <input v-model=\"state.name\" type=\"text\">\r",
      "    <input v-model=\"state.color\" type=\"text\">\r",
      "    <input v-model=\"state.size\" type=\"text\">\r",
      "    <input v-model.number=\"state.count\" type=\"range\" min=\"0\" step=\"0.01\" max=\"1000\">\r",
      "\r",
      "    <pre lang=\"json\">{{ text }}</pre>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useStyleTag - vueuse": {
    "prefix": "hvue useStyleTag - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useStyleTag\r",
      "\r",
      "Inject reactive `style` element in head.\r",
      "\r",
      "## Usage\r",
      "\r",
      "### Basic usage\r",
      "\r",
      "Provide a CSS string, then `useStyleTag` will automatically generate an id and inject it in `<head>`.\r",
      "```js\r",
      "import { useStyleTag } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  id,\r",
      "  css,\r",
      "  load,\r",
      "  unload,\r",
      "  isLoaded,\r",
      "} = useStyleTag('.foo { margin-top: 32px; }')\r",
      "\r",
      "// Later you can modify styles\r",
      "css.value = '.foo { margin-top: 64px; }'\r",
      "```\r",
      "\r",
      "This code will be injected to `<head>`:\r",
      "\r",
      "```html\r",
      "<style id=\"vueuse_styletag_1\">\r",
      ".foo { margin-top: 64px; }\r",
      "</style>\r",
      "```\r",
      "\r",
      "### Custom ID\r",
      "\r",
      "If you need to define your own id, you can pass `id` as first argument.\r",
      "\r",
      "```js\r",
      "import { useStyleTag } from '@vueuse/core'\r",
      "\r",
      "useStyleTag('.foo { margin-top: 32px; }', { id: 'custom-id' })\r",
      "```\r",
      "\r",
      "```html\r",
      "<!-- injected to <head> -->\r",
      "<style id=\"custom-id\">\r",
      ".foo { margin-top: 32px; }\r",
      "</style>\r",
      "```\r",
      "\r",
      "### Media query\r",
      "\r",
      "You can pass media attributes as last argument within object.\r",
      "\r",
      "```js\r",
      "useStyleTag('.foo { margin-top: 32px; }', { media: 'print' })\r",
      "```\r",
      "\r",
      "```html\r",
      "<!-- injected to <head> -->\r",
      "<style id=\"vueuse_styletag_1\" media=\"print\">\r",
      ".foo { margin-top: 32px; }\r",
      "</style>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { readonly, ref, watch } from 'vue-demi'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { tryOnMounted, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { MaybeRef } from '@vueuse/shared'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "\r",
      "export interface UseStyleTagOptions extends ConfigurableDocument {\r",
      "  /**\r",
      "   * Media query for styles to apply\r",
      "   */\r",
      "  media?: string\r",
      "\r",
      "  /**\r",
      "   * Load the style immediately\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "\r",
      "  /**\r",
      "   * Manual controls the timing of loading and unloading\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  manual?: boolean\r",
      "\r",
      "  /**\r",
      "   * DOM id of the style tag\r",
      "   *\r",
      "   * @default auto-incremented\r",
      "   */\r",
      "  id?: string\r",
      "}\r",
      "\r",
      "export interface UseStyleTagReturn {\r",
      "  id: string\r",
      "  css: Ref<string>\r",
      "  load: () => void\r",
      "  unload: () => void\r",
      "  isLoaded: Readonly<Ref<boolean>>\r",
      "}\r",
      "\r",
      "let _id = 0\r",
      "\r",
      "/**\r",
      " * Inject <style> element in head.\r",
      " *\r",
      " * Overload: Omitted id\r",
      " *\r",
      " * @see https://vueuse.org/useStyleTag\r",
      " * @param css\r",
      " * @param options\r",
      " */\r",
      "export function useStyleTag(\r",
      "  css: MaybeRef<string>,\r",
      "  options: UseStyleTagOptions = {},\r",
      "): UseStyleTagReturn {\r",
      "  const isLoaded = ref(false)\r",
      "\r",
      "  const {\r",
      "    document = defaultDocument, immediate = true,\r",
      "    manual = false,\r",
      "    id = `vueuse_styletag_${++_id}`,\r",
      "  } = options\r",
      "\r",
      "  const cssRef = ref(css)\r",
      "\r",
      "  let stop = () => { }\r",
      "  const load = () => {\r",
      "    if (!document)\r",
      "      return\r",
      "\r",
      "    const el = (document.getElementById(id) || document.createElement('style')) as HTMLStyleElement\r",
      "\r",
      "    if (!el.isConnected) {\r",
      "      el.id = id\r",
      "      if (options.media)\r",
      "        el.media = options.media\r",
      "      document.head.appendChild(el)\r",
      "    }\r",
      "\r",
      "    if (isLoaded.value)\r",
      "      return\r",
      "\r",
      "    stop = watch(\r",
      "      cssRef,\r",
      "      (value) => {\r",
      "        el.textContent = value\r",
      "      },\r",
      "      { immediate: true },\r",
      "    )\r",
      "\r",
      "    isLoaded.value = true\r",
      "  }\r",
      "\r",
      "  const unload = () => {\r",
      "    if (!document || !isLoaded.value)\r",
      "      return\r",
      "    stop()\r",
      "    document.head.removeChild(document.getElementById(id) as HTMLStyleElement)\r",
      "    isLoaded.value = false\r",
      "  }\r",
      "\r",
      "  if (immediate && !manual)\r",
      "    tryOnMounted(load)\r",
      "\r",
      "  if (!manual)\r",
      "    tryOnScopeDispose(unload)\r",
      "\r",
      "  return {\r",
      "    id,\r",
      "    css: cssRef,\r",
      "    unload,\r",
      "    load,\r",
      "    isLoaded: readonly(isLoaded),\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useStyleTag } from '@vueuse/core'\r",
      "\r",
      "const customCSS = `\r",
      ".demo { background: #ad4c2e50; }\r",
      ".demo textarea { background: lightyellow; }\r",
      "`.trim()\r",
      "\r",
      "const { id, css, load, unload, isLoaded } = useStyleTag(customCSS)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    Edit CSS:\r",
      "    <textarea v-model=\"css\" type=\"text\" rows=\"2\" class=\"w-full\" />\r",
      "  </div>\r",
      "  <button :disabled=\"isLoaded\" @click=\"load\">\r",
      "    Load\r",
      "  </button>\r",
      "  <button class=\"orange\" :disabled=\"!isLoaded\" @click=\"unload\">\r",
      "    Unload\r",
      "  </button>\r",
      "  <div class=\"usestyle-demo\">\r",
      "    <p>ID: <code>{{ id }}</code></p>\r",
      "    <p>Loaded: <code>{{ isLoaded }}</code></p>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useSwipe - vueuse": {
    "prefix": "hvue useSwipe - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useSwipe\r",
      "\r",
      "Reactive swipe detection based on [`TouchEvents`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent).\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html {16-20}\r",
      "<template>\r",
      "  <div ref=\"el\">\r",
      "    Swipe here\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<script>\r",
      "  setup() {\r",
      "    const el = ref(null)\r",
      "    const { isSwiping, direction } = useSwipe(el)\r",
      "\r",
      "    return { el, isSwiping, direction }\r",
      "  } \r",
      "</script>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { noop } from '@vueuse/shared'\r",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { computed, reactive, ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import type { Position } from '../types'\r",
      "\r",
      "export type UseSwipeDirection = 'up' | 'down' | 'left' | 'right' | 'none'\r",
      "\r",
      "export interface UseSwipeOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Register events as passive\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  passive?: boolean\r",
      "\r",
      "  /**\r",
      "   * @default 50\r",
      "   */\r",
      "  threshold?: number\r",
      "\r",
      "  /**\r",
      "   * Callback on swipe start\r",
      "   */\r",
      "  onSwipeStart?: (e: TouchEvent) => void\r",
      "\r",
      "  /**\r",
      "   * Callback on swipe moves\r",
      "   */\r",
      "  onSwipe?: (e: TouchEvent) => void\r",
      "\r",
      "  /**\r",
      "   * Callback on swipe ends\r",
      "   */\r",
      "  onSwipeEnd?: (e: TouchEvent, direction: UseSwipeDirection) => void\r",
      "}\r",
      "\r",
      "export interface UseSwipeReturn {\r",
      "  isPassiveEventSupported: boolean\r",
      "  isSwiping: Ref<boolean>\r",
      "  direction: ComputedRef<UseSwipeDirection>\r",
      "  coordsStart: Readonly<Position>\r",
      "  coordsEnd: Readonly<Position>\r",
      "  lengthX: ComputedRef<number>\r",
      "  lengthY: ComputedRef<number>\r",
      "  stop: () => void\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive swipe detection.\r",
      " *\r",
      " * @see https://vueuse.org/useSwipe\r",
      " * @param target\r",
      " * @param options\r",
      " */\r",
      "export function useSwipe(\r",
      "  target: MaybeRefOrGetter<EventTarget | null | undefined>,\r",
      "  options: UseSwipeOptions = {},\r",
      "): UseSwipeReturn {\r",
      "  const {\r",
      "    threshold = 50,\r",
      "    onSwipe,\r",
      "    onSwipeEnd,\r",
      "    onSwipeStart,\r",
      "    passive = true,\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const coordsStart = reactive<Position>({ x: 0, y: 0 })\r",
      "  const coordsEnd = reactive<Position>({ x: 0, y: 0 })\r",
      "\r",
      "  const diffX = computed(() => coordsStart.x - coordsEnd.x)\r",
      "  const diffY = computed(() => coordsStart.y - coordsEnd.y)\r",
      "\r",
      "  const { max, abs } = Math\r",
      "  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold)\r",
      "\r",
      "  const isSwiping = ref(false)\r",
      "\r",
      "  const direction = computed((): UseSwipeDirection => {\r",
      "    if (!isThresholdExceeded.value)\r",
      "      return 'none'\r",
      "\r",
      "    if (abs(diffX.value) > abs(diffY.value)) {\r",
      "      return diffX.value > 0\r",
      "        ? 'left'\r",
      "        : 'right'\r",
      "    }\r",
      "    else {\r",
      "      return diffY.value > 0\r",
      "        ? 'up'\r",
      "        : 'down'\r",
      "    }\r",
      "  })\r",
      "\r",
      "  const getTouchEventCoords = (e: TouchEvent) => [e.touches[0].clientX, e.touches[0].clientY]\r",
      "\r",
      "  const updateCoordsStart = (x: number, y: number) => {\r",
      "    coordsStart.x = x\r",
      "    coordsStart.y = y\r",
      "  }\r",
      "\r",
      "  const updateCoordsEnd = (x: number, y: number) => {\r",
      "    coordsEnd.x = x\r",
      "    coordsEnd.y = y\r",
      "  }\r",
      "\r",
      "  let listenerOptions: { passive?: boolean; capture?: boolean }\r",
      "\r",
      "  const isPassiveEventSupported = checkPassiveEventSupport(window?.document)\r",
      "\r",
      "  if (!passive)\r",
      "    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true }\r",
      "  else\r",
      "    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false }\r",
      "\r",
      "  const onTouchEnd = (e: TouchEvent) => {\r",
      "    if (isSwiping.value)\r",
      "      onSwipeEnd?.(e, direction.value)\r",
      "\r",
      "    isSwiping.value = false\r",
      "  }\r",
      "\r",
      "  const stops = [\r",
      "    useEventListener(target, 'touchstart', (e: TouchEvent) => {\r",
      "      if (e.touches.length !== 1)\r",
      "        return\r",
      "      if (listenerOptions.capture && !listenerOptions.passive)\r",
      "        e.preventDefault()\r",
      "      const [x, y] = getTouchEventCoords(e)\r",
      "      updateCoordsStart(x, y)\r",
      "      updateCoordsEnd(x, y)\r",
      "      onSwipeStart?.(e)\r",
      "    }, listenerOptions),\r",
      "\r",
      "    useEventListener(target, 'touchmove', (e: TouchEvent) => {\r",
      "      if (e.touches.length !== 1)\r",
      "        return\r",
      "      const [x, y] = getTouchEventCoords(e)\r",
      "      updateCoordsEnd(x, y)\r",
      "      if (!isSwiping.value && isThresholdExceeded.value)\r",
      "        isSwiping.value = true\r",
      "      if (isSwiping.value)\r",
      "        onSwipe?.(e)\r",
      "    }, listenerOptions),\r",
      "\r",
      "    useEventListener(target, ['touchend', 'touchcancel'], onTouchEnd, listenerOptions),\r",
      "  ]\r",
      "\r",
      "  const stop = () => stops.forEach(s => s())\r",
      "\r",
      "  return {\r",
      "    isPassiveEventSupported,\r",
      "    isSwiping,\r",
      "    direction,\r",
      "    coordsStart,\r",
      "    coordsEnd,\r",
      "    lengthX: diffX,\r",
      "    lengthY: diffY,\r",
      "    stop,\r",
      "  }\r",
      "}\r",
      "\r",
      "/**\r",
      " * This is a polyfill for passive event support detection\r",
      " * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r",
      " */\r",
      "function checkPassiveEventSupport(document?: Document) {\r",
      "  if (!document)\r",
      "    return false\r",
      "  let supportsPassive = false\r",
      "  const optionsBlock: AddEventListenerOptions = {\r",
      "    get passive() {\r",
      "      supportsPassive = true\r",
      "      return false\r",
      "    },\r",
      "  }\r",
      "  document.addEventListener('x', noop, optionsBlock)\r",
      "  document.removeEventListener('x', noop)\r",
      "  return supportsPassive\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, ref } from 'vue'\r",
      "import type { UseSwipeDirection } from '@vueuse/core'\r",
      "import { useSwipe } from '@vueuse/core'\r",
      "\r",
      "const target = ref<HTMLElement | null>(null)\r",
      "const container = ref<HTMLElement | null>(null)\r",
      "const containerWidth = computed(() => container.value?.offsetWidth)\r",
      "const left = ref('0')\r",
      "const opacity = ref(1)\r",
      "\r",
      "function reset() {\r",
      "  left.value = '0'\r",
      "  opacity.value = 1\r",
      "}\r",
      "\r",
      "const { direction, isSwiping, lengthX, lengthY } = useSwipe(\r",
      "  target, {\r",
      "    passive: false,\r",
      "    onSwipe(e: TouchEvent) {\r",
      "      if (containerWidth.value) {\r",
      "        if (lengthX.value < 0) {\r",
      "          const length = Math.abs(lengthX.value)\r",
      "          left.value = `${length}px`\r",
      "          opacity.value = 1.1 - length / containerWidth.value\r",
      "        }\r",
      "        else {\r",
      "          left.value = '0'\r",
      "          opacity.value = 1\r",
      "        }\r",
      "      }\r",
      "    },\r",
      "    onSwipeEnd(e: TouchEvent, direction: UseSwipeDirection) {\r",
      "      if (lengthX.value < 0 && containerWidth.value && (Math.abs(lengthX.value) / containerWidth.value) >= 0.5) {\r",
      "        left.value = '100%'\r",
      "        opacity.value = 0\r",
      "      }\r",
      "      else {\r",
      "        left.value = '0'\r",
      "        opacity.value = 1\r",
      "      }\r",
      "    },\r",
      "  })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div ref=\"container\" class=\"container select-none\">\r",
      "      <button @click=\"reset\">\r",
      "        Reset\r",
      "      </button>\r",
      "      <div ref=\"target\" class=\"overlay\" :class=\"{ animated: !isSwiping }\" :style=\"{ left, opacity }\">\r",
      "        <p>Swipe right</p>\r",
      "      </div>\r",
      "    </div>\r",
      "    <p class=\"status\">\r",
      "      Direction: {{ direction ? direction : '-' }} <br>\r",
      "      lengthX: {{ lengthX }} | lengthY: {{ lengthY }}\r",
      "    </p>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      ".container {\r",
      "  position: relative;\r",
      "  display: flex;\r",
      "  align-items: center;\r",
      "  justify-content: center;\r",
      "  border: 2px dashed #ccc;\r",
      "  overflow: hidden;\r",
      "}\r",
      "\r",
      ".overlay {\r",
      "  top: 0;\r",
      "  left: 0;\r",
      "  width: 100%;\r",
      "  height: 100%;\r",
      "  position: absolute;\r",
      "  background: #3fb983;\r",
      "}\r",
      "\r",
      ".overlay.animated {\r",
      "  transition: all 0.2s ease-in-out;\r",
      "}\r",
      "\r",
      ".overlay > p {\r",
      "  color: #fff;\r",
      "  font-weight: bold;\r",
      "  text-align: center;\r",
      "  overflow:hidden;\r",
      "  white-space: nowrap;\r",
      "}\r",
      "\r",
      ".status {\r",
      "  text-align: center;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTemplateRefsList - vueuse": {
    "prefix": "hvue useTemplateRefsList - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Component\r",
      "---\r",
      "\r",
      "# useTemplateRefsList\r",
      "\r",
      "Shorthand for binding refs to template elements and components inside `v-for`.\r",
      "\r",
      "::: warning\r",
      "This function only works for Vue 3\r",
      ":::\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <div v-for=\"i of 5\" :key=\"i\" :ref=\"refs.set\"></div>\r",
      "</template>\r",
      "\r",
      "<script setup lang=\"ts\">\r",
      "import { onUpdated } from 'vue'\r",
      "import { useTemplateRefsList } from '@vueuse/core'\r",
      "\r",
      "const refs = useTemplateRefsList<HTMLDivElement>()\r",
      "\r",
      "onUpdated(() => {\r",
      "  console.log(refs)\r",
      "})\r",
      "</script>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { onBeforeUpdate, ref } from 'vue-demi'\r",
      "\r",
      "export type TemplateRefsList<T> = T[] & {\r",
      "  set(el: Object | null): void\r",
      "}\r",
      "\r",
      "export function useTemplateRefsList<T = Element>(): Readonly<Ref<Readonly<TemplateRefsList<T>>>> {\r",
      "  const refs = ref<unknown>([]) as Ref<TemplateRefsList<T>>\r",
      "  refs.value.set = (el: Object | null) => {\r",
      "    if (el)\r",
      "      refs.value.push(el as T)\r",
      "  }\r",
      "  onBeforeUpdate(() => {\r",
      "    refs.value.length = 0\r",
      "  })\r",
      "  return refs\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { nextTick, ref, watch } from 'vue'\r",
      "import { useTemplateRefsList } from '@vueuse/core'\r",
      "\r",
      "const count = ref(5)\r",
      "const refs = useTemplateRefsList<HTMLDivElement>()\r",
      "\r",
      "watch(refs, async () => {\r",
      "  await nextTick()\r",
      "  console.log([...refs.value])\r",
      "}, {\r",
      "  deep: true,\r",
      "  flush: 'post',\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <span v-for=\"i of count\" :key=\"i\" :ref=\"refs.set\" class=\"mr-2\">\r",
      "    {{ i }}\r",
      "  </span>\r",
      "  <br>\r",
      "  <button @click=\"count += 1\">\r",
      "    Inc\r",
      "  </button>\r",
      "  <button :disabled=\"count <= 0\" @click=\"count -= 1\">\r",
      "    Dec\r",
      "  </button>\r",
      "  <note>Open the console to see the output</note>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTextareaAutosize - vueuse": {
    "prefix": "hvue useTextareaAutosize - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useTextareaAutosize\r",
      "\r",
      "Automatically update the height of a textarea depending on the content.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```vue\r",
      "<script setup lang=\"ts\">\r",
      "const { textarea, input } = useTextareaAutosize()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <textarea\r",
      "    ref=\"textarea\"\r",
      "    v-model=\"input\"\r",
      "    class=\"resize-none\"\r",
      "    placeholder=\"What's on your mind?\"\r",
      "  />\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRef } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import type { WatchSource } from 'vue-demi'\r",
      "import { nextTick, ref, watch } from 'vue-demi'\r",
      "import { useResizeObserver } from '../useResizeObserver'\r",
      "\r",
      "export interface UseTextareaAutosizeOptions {\r",
      "  /** Textarea element to autosize. */\r",
      "  element?: MaybeRef<HTMLTextAreaElement | undefined>\r",
      "  /** Textarea content. */\r",
      "  input?: MaybeRef<string | undefined>\r",
      "  /** Watch sources that should trigger a textarea resize. */\r",
      "  watch?: WatchSource | Array<WatchSource>\r",
      "  /** Function called when the textarea size changes. */\r",
      "  onResize?: () => void\r",
      "  /** Specify style target to apply the height based on textarea content. If not provided it will use textarea it self.  */\r",
      "  styleTarget?: MaybeRef<HTMLElement>\r",
      "}\r",
      "\r",
      "export function useTextareaAutosize(options?: UseTextareaAutosizeOptions) {\r",
      "  const textarea = ref<HTMLTextAreaElement>(options?.element as any)\r",
      "  const input = ref<string>(options?.input as any)\r",
      "  const textareaScrollHeight = ref(1)\r",
      "\r",
      "  function triggerResize() {\r",
      "    if (!textarea.value)\r",
      "      return\r",
      "\r",
      "    let height = ''\r",
      "\r",
      "    textarea.value!.style.height = '1px'\r",
      "    textareaScrollHeight.value = textarea.value?.scrollHeight\r",
      "\r",
      "    // If style target is provided update its height\r",
      "    if (options?.styleTarget)\r",
      "      toValue(options.styleTarget).style.height = `${textareaScrollHeight.value}px`\r",
      "    // else update textarea's height by updating height variable\r",
      "    else\r",
      "      height = `${textareaScrollHeight.value}px`\r",
      "\r",
      "    textarea.value!.style.height = height\r",
      "\r",
      "    options?.onResize?.()\r",
      "  }\r",
      "\r",
      "  watch([input, textarea], () => nextTick(triggerResize), { immediate: true })\r",
      "\r",
      "  useResizeObserver(textarea, () => triggerResize())\r",
      "\r",
      "  if (options?.watch)\r",
      "    watch(options.watch, triggerResize, { immediate: true, deep: true })\r",
      "\r",
      "  return {\r",
      "    textarea,\r",
      "    input,\r",
      "    triggerResize,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseTextareaAutosizeReturn = ReturnType<typeof useTextareaAutosize>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useTextareaAutosize } from '@vueuse/core'\r",
      "\r",
      "const { textarea, input } = useTextareaAutosize()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <span>Type, the textarea will grow:</span>\r",
      "    <textarea\r",
      "      ref=\"textarea\"\r",
      "      v-model=\"input\"\r",
      "      class=\"resize-none\"\r",
      "      placeholder=\"What's on your mind?\"\r",
      "    />\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTextDirection - vueuse": {
    "prefix": "hvue useTextDirection - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useTextDirection\r",
      "\r",
      "Reactive [dir](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir) of the element's text.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useTextDirection } from '@vueuse/core'\r",
      "\r",
      "const dir = useTextDirection() // Ref<'ltr' | 'rtl' | 'auto'>\r",
      "```\r",
      "\r",
      "By default, it returns `rlt` direction when dir `rtl` is applied to the `html` tag, for example:\r",
      "\r",
      "```html\r",
      "<!--ltr-->\r",
      "<html> ... </html>\r",
      "\r",
      "<!--rtl-->\r",
      "<html dir=\"rtl\"> ... </html>\r",
      "```\r",
      "\r",
      "## Options\r",
      "\r",
      "```ts\r",
      "import { useTextDirection } from '@vueuse/core'\r",
      "\r",
      "const mode = useTextDirection({\r",
      "  selector: 'body'\r",
      "}) // Ref<'ltr' | 'rtl' | 'auto'>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { tryOnMounted } from '@vueuse/shared'\r",
      "import { computed, ref } from 'vue-demi'\r",
      "\r",
      "import type { MaybeElement } from '../unrefElement'\r",
      "import { useMutationObserver } from '../useMutationObserver'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "\r",
      "export type UseTextDirectionValue = 'ltr' | 'rtl' | 'auto'\r",
      "\r",
      "export interface UseTextDirectionOptions extends ConfigurableDocument {\r",
      "  /**\r",
      "   * CSS Selector for the target element applying to\r",
      "   *\r",
      "   * @default 'html'\r",
      "   */\r",
      "  selector?: string\r",
      "  /**\r",
      "   * Observe `document.querySelector(selector)` changes using MutationObserve\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  observe?: boolean\r",
      "  /**\r",
      "   * Initial value\r",
      "   *\r",
      "   * @default 'ltr'\r",
      "   */\r",
      "  initialValue?: UseTextDirectionValue\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive dir of the element's text.\r",
      " *\r",
      " * @see https://vueuse.org/useTextDirection\r",
      " */\r",
      "export function useTextDirection(options: UseTextDirectionOptions = {}) {\r",
      "  const {\r",
      "    document = defaultDocument,\r",
      "    selector = 'html',\r",
      "    observe = false,\r",
      "    initialValue = 'ltr',\r",
      "  } = options\r",
      "\r",
      "  function getValue() {\r",
      "    return document?.querySelector(selector)?.getAttribute('dir') as UseTextDirectionValue ?? initialValue\r",
      "  }\r",
      "\r",
      "  const dir = ref<UseTextDirectionValue>(getValue())\r",
      "\r",
      "  tryOnMounted(() => dir.value = getValue())\r",
      "\r",
      "  if (observe && document) {\r",
      "    useMutationObserver(\r",
      "      document.querySelector(selector) as MaybeElement,\r",
      "      () => dir.value = getValue(),\r",
      "      { attributes: true },\r",
      "    )\r",
      "  }\r",
      "\r",
      "  return computed<UseTextDirectionValue>({\r",
      "    get() {\r",
      "      return dir.value\r",
      "    },\r",
      "    set(v) {\r",
      "      dir.value = v\r",
      "      if (!document)\r",
      "        return\r",
      "      if (dir.value)\r",
      "        document.querySelector(selector)?.setAttribute('dir', dir.value)\r",
      "      else\r",
      "        document.querySelector(selector)?.removeAttribute('dir')\r",
      "    },\r",
      "  })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed } from 'vue'\r",
      "\r",
      "import { useTextDirection } from '.'\r",
      "\r",
      "const dir = useTextDirection({\r",
      "  selector: '#_useTextDirectionDemo',\r",
      "})\r",
      "const text = computed(() =>\r",
      "  dir.value === 'ltr'\r",
      "    ? 'This paragraph is in English and correctly goes left to right.'\r",
      "    : 'This paragraph is in English but incorrectly goes right to left.',\r",
      ")\r",
      "\r",
      "function handleOnClick() {\r",
      "  dir.value = dir.value === 'rtl' ? 'ltr' : 'rtl'\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div id=\"_useTextDirectionDemo\">\r",
      "    <p>\r",
      "      {{ text }}\r",
      "    </p>\r",
      "    <hr>\r",
      "    <button @click=\"handleOnClick\">\r",
      "      <span class=\"ml-2\">{{ dir.toUpperCase() }}</span>\r",
      "    </button>\r",
      "    <span class=\"p-4 opacity-50\">Click to change the direction</span>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      "#_useTextDirectionDemo[dir='rtl']\r",
      "p {\r",
      "  color: red;\r",
      "}\r",
      "button {\r",
      "  margin-right: 0.5em;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTextSelection - vueuse": {
    "prefix": "hvue useTextSelection - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "---\r",
      "\r",
      "# useTextSelection\r",
      "\r",
      "Reactively track user text selection based on [`Window.getSelection`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection).\r",
      "\r",
      "## Usage\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <p>{{state.text}}</p>\r",
      "</template>\r",
      "\r",
      "<script setup lang=\"ts\">\r",
      "  import { useTextSelection } from '@vueuse/core'\r",
      "  const state = useTextSelection()\r",
      "</script>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed, ref } from 'vue-demi'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "\r",
      "function getRangesFromSelection(selection: Selection) {\r",
      "  const rangeCount = selection.rangeCount ?? 0\r",
      "  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i))\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactively track user text selection based on [`Window.getSelection`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getSelection).\r",
      " *\r",
      " * @see https://vueuse.org/useTextSelection\r",
      " */\r",
      "export function useTextSelection(options: ConfigurableWindow = {}) {\r",
      "  const {\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const selection = ref<Selection | null>(null)\r",
      "  const text = computed(() => selection.value?.toString() ?? '')\r",
      "  const ranges = computed<Range[]>(() => selection.value ? getRangesFromSelection(selection.value) : [])\r",
      "  const rects = computed(() => ranges.value.map(range => range.getBoundingClientRect()))\r",
      "\r",
      "  function onSelectionChange() {\r",
      "    selection.value = null // trigger computed update\r",
      "    if (window)\r",
      "      selection.value = window.getSelection()\r",
      "  }\r",
      "\r",
      "  if (window)\r",
      "    useEventListener(window.document, 'selectionchange', onSelectionChange)\r",
      "\r",
      "  return {\r",
      "    text,\r",
      "    rects,\r",
      "    ranges,\r",
      "    selection,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseTextSelectionReturn = ReturnType<typeof useTextSelection>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, ref } from 'vue'\r",
      "import { useTextSelection } from '@vueuse/core'\r",
      "\r",
      "const demo = ref()\r",
      "const { rects, text } = useTextSelection()\r",
      "const selectedStyle = computed(() => text.value ? 'text-primary' : 'text-gray-400')\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"demo\">\r",
      "    <p class=\"font-600 text-blue-600\">\r",
      "      You can select any text on the page.\r",
      "    </p>\r",
      "    <p>\r",
      "      <strong>Selected Text:</strong>\r",
      "      <em\r",
      "        :class=\"selectedStyle\"\r",
      "        class=\"whitespace-pre h-44 overflow-y-auto block\"\r",
      "      >{{ text || 'No selected' }}</em>\r",
      "    </p>\r",
      "    <p>\r",
      "      <strong>Selected rects:</strong>\r",
      "      <pre class=\"h-72\" lang=\"json\">{{ rects }}</pre>\r",
      "    </p>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useThrottledRefHistory - vueuse": {
    "prefix": "hvue useThrottledRefHistory - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: State\r",
      "related: useDebouncedRefHistory, useRefHistory\r",
      "---\r",
      "\r",
      "# useThrottledRefHistory\r",
      "\r",
      "Shorthand for `useRefHistory` with throttled filter.\r",
      "\r",
      "## Usage\r",
      "\r",
      "This function takes the first snapshot right after the counter's value was changed and the second with a delay of 1000ms.\r",
      "\r",
      "```ts\r",
      "import { ref } from 'vue'\r",
      "import { useThrottledRefHistory } from '@vueuse/core'\r",
      "\r",
      "const counter = ref(0)\r",
      "const { history, undo, redo } = useThrottledRefHistory(counter, { deep: true, throttle: 1000 })\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRef } from '@vueuse/shared'\r",
      "import { throttleFilter } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import type { UseRefHistoryOptions, UseRefHistoryReturn } from '../useRefHistory'\r",
      "import { useRefHistory } from '../useRefHistory'\r",
      "\r",
      "export type UseThrottledRefHistoryOptions<Raw, Serialized = Raw> = Omit<UseRefHistoryOptions<Raw, Serialized>, 'eventFilter'> & { throttle?: MaybeRef<number>; trailing?: boolean }\r",
      "\r",
      "export type UseThrottledRefHistoryReturn<Raw, Serialized = Raw> = UseRefHistoryReturn<Raw, Serialized>\r",
      "\r",
      "/**\r",
      " * Shorthand for [useRefHistory](https://vueuse.org/useRefHistory) with throttled filter.\r",
      " *\r",
      " * @see https://vueuse.org/useThrottledRefHistory\r",
      " * @param source\r",
      " * @param options\r",
      " */\r",
      "export function useThrottledRefHistory<Raw, Serialized = Raw>(\r",
      "  source: Ref<Raw>,\r",
      "  options: UseThrottledRefHistoryOptions<Raw, Serialized> = {},\r",
      "): UseThrottledRefHistoryReturn<Raw, Serialized> {\r",
      "  const { throttle = 200, trailing = true } = options\r",
      "  const filter = throttleFilter(throttle, trailing)\r",
      "  const history = useRefHistory(source, { ...options, eventFilter: filter })\r",
      "\r",
      "  return {\r",
      "    ...history,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useCounter } from '@vueuse/shared'\r",
      "import { formatDate, useThrottledRefHistory } from '@vueuse/core'\r",
      "import type { Ref } from 'vue'\r",
      "\r",
      "function format(ts: number) {\r",
      "  return formatDate(new Date(ts), 'YYYY-MM-DD HH:mm:ss')\r",
      "}\r",
      "const delay: Ref<number> = ref(1000)\r",
      "\r",
      "const { count, inc, dec } = useCounter()\r",
      "const { history, undo, redo, canUndo, canRedo } = useThrottledRefHistory(\r",
      "  count, {\r",
      "    deep: true, throttle: delay, capacity: 10, trailing: true,\r",
      "  })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Count: {{ count }}</div>\r",
      "  <button @click=\"inc()\">\r",
      "    Increment\r",
      "  </button>\r",
      "  <button @click=\"dec()\">\r",
      "    Decrement\r",
      "  </button>\r",
      "  <span class=\"ml-2\">/</span>\r",
      "  <button :disabled=\"!canUndo\" @click=\"undo()\">\r",
      "    Undo\r",
      "  </button>\r",
      "  <button :disabled=\"!canRedo\" @click=\"redo()\">\r",
      "    Redo\r",
      "  </button>\r",
      "  <br>\r",
      "  <span>Delay (in ms):</span>\r",
      "  <input v-model=\"delay\" type=\"number\">\r",
      "  <br>\r",
      "  <br>\r",
      "  <note>History (limited to 10 records for demo)</note>\r",
      "  <div class=\"code-block mt-4\">\r",
      "    <div v-for=\"i in history\" :key=\"i.timestamp\">\r",
      "      <span class=\"opacity-50 mr-2 font-mono\">{{ format(i.timestamp) }}</span>\r",
      "      <span class=\"font-mono\">{ value: {{ i.snapshot }} }</span>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTimeAgo - vueuse": {
    "prefix": "hvue useTimeAgo - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Time\r",
      "---\r",
      "\r",
      "# useTimeAgo\r",
      "\r",
      "Reactive time ago. Automatically update the time ago string when the time changes.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useTimeAgo } from '@vueuse/core'\r",
      "\r",
      "const timeAgo = useTimeAgo(new Date(2021, 0, 1))\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseTimeAgo v-slot=\"{ timeAgo }\" :time=\"new Date(2021, 0, 1)\">\r",
      "  Time Ago: {{ timeAgo }}\r",
      "</UseTimeAgo>\r",
      "```\r",
      "\r",
      "## Non-Reactivity Usage\r",
      "\r",
      "In case you don't need the reactivity, you can use the `formatTimeAgo` function to get the formatted string instead of a Ref.\r",
      "\r",
      "```js\r",
      "import { formatTimeAgo } from '@vueuse/core'\r",
      "\r",
      "const timeAgo = formatTimeAgo(new Date(2021, 0, 1)) // string\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRefOrGetter, Pausable } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import type { ComputedRef } from 'vue-demi'\r",
      "import { computed } from 'vue-demi'\r",
      "import { useNow } from '../useNow'\r",
      "\r",
      "export type UseTimeAgoFormatter<T = number> = (value: T, isPast: boolean) => string\r",
      "\r",
      "export type UseTimeAgoUnitNamesDefault = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year'\r",
      "\r",
      "export interface UseTimeAgoMessagesBuiltIn {\r",
      "  justNow: string\r",
      "  past: string | UseTimeAgoFormatter<string>\r",
      "  future: string | UseTimeAgoFormatter<string>\r",
      "  invalid: string\r",
      "}\r",
      "\r",
      "export type UseTimeAgoMessages<UnitNames extends string = UseTimeAgoUnitNamesDefault>\r",
      "  = UseTimeAgoMessagesBuiltIn\r",
      "  & Record<UnitNames, string | UseTimeAgoFormatter<number>>\r",
      "\r",
      "export interface FormatTimeAgoOptions<UnitNames extends string = UseTimeAgoUnitNamesDefault> {\r",
      "  /**\r",
      "   * Maximum unit (of diff in milliseconds) to display the full date instead of relative\r",
      "   *\r",
      "   * @default undefined\r",
      "   */\r",
      "  max?: UnitNames | number\r",
      "\r",
      "  /**\r",
      "   * Formatter for full date\r",
      "   */\r",
      "  fullDateFormatter?: (date: Date) => string\r",
      "\r",
      "  /**\r",
      "   * Messages for formatting the string\r",
      "   */\r",
      "  messages?: UseTimeAgoMessages<UnitNames>\r",
      "\r",
      "  /**\r",
      "   * Minimum display time unit (default is minute)\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  showSecond?: boolean\r",
      "\r",
      "  /**\r",
      "   * Rounding method to apply.\r",
      "   *\r",
      "   * @default 'round'\r",
      "   */\r",
      "  rounding?: 'round' | 'ceil' | 'floor' | number\r",
      "\r",
      "  /**\r",
      "   * Custom units\r",
      "   */\r",
      "  units?: UseTimeAgoUnit<UseTimeAgoUnitNamesDefault>[]\r",
      "}\r",
      "\r",
      "export interface UseTimeAgoOptions<Controls extends boolean, UnitNames extends string = UseTimeAgoUnitNamesDefault> extends FormatTimeAgoOptions<UnitNames> {\r",
      "  /**\r",
      "   * Expose more controls\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  controls?: Controls\r",
      "\r",
      "  /**\r",
      "   * Intervals to update, set 0 to disable auto update\r",
      "   *\r",
      "   * @default 30_000\r",
      "   */\r",
      "  updateInterval?: number\r",
      "}\r",
      "\r",
      "export interface UseTimeAgoUnit<Unit extends string = UseTimeAgoUnitNamesDefault> {\r",
      "  max: number\r",
      "  value: number\r",
      "  name: Unit\r",
      "}\r",
      "\r",
      "const DEFAULT_UNITS: UseTimeAgoUnit<UseTimeAgoUnitNamesDefault>[] = [\r",
      "  { max: 60000, value: 1000, name: 'second' },\r",
      "  { max: 2760000, value: 60000, name: 'minute' },\r",
      "  { max: 72000000, value: 3600000, name: 'hour' },\r",
      "  { max: 518400000, value: 86400000, name: 'day' },\r",
      "  { max: 2419200000, value: 604800000, name: 'week' },\r",
      "  { max: 28512000000, value: 2592000000, name: 'month' },\r",
      "  { max: Number.POSITIVE_INFINITY, value: 31536000000, name: 'year' },\r",
      "]\r",
      "\r",
      "const DEFAULT_MESSAGES: UseTimeAgoMessages<UseTimeAgoUnitNamesDefault> = {\r",
      "  justNow: 'just now',\r",
      "  past: n => n.match(/\\d/) ? `${n} ago` : n,\r",
      "  future: n => n.match(/\\d/) ? `in ${n}` : n,\r",
      "  month: (n, past) => n === 1\r",
      "    ? past\r",
      "      ? 'last month'\r",
      "      : 'next month'\r",
      "    : `${n} month${n > 1 ? 's' : ''}`,\r",
      "  year: (n, past) => n === 1\r",
      "    ? past\r",
      "      ? 'last year'\r",
      "      : 'next year'\r",
      "    : `${n} year${n > 1 ? 's' : ''}`,\r",
      "  day: (n, past) => n === 1\r",
      "    ? past\r",
      "      ? 'yesterday'\r",
      "      : 'tomorrow'\r",
      "    : `${n} day${n > 1 ? 's' : ''}`,\r",
      "  week: (n, past) => n === 1\r",
      "    ? past\r",
      "      ? 'last week'\r",
      "      : 'next week'\r",
      "    : `${n} week${n > 1 ? 's' : ''}`,\r",
      "  hour: n => `${n} hour${n > 1 ? 's' : ''}`,\r",
      "  minute: n => `${n} minute${n > 1 ? 's' : ''}`,\r",
      "  second: n => `${n} second${n > 1 ? 's' : ''}`,\r",
      "  invalid: '',\r",
      "}\r",
      "\r",
      "function DEFAULT_FORMATTER(date: Date) {\r",
      "  return date.toISOString().slice(0, 10)\r",
      "}\r",
      "\r",
      "export type UseTimeAgoReturn<Controls extends boolean = false> = Controls extends true ? { timeAgo: ComputedRef<string> } & Pausable : ComputedRef<string>\r",
      "\r",
      "/**\r",
      " * Reactive time ago formatter.\r",
      " *\r",
      " * @see https://vueuse.org/useTimeAgo\r",
      " * @param options\r",
      " */\r",
      "export function useTimeAgo<UnitNames extends string = UseTimeAgoUnitNamesDefault>(time: MaybeRefOrGetter<Date | number | string>, options?: UseTimeAgoOptions<false, UnitNames>): UseTimeAgoReturn<false>\r",
      "export function useTimeAgo<UnitNames extends string = UseTimeAgoUnitNamesDefault>(time: MaybeRefOrGetter<Date | number | string>, options: UseTimeAgoOptions<true, UnitNames>): UseTimeAgoReturn<true>\r",
      "export function useTimeAgo<UnitNames extends string = UseTimeAgoUnitNamesDefault>(time: MaybeRefOrGetter<Date | number | string>, options: UseTimeAgoOptions<boolean, UnitNames> = {}) {\r",
      "  const {\r",
      "    controls: exposeControls = false,\r",
      "    updateInterval = 30_000,\r",
      "  } = options\r",
      "\r",
      "  const { now, ...controls } = useNow({ interval: updateInterval, controls: true })\r",
      "  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)))\r",
      "\r",
      "  if (exposeControls) {\r",
      "    return {\r",
      "      timeAgo,\r",
      "      ...controls,\r",
      "    }\r",
      "  }\r",
      "  else {\r",
      "    return timeAgo\r",
      "  }\r",
      "}\r",
      "\r",
      "export function formatTimeAgo<UnitNames extends string = UseTimeAgoUnitNamesDefault>(from: Date, options: FormatTimeAgoOptions<UnitNames> = {}, now: Date | number = Date.now()): string {\r",
      "  const {\r",
      "    max,\r",
      "    messages = DEFAULT_MESSAGES as UseTimeAgoMessages<UnitNames>,\r",
      "    fullDateFormatter = DEFAULT_FORMATTER,\r",
      "    units = DEFAULT_UNITS,\r",
      "    showSecond = false,\r",
      "    rounding = 'round',\r",
      "  } = options\r",
      "\r",
      "  const roundFn = typeof rounding === 'number'\r",
      "    ? (n: number) => +n.toFixed(rounding)\r",
      "    : Math[rounding]\r",
      "\r",
      "  const diff = +now - +from\r",
      "  const absDiff = Math.abs(diff)\r",
      "\r",
      "  function getValue(diff: number, unit: UseTimeAgoUnit) {\r",
      "    return roundFn(Math.abs(diff) / unit.value)\r",
      "  }\r",
      "\r",
      "  function format(diff: number, unit: UseTimeAgoUnit) {\r",
      "    const val = getValue(diff, unit)\r",
      "    const past = diff > 0\r",
      "\r",
      "    const str = applyFormat(unit.name as UnitNames, val, past)\r",
      "    return applyFormat(past ? 'past' : 'future', str, past)\r",
      "  }\r",
      "\r",
      "  function applyFormat(name: UnitNames | keyof UseTimeAgoMessagesBuiltIn, val: number | string, isPast: boolean) {\r",
      "    const formatter = messages[name]\r",
      "    if (typeof formatter === 'function')\r",
      "      return formatter(val as never, isPast)\r",
      "    return formatter.replace('{0}', val.toString())\r",
      "  }\r",
      "\r",
      "  // less than a minute\r",
      "  if (absDiff < 60000 && !showSecond)\r",
      "    return messages.justNow\r",
      "\r",
      "  if (typeof max === 'number' && absDiff > max)\r",
      "    return fullDateFormatter(new Date(from))\r",
      "\r",
      "  if (typeof max === 'string') {\r",
      "    const unitMax = units.find(i => i.name === max)?.max\r",
      "    if (unitMax && absDiff > unitMax)\r",
      "      return fullDateFormatter(new Date(from))\r",
      "  }\r",
      "\r",
      "  for (const [idx, unit] of units.entries()) {\r",
      "    const val = getValue(diff, unit)\r",
      "    if (val <= 0 && units[idx - 1])\r",
      "      return format(diff, units[idx - 1])\r",
      "    if (absDiff < unit.max)\r",
      "      return format(diff, unit)\r",
      "  }\r",
      "\r",
      "  return messages.invalid\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { timestamp } from '@vueuse/shared'\r",
      "import { computed, ref } from 'vue'\r",
      "import { useTimeAgo } from '@vueuse/core'\r",
      "\r",
      "const slider = ref(0)\r",
      "const value = computed(() => timestamp() + slider.value ** 3)\r",
      "const timeAgo = useTimeAgo(value)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"text-primary text-center\">\r",
      "    {{ timeAgo }}\r",
      "  </div>\r",
      "  <input v-model=\"slider\" class=\"slider\" type=\"range\" min=\"-3800\" max=\"3800\">\r",
      "  <div class=\"text-center opacity-50\">\r",
      "    {{ slider ** 3 }}ms\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style>\r",
      ".slider {\r",
      "  -webkit-appearance: none;\r",
      "  width: 100%;\r",
      "  background: rgba(125, 125, 125, 0.1);\r",
      "  border-radius: 1rem;\r",
      "  height: 1rem;\r",
      "  opacity: 0.8;\r",
      "  margin: 0.5rem 0;\r",
      "  outline: none !important;\r",
      "  transition: opacity .2s;\r",
      "}\r",
      "\r",
      ".slider:hover {\r",
      "  opacity: 1;\r",
      "}\r",
      "\r",
      ".slider::-webkit-slider-thumb {\r",
      "  -webkit-appearance: none;\r",
      "  appearance: none;\r",
      "  width: 1.3rem;\r",
      "  height: 1.3rem;\r",
      "  background: var(--vp-c-brand);\r",
      "  cursor: pointer;\r",
      "  border-radius: 50%;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTimeoutPoll - vueuse": {
    "prefix": "hvue useTimeoutPoll - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useTimeoutPoll\r",
      "\r",
      "Use timeout to poll something. It's will trigger callback after last task is done.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useTimeoutPoll } from '@vueuse/core'\r",
      "\r",
      "const count = ref(0)\r",
      "\r",
      "async function fetchData() {\r",
      "  await promiseTimeout(1000)\r",
      "  count.value++\r",
      "}\r",
      "\r",
      "// Only trigger after last fetch is done\r",
      "const { isActive, pause, resume } = useTimeoutPoll(fetchData, 1000)\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import type { Awaitable, MaybeRefOrGetter, Pausable, UseTimeoutFnOptions } from '@vueuse/shared'\r",
      "import { tryOnScopeDispose, useTimeoutFn } from '@vueuse/shared'\r",
      "\r",
      "export function useTimeoutPoll(fn: () => Awaitable<void>, interval: MaybeRefOrGetter<number>, timeoutPollOptions?: UseTimeoutFnOptions): Pausable {\r",
      "  const { start } = useTimeoutFn(loop, interval, { immediate: false })\r",
      "\r",
      "  const isActive = ref(false)\r",
      "\r",
      "  async function loop() {\r",
      "    if (!isActive.value)\r",
      "      return\r",
      "\r",
      "    await fn()\r",
      "    start()\r",
      "  }\r",
      "\r",
      "  function resume() {\r",
      "    if (!isActive.value) {\r",
      "      isActive.value = true\r",
      "      loop()\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function pause() {\r",
      "    isActive.value = false\r",
      "  }\r",
      "\r",
      "  if (timeoutPollOptions?.immediate)\r",
      "    resume()\r",
      "\r",
      "  tryOnScopeDispose(pause)\r",
      "\r",
      "  return {\r",
      "    isActive,\r",
      "    pause,\r",
      "    resume,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { promiseTimeout } from '@vueuse/shared'\r",
      "import { useTimeoutPoll } from '@vueuse/core'\r",
      "\r",
      "const count = ref(0)\r",
      "\r",
      "async function fetchData() {\r",
      "  await promiseTimeout(1000)\r",
      "  count.value++\r",
      "}\r",
      "\r",
      "const { isActive, pause, resume } = useTimeoutPoll(fetchData, 1000)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div>Count: {{ count }}</div>\r",
      "    <div>isActive: {{ isActive }}</div>\r",
      "    <div>\r",
      "      <button @click=\"pause\">\r",
      "        pause\r",
      "      </button>\r",
      "      <button @click=\"resume\">\r",
      "        resume\r",
      "      </button>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTimestamp - vueuse": {
    "prefix": "hvue useTimestamp - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Animation\r",
      "---\r",
      "\r",
      "# useTimestamp\r",
      "\r",
      "Reactive current timestamp\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useTimestamp } from '@vueuse/core'\r",
      "\r",
      "const timestamp = useTimestamp({ offset: 0 })\r",
      "```\r",
      "\r",
      "```js\r",
      "const { timestamp, pause, resume } = useTimestamp({ controls: true })\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseTimestamp v-slot=\"{ timestamp, pause, resume }\">\r",
      "  Current Time: {{ timestamp }}\r",
      "  <button @click=\"pause()\">Pause</button>\r",
      "  <button @click=\"resume()\">Resume</button>\r",
      "</UseTimestamp>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Pausable } from '@vueuse/shared'\r",
      "import { timestamp, useIntervalFn } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { useRafFn } from '../useRafFn'\r",
      "\r",
      "export interface UseTimestampOptions<Controls extends boolean> {\r",
      "  /**\r",
      "   * Expose more controls\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  controls?: Controls\r",
      "\r",
      "  /**\r",
      "   * Offset value adding to the value\r",
      "   *\r",
      "   * @default 0\r",
      "   */\r",
      "  offset?: number\r",
      "\r",
      "  /**\r",
      "   * Update the timestamp immediately\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "\r",
      "  /**\r",
      "   * Update interval, or use requestAnimationFrame\r",
      "   *\r",
      "   * @default requestAnimationFrame\r",
      "   */\r",
      "  interval?: 'requestAnimationFrame' | number\r",
      "  /**\r",
      "   * Callback on each update\r",
      "   */\r",
      "  callback?: (timestamp: number) => void\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive current timestamp.\r",
      " *\r",
      " * @see https://vueuse.org/useTimestamp\r",
      " * @param options\r",
      " */\r",
      "export function useTimestamp(options?: UseTimestampOptions<false>): Ref<number>\r",
      "export function useTimestamp(options: UseTimestampOptions<true>): { timestamp: Ref<number> } & Pausable\r",
      "export function useTimestamp(options: UseTimestampOptions<boolean> = {}) {\r",
      "  const {\r",
      "    controls: exposeControls = false,\r",
      "    offset = 0,\r",
      "    immediate = true,\r",
      "    interval = 'requestAnimationFrame',\r",
      "    callback,\r",
      "  } = options\r",
      "\r",
      "  const ts = ref(timestamp() + offset)\r",
      "\r",
      "  const update = () => ts.value = timestamp() + offset\r",
      "  const cb = callback\r",
      "    ? () => {\r",
      "        update()\r",
      "        callback(ts.value)\r",
      "      }\r",
      "    : update\r",
      "\r",
      "  const controls: Pausable = interval === 'requestAnimationFrame'\r",
      "    ? useRafFn(cb, { immediate })\r",
      "    : useIntervalFn(cb, interval, { immediate })\r",
      "\r",
      "  if (exposeControls) {\r",
      "    return {\r",
      "      timestamp: ts,\r",
      "      ...controls,\r",
      "    }\r",
      "  }\r",
      "  else {\r",
      "    return ts\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseTimestampReturn = ReturnType<typeof useTimestamp>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useTimestamp } from '@vueuse/core'\r",
      "\r",
      "const timestamp = useTimestamp()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Timestamp: {{ timestamp }}</div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTitle - vueuse": {
    "prefix": "hvue useTitle - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useTitle\r",
      "\r",
      "Reactive document title.\r",
      "\r",
      "::: tip\r",
      "When using with Nuxt 3, this function will **NOT** be auto imported in favor of Nuxt's built-in `useTitle()`.\r",
      "Use explicit import if you want to use the function from VueUse.\r",
      ":::\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useTitle } from '@vueuse/core'\r",
      "\r",
      "const title = useTitle()\r",
      "console.log(title.value) // print current title\r",
      "title.value = 'Hello' // change current title\r",
      "```\r",
      "\r",
      "Set initial title immediately:\r",
      "\r",
      "```js\r",
      "const title = useTitle('New Title')\r",
      "```\r",
      "\r",
      "Pass a `ref` and the title will be updated when the source ref changes:\r",
      "\r",
      "```js\r",
      "import { useTitle } from '@vueuse/core'\r",
      "\r",
      "const messages = ref(0)\r",
      "\r",
      "const title = computed(() => {\r",
      "  return !messages.value ? 'No message' : `${messages.value} new messages`\r",
      "})\r",
      "\r",
      "useTitle(title) // document title will match with the ref \"title\"\r",
      "```\r",
      "\r",
      "Pass an optional template tag [Vue Meta Title Template](https://vue-meta.nuxtjs.org/guide/metainfo.html) to update the title to be injected into this template:\r",
      "\r",
      "```js\r",
      "const title = useTitle('New Title', { titleTemplate: '%s | My Awesome Website' })\r",
      "```\r",
      "\r",
      "::: warning\r",
      "`observe` is incompatible with `titleTemplate`.\r",
      ":::\r",
      "# Source TS",
      "```js",
      "import type { MaybeRef, MaybeRefOrGetter, ReadonlyRefOrGetter } from '@vueuse/shared'\r",
      "import { toRef, toValue } from '@vueuse/shared'\r",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { watch } from 'vue-demi'\r",
      "import { useMutationObserver } from '../useMutationObserver'\r",
      "import type { ConfigurableDocument } from '../_configurable'\r",
      "import { defaultDocument } from '../_configurable'\r",
      "\r",
      "export type UseTitleOptionsBase =\r",
      "{\r",
      "  /**\r",
      "   * Observe `document.title` changes using MutationObserve\r",
      "   * Cannot be used together with `titleTemplate` option.\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  observe?: boolean\r",
      "}\r",
      "| {\r",
      "  /**\r",
      "   * The template string to parse the title (e.g., '%s | My Website')\r",
      "   * Cannot be used together with `observe` option.\r",
      "   *\r",
      "   * @default '%s'\r",
      "   */\r",
      "  titleTemplate?: MaybeRef<string> | ((title: string) => string)\r",
      "}\r",
      "\r",
      "export type UseTitleOptions = ConfigurableDocument & UseTitleOptionsBase\r",
      "\r",
      "export function useTitle(\r",
      "  newTitle: ReadonlyRefOrGetter<string | null | undefined>,\r",
      "  options?: UseTitleOptions,\r",
      "): ComputedRef<string | null | undefined>\r",
      "\r",
      "export function useTitle(\r",
      "  newTitle?: MaybeRef<string | null | undefined>,\r",
      "  options?: UseTitleOptions,\r",
      "): Ref<string | null | undefined>\r",
      "\r",
      "/**\r",
      " * Reactive document title.\r",
      " *\r",
      " * @see https://vueuse.org/useTitle\r",
      " * @param newTitle\r",
      " * @param options\r",
      " */\r",
      "export function useTitle(\r",
      "  newTitle: MaybeRefOrGetter<string | null | undefined> = null,\r",
      "  options: UseTitleOptions = {},\r",
      ") {\r",
      "  /*\r",
      "    `titleTemplate` that returns the modified input string will make\r",
      "    the `document.title` to be different from the `title.value`,\r",
      "    causing the title to update infinitely if `observe` is set to `true`.\r",
      "  */\r",
      "  const {\r",
      "    document = defaultDocument,\r",
      "  } = options\r",
      "\r",
      "  const title: Ref<string | null | undefined> = toRef(newTitle ?? document?.title ?? null)\r",
      "  const isReadonly = newTitle && typeof newTitle === 'function'\r",
      "\r",
      "  function format(t: string) {\r",
      "    if (!('titleTemplate' in options))\r",
      "      return t\r",
      "    const template = options.titleTemplate || '%s'\r",
      "    return typeof template === 'function'\r",
      "      ? template(t)\r",
      "      : toValue(template).replace(/%s/g, t)\r",
      "  }\r",
      "\r",
      "  watch(\r",
      "    title,\r",
      "    (t, o) => {\r",
      "      if (t !== o && document)\r",
      "        document.title = format(typeof t === 'string' ? t : '')\r",
      "    },\r",
      "    { immediate: true },\r",
      "  )\r",
      "\r",
      "  if ((options as any).observe && !(options as any).titleTemplate && document && !isReadonly) {\r",
      "    useMutationObserver(\r",
      "      document.head?.querySelector('title'),\r",
      "      () => {\r",
      "        if (document && document.title !== title.value)\r",
      "          title.value = format(document.title)\r",
      "      },\r",
      "      { childList: true },\r",
      "    )\r",
      "  }\r",
      "\r",
      "  return title\r",
      "}\r",
      "\r",
      "export type UseTitleReturn = ReturnType<typeof useTitle>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useTitle } from '@vueuse/core'\r",
      "\r",
      "const title = useTitle(null)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note>Title</note>\r",
      "  <input v-model=\"title\" type=\"text\">\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTransition - vueuse": {
    "prefix": "hvue useTransition - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Animation\r",
      "---\r",
      "\r",
      "# useTransition\r",
      "\r",
      "Transition between values\r",
      "\r",
      "## Usage\r",
      "\r",
      "Define a numeric source value to follow, and when changed the output will transition to the new value. If the source changes while a transition is in progress, a new transition will begin from where the previous one was interrupted.\r",
      "\r",
      "```js\r",
      "import { ref } from 'vue'\r",
      "import { TransitionPresets, useTransition } from '@vueuse/core'\r",
      "\r",
      "const source = ref(0)\r",
      "\r",
      "const output = useTransition(source, {\r",
      "  duration: 1000,\r",
      "  transition: TransitionPresets.easeInOutCubic,\r",
      "})\r",
      "```\r",
      "\r",
      "To synchronize transitions, use an array of numbers. As an example, here is how we could transition between colors.\r",
      "\r",
      "```js\r",
      "const source = ref([0, 0, 0])\r",
      "\r",
      "const output = useTransition(source)\r",
      "\r",
      "const color = computed(() => {\r",
      "  const [r, g, b] = output.value\r",
      "  return `rgb(${r}, ${g}, ${b})`\r",
      "})\r",
      "```\r",
      "\r",
      "Transition easing can be customized using cubic bezier curves. Transitions defined this way work the same as [CSS easing functions](https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#easing_functions).\r",
      "\r",
      "```js\r",
      "useTransition(source, {\r",
      "  transition: [0.75, 0, 0.25, 1],\r",
      "})\r",
      "```\r",
      "\r",
      "The following transitions are available via the `TransitionPresets` constant.\r",
      "\r",
      "- [`linear`](https://cubic-bezier.com/#0,0,1,1)\r",
      "- [`easeInSine`](https://cubic-bezier.com/#.12,0,.39,0)\r",
      "- [`easeOutSine`](https://cubic-bezier.com/#.61,1,.88,1)\r",
      "- [`easeInOutSine`](https://cubic-bezier.com/#.37,0,.63,1)\r",
      "- [`easeInQuad`](https://cubic-bezier.com/#.11,0,.5,0)\r",
      "- [`easeOutQuad`](https://cubic-bezier.com/#.5,1,.89,1)\r",
      "- [`easeInOutQuad`](https://cubic-bezier.com/#.45,0,.55,1)\r",
      "- [`easeInCubic`](https://cubic-bezier.com/#.32,0,.67,0)\r",
      "- [`easeOutCubic`](https://cubic-bezier.com/#.33,1,.68,1)\r",
      "- [`easeInOutCubic`](https://cubic-bezier.com/#.65,0,.35,1)\r",
      "- [`easeInQuart`](https://cubic-bezier.com/#.5,0,.75,0)\r",
      "- [`easeOutQuart`](https://cubic-bezier.com/#.25,1,.5,1)\r",
      "- [`easeInOutQuart`](https://cubic-bezier.com/#.76,0,.24,1)\r",
      "- [`easeInQuint`](https://cubic-bezier.com/#.64,0,.78,0)\r",
      "- [`easeOutQuint`](https://cubic-bezier.com/#.22,1,.36,1)\r",
      "- [`easeInOutQuint`](https://cubic-bezier.com/#.83,0,.17,1)\r",
      "- [`easeInExpo`](https://cubic-bezier.com/#.7,0,.84,0)\r",
      "- [`easeOutExpo`](https://cubic-bezier.com/#.16,1,.3,1)\r",
      "- [`easeInOutExpo`](https://cubic-bezier.com/#.87,0,.13,1)\r",
      "- [`easeInCirc`](https://cubic-bezier.com/#.55,0,1,.45)\r",
      "- [`easeOutCirc`](https://cubic-bezier.com/#0,.55,.45,1)\r",
      "- [`easeInOutCirc`](https://cubic-bezier.com/#.85,0,.15,1)\r",
      "- [`easeInBack`](https://cubic-bezier.com/#.36,0,.66,-.56)\r",
      "- [`easeOutBack`](https://cubic-bezier.com/#.34,1.56,.64,1)\r",
      "- [`easeInOutBack`](https://cubic-bezier.com/#.68,-.6,.32,1.6)\r",
      "\r",
      "For more complex transitions, a custom function can be provided.\r",
      "\r",
      "```js\r",
      "function easeOutElastic(n) {\r",
      "  return n === 0\r",
      "    ? 0\r",
      "    : n === 1\r",
      "      ? 1\r",
      "      : (2 ** (-10 * n)) * Math.sin((n * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1\r",
      "}\r",
      "\r",
      "useTransition(source, {\r",
      "  transition: easeOutElastic,\r",
      "})\r",
      "```\r",
      "\r",
      "To control when a transition starts, set a `delay` value. To choreograph behavior around a transition, define `onStarted` or `onFinished` callbacks.\r",
      "\r",
      "```js\r",
      "useTransition(source, {\r",
      "  delay: 1000,\r",
      "  onStarted() {\r",
      "    // called after the transition starts\r",
      "  },\r",
      "  onFinished() {\r",
      "    // called after the transition ends\r",
      "  },\r",
      "})\r",
      "```\r",
      "\r",
      "To temporarily stop transitioning, define a boolean `disabled` property. Be aware, this is not the same a `duration` of `0`. Disabled transitions track the source value **_synchronously_**. They do not respect a `delay`, and do not fire `onStarted` or `onFinished` callbacks.\r",
      "\r",
      "For more control, transitions can be executed manually by using `executeTransition`. This function returns a promise that resolves upon completion. Manual transitions can be cancelled by defining an `abort` function that returns a truthy value.\r",
      "\r",
      "```js\r",
      "import { executeTransition } from '@vueuse/core'\r",
      "\r",
      "await executeTransition(source, from, to, {\r",
      "  duration: 1000,\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed, ref, watch } from 'vue-demi'\r",
      "import { identity as linear, promiseTimeout, toValue, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import type { MaybeRef, MaybeRefOrGetter } from '@vueuse/shared'\r",
      "\r",
      "/**\r",
      " * Cubic bezier points\r",
      " */\r",
      "export type CubicBezierPoints = [number, number, number, number]\r",
      "\r",
      "/**\r",
      " * Easing function\r",
      " */\r",
      "export type EasingFunction = (n: number) => number\r",
      "\r",
      "/**\r",
      " * Transition options\r",
      " */\r",
      "export interface TransitionOptions {\r",
      "\r",
      "  /**\r",
      "   * Manually abort a transition\r",
      "   */\r",
      "  abort?: () => any\r",
      "\r",
      "  /**\r",
      "   * Transition duration in milliseconds\r",
      "   */\r",
      "  duration?: MaybeRef<number>\r",
      "\r",
      "  /**\r",
      "   * Easing function or cubic bezier points for calculating transition values\r",
      "   */\r",
      "  transition?: MaybeRef<EasingFunction | CubicBezierPoints>\r",
      "}\r",
      "\r",
      "export interface UseTransitionOptions extends TransitionOptions {\r",
      "  /**\r",
      "   * Milliseconds to wait before starting transition\r",
      "   */\r",
      "  delay?: MaybeRef<number>\r",
      "\r",
      "  /**\r",
      "   * Disables the transition\r",
      "   */\r",
      "  disabled?: MaybeRef<boolean>\r",
      "\r",
      "  /**\r",
      "   * Callback to execute after transition finishes\r",
      "   */\r",
      "  onFinished?: () => void\r",
      "\r",
      "  /**\r",
      "   * Callback to execute after transition starts\r",
      "   */\r",
      "  onStarted?: () => void\r",
      "}\r",
      "\r",
      "const _TransitionPresets = {\r",
      "  easeInSine: [0.12, 0, 0.39, 0],\r",
      "  easeOutSine: [0.61, 1, 0.88, 1],\r",
      "  easeInOutSine: [0.37, 0, 0.63, 1],\r",
      "  easeInQuad: [0.11, 0, 0.5, 0],\r",
      "  easeOutQuad: [0.5, 1, 0.89, 1],\r",
      "  easeInOutQuad: [0.45, 0, 0.55, 1],\r",
      "  easeInCubic: [0.32, 0, 0.67, 0],\r",
      "  easeOutCubic: [0.33, 1, 0.68, 1],\r",
      "  easeInOutCubic: [0.65, 0, 0.35, 1],\r",
      "  easeInQuart: [0.5, 0, 0.75, 0],\r",
      "  easeOutQuart: [0.25, 1, 0.5, 1],\r",
      "  easeInOutQuart: [0.76, 0, 0.24, 1],\r",
      "  easeInQuint: [0.64, 0, 0.78, 0],\r",
      "  easeOutQuint: [0.22, 1, 0.36, 1],\r",
      "  easeInOutQuint: [0.83, 0, 0.17, 1],\r",
      "  easeInExpo: [0.7, 0, 0.84, 0],\r",
      "  easeOutExpo: [0.16, 1, 0.3, 1],\r",
      "  easeInOutExpo: [0.87, 0, 0.13, 1],\r",
      "  easeInCirc: [0.55, 0, 1, 0.45],\r",
      "  easeOutCirc: [0, 0.55, 0.45, 1],\r",
      "  easeInOutCirc: [0.85, 0, 0.15, 1],\r",
      "  easeInBack: [0.36, 0, 0.66, -0.56],\r",
      "  easeOutBack: [0.34, 1.56, 0.64, 1],\r",
      "  easeInOutBack: [0.68, -0.6, 0.32, 1.6],\r",
      "} as const\r",
      "\r",
      "/**\r",
      " * Common transitions\r",
      " *\r",
      " * @see https://easings.net\r",
      " */\r",
      "export const TransitionPresets = /*#__PURE__*/ Object.assign({}, { linear }, _TransitionPresets) as Record<keyof typeof _TransitionPresets, CubicBezierPoints> & { linear: EasingFunction }\r",
      "\r",
      "/**\r",
      " * Create an easing function from cubic bezier points.\r",
      " */\r",
      "function createEasingFunction([p0, p1, p2, p3]: CubicBezierPoints): EasingFunction {\r",
      "  const a = (a1: number, a2: number) => 1 - 3 * a2 + 3 * a1\r",
      "  const b = (a1: number, a2: number) => 3 * a2 - 6 * a1\r",
      "  const c = (a1: number) => 3 * a1\r",
      "\r",
      "  const calcBezier = (t: number, a1: number, a2: number) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t\r",
      "\r",
      "  const getSlope = (t: number, a1: number, a2: number) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1)\r",
      "\r",
      "  const getTforX = (x: number) => {\r",
      "    let aGuessT = x\r",
      "\r",
      "    for (let i = 0; i < 4; ++i) {\r",
      "      const currentSlope = getSlope(aGuessT, p0, p2)\r",
      "      if (currentSlope === 0)\r",
      "        return aGuessT\r",
      "      const currentX = calcBezier(aGuessT, p0, p2) - x\r",
      "      aGuessT -= currentX / currentSlope\r",
      "    }\r",
      "\r",
      "    return aGuessT\r",
      "  }\r",
      "\r",
      "  return (x: number) => (p0 === p1 && p2 === p3) ? x : calcBezier(getTforX(x), p1, p3)\r",
      "}\r",
      "\r",
      "function lerp(a: number, b: number, alpha: number) {\r",
      "  return a + alpha * (b - a)\r",
      "}\r",
      "\r",
      "function toVec(t: number | number[] | undefined) {\r",
      "  return (typeof t === 'number' ? [t] : t) || []\r",
      "}\r",
      "\r",
      "/**\r",
      " * Transition from one value to another.\r",
      " *\r",
      " * @param source\r",
      " * @param from\r",
      " * @param to\r",
      " * @param options\r",
      " */\r",
      "export function executeTransition<T extends number | number[]>(\r",
      "  source: Ref<T>,\r",
      "  from: MaybeRefOrGetter<T>,\r",
      "  to: MaybeRefOrGetter<T>,\r",
      "  options: TransitionOptions = {},\r",
      "): PromiseLike<void> {\r",
      "  const fromVal = toValue(from)\r",
      "  const toVal = toValue(to)\r",
      "  const v1 = toVec(fromVal)\r",
      "  const v2 = toVec(toVal)\r",
      "  const duration = toValue(options.duration) ?? 1000\r",
      "  const startedAt = Date.now()\r",
      "  const endAt = Date.now() + duration\r",
      "  const trans = typeof options.transition === 'function'\r",
      "    ? options.transition\r",
      "    : (toValue(options.transition) ?? linear)\r",
      "\r",
      "  const ease = typeof trans === 'function'\r",
      "    ? trans\r",
      "    : createEasingFunction(trans)\r",
      "\r",
      "  return new Promise<void>((resolve) => {\r",
      "    source.value = fromVal\r",
      "\r",
      "    const tick = () => {\r",
      "      if (options.abort?.()) {\r",
      "        resolve()\r",
      "\r",
      "        return\r",
      "      }\r",
      "\r",
      "      const now = Date.now()\r",
      "      const alpha = ease((now - startedAt) / duration)\r",
      "      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha))\r",
      "\r",
      "      if (Array.isArray(source.value))\r",
      "        (source.value as number[]) = arr.map((n, i) => lerp(v1[i] ?? 0, v2[i] ?? 0, alpha))\r",
      "      else if (typeof source.value === 'number')\r",
      "        (source.value as number) = arr[0]\r",
      "\r",
      "      if (now < endAt) {\r",
      "        requestAnimationFrame(tick)\r",
      "      }\r",
      "      else {\r",
      "        source.value = toVal\r",
      "\r",
      "        resolve()\r",
      "      }\r",
      "    }\r",
      "\r",
      "    tick()\r",
      "  })\r",
      "}\r",
      "\r",
      "// option 1: reactive number\r",
      "export function useTransition(source: MaybeRefOrGetter<number>, options?: UseTransitionOptions): ComputedRef<number>\r",
      "\r",
      "// option 2: static array of possibly reactive numbers\r",
      "export function useTransition<T extends MaybeRefOrGetter<number>[]>(source: [...T], options?: UseTransitionOptions): ComputedRef<{ [K in keyof T]: number }>\r",
      "\r",
      "// option 3: reactive array of numbers\r",
      "export function useTransition<T extends MaybeRefOrGetter<number[]>>(source: T, options?: UseTransitionOptions): ComputedRef<number[]>\r",
      "\r",
      "/**\r",
      " * Follow value with a transition.\r",
      " *\r",
      " * @see https://vueuse.org/useTransition\r",
      " * @param source\r",
      " * @param options\r",
      " */\r",
      "export function useTransition(\r",
      "  source: MaybeRefOrGetter<number | number[]> | MaybeRefOrGetter<number>[],\r",
      "  options: UseTransitionOptions = {},\r",
      "): Ref<any> {\r",
      "  let currentId = 0\r",
      "\r",
      "  const sourceVal = () => {\r",
      "    const v = toValue(source)\r",
      "\r",
      "    return typeof v === 'number'\r",
      "      ? v\r",
      "      : v.map(toValue<number>)\r",
      "  }\r",
      "\r",
      "  const outputRef = ref(sourceVal())\r",
      "\r",
      "  watch(sourceVal, async (to) => {\r",
      "    if (toValue(options.disabled))\r",
      "      return\r",
      "\r",
      "    const id = ++currentId\r",
      "\r",
      "    if (options.delay)\r",
      "      await promiseTimeout(toValue(options.delay))\r",
      "\r",
      "    if (id !== currentId)\r",
      "      return\r",
      "\r",
      "    const toVal = Array.isArray(to) ? to.map(toValue<number>) : toValue(to)\r",
      "\r",
      "    options.onStarted?.()\r",
      "\r",
      "    await executeTransition(outputRef, outputRef.value, toVal, {\r",
      "      ...options,\r",
      "      abort: () => id !== currentId || options.abort?.(),\r",
      "    })\r",
      "\r",
      "    options.onFinished?.()\r",
      "  }, { deep: true })\r",
      "\r",
      "  watch(() => toValue(options.disabled), (disabled) => {\r",
      "    if (disabled) {\r",
      "      currentId++\r",
      "\r",
      "      outputRef.value = sourceVal()\r",
      "    }\r",
      "  })\r",
      "\r",
      "  tryOnScopeDispose(() => {\r",
      "    currentId++\r",
      "  })\r",
      "\r",
      "  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value)\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { rand } from '@vueuse/shared'\r",
      "import { ref } from 'vue'\r",
      "import { TransitionPresets, useTransition } from '@vueuse/core'\r",
      "\r",
      "const duration = 1500\r",
      "\r",
      "const baseNumber = ref(0)\r",
      "\r",
      "const baseVector = ref([0, 0])\r",
      "\r",
      "function easeOutElastic(n: number) {\r",
      "  return n === 0\r",
      "    ? 0\r",
      "    : n === 1\r",
      "      ? 1\r",
      "      : (2 ** (-10 * n)) * Math.sin((n * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1\r",
      "}\r",
      "\r",
      "const cubicBezierNumber = useTransition(baseNumber, {\r",
      "  duration,\r",
      "  transition: [0.75, 0, 0.25, 1],\r",
      "})\r",
      "\r",
      "const customFnNumber = useTransition(baseNumber, {\r",
      "  duration,\r",
      "  transition: easeOutElastic,\r",
      "})\r",
      "\r",
      "const vector = useTransition(baseVector, {\r",
      "  duration,\r",
      "  transition: TransitionPresets.easeOutExpo,\r",
      "})\r",
      "\r",
      "function toggle() {\r",
      "  baseNumber.value = baseNumber.value === 100 ? 0 : 100\r",
      "  baseVector.value = [rand(0, 100), rand(0, 100)]\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <button @click=\"toggle\">\r",
      "      Transition\r",
      "    </button>\r",
      "\r",
      "    <p class=\"mt-2\">\r",
      "      Cubic bezier curve: <b>{{ cubicBezierNumber.toFixed(2) }}</b>\r",
      "    </p>\r",
      "\r",
      "    <div class=\"track number\">\r",
      "      <div class=\"relative\">\r",
      "        <div class=\"sled\" :style=\"{ left: `${cubicBezierNumber}%` }\" />\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <p class=\"mt-2\">\r",
      "      Custom function: <b>{{ customFnNumber.toFixed(2) }}</b>\r",
      "    </p>\r",
      "\r",
      "    <div class=\"track number\">\r",
      "      <div class=\"relative\">\r",
      "        <div class=\"sled\" :style=\"{ left: `${customFnNumber}%` }\" />\r",
      "      </div>\r",
      "    </div>\r",
      "\r",
      "    <p class=\"mt-2\">\r",
      "      Vector: <b>[{{ vector[0].toFixed(2) }}, {{ vector[1].toFixed(2) }}]</b>\r",
      "    </p>\r",
      "\r",
      "    <div class=\"track vector\">\r",
      "      <div class=\"relative\">\r",
      "        <div class=\"sled\" :style=\"{ left: `${vector[0]}%`, top: `${vector[1]}%` }\" />\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      ".track {\r",
      "  background: rgba(125, 125, 125, 0.3);\r",
      "  border-radius: 0.5rem;\r",
      "  max-width: 20rem;\r",
      "  width: 100%;\r",
      "}\r",
      "\r",
      ".sled {\r",
      "  background: var(--vp-c-brand);\r",
      "  border-radius: 50%;\r",
      "  height: 1rem;\r",
      "  position: absolute;\r",
      "  width: 1rem;\r",
      "}\r",
      "\r",
      ".number.track {\r",
      "  height: 1rem;\r",
      "  margin: 0.5rem 0;\r",
      "  padding: 0 0.5rem;\r",
      "}\r",
      "\r",
      ".number.track .sled {\r",
      "  transform: translateX(-50%);\r",
      "}\r",
      "\r",
      ".vector.track {\r",
      "  padding: 0.5rem;\r",
      "}\r",
      "\r",
      ".vector.track .relative {\r",
      "  padding-bottom: 30%;\r",
      "}\r",
      "\r",
      ".vector.track .sled {\r",
      "  transform: translateX(-50%) translateY(-50%);\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useUrlSearchParams - vueuse": {
    "prefix": "hvue useUrlSearchParams - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useUrlSearchParams\r",
      "\r",
      "Reactive [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useUrlSearchParams } from '@vueuse/core'\r",
      "\r",
      "const params = useUrlSearchParams('history')\r",
      "\r",
      "console.log(params.foo) // 'bar'\r",
      "\r",
      "params.foo = 'bar'\r",
      "params.vueuse = 'awesome'\r",
      "// url updated to `?foo=bar&vueuse=awesome`\r",
      "```\r",
      "\r",
      "### Hash Mode\r",
      "\r",
      "When using with hash mode route, specify the `mode` to `hash`\r",
      "\r",
      "```js\r",
      "import { useUrlSearchParams } from '@vueuse/core'\r",
      "\r",
      "const params = useUrlSearchParams('hash')\r",
      "\r",
      "params.foo = 'bar'\r",
      "params.vueuse = 'awesome'\r",
      "// url updated to `#/your/route?foo=bar&vueuse=awesome`\r",
      "```\r",
      "\r",
      "### Hash Params\r",
      "\r",
      "When using with history mode route, but want to use hash as params, specify the `mode` to `hash-params`\r",
      "\r",
      "```js\r",
      "import { useUrlSearchParams } from '@vueuse/core'\r",
      "\r",
      "const params = useUrlSearchParams('hash-params')\r",
      "\r",
      "params.foo = 'bar'\r",
      "params.vueuse = 'awesome'\r",
      "// url updated to `/your/route#foo=bar&vueuse=awesome`\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { reactive } from 'vue-demi'\r",
      "import { pausableWatch } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export type UrlParams = Record<string, string[] | string>\r",
      "\r",
      "export interface UseUrlSearchParamsOptions<T> extends ConfigurableWindow {\r",
      "  /**\r",
      "   * @default true\r",
      "   */\r",
      "  removeNullishValues?: boolean\r",
      "\r",
      "  /**\r",
      "   * @default false\r",
      "   */\r",
      "  removeFalsyValues?: boolean\r",
      "\r",
      "  /**\r",
      "   * @default {}\r",
      "   */\r",
      "  initialValue?: T\r",
      "\r",
      "  /**\r",
      "   * Write back to `window.history` automatically\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  write?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive URLSearchParams\r",
      " *\r",
      " * @see https://vueuse.org/useUrlSearchParams\r",
      " * @param mode\r",
      " * @param options\r",
      " */\r",
      "export function useUrlSearchParams<T extends Record<string, any> = UrlParams>(\r",
      "  mode: 'history' | 'hash' | 'hash-params' = 'history',\r",
      "  options: UseUrlSearchParamsOptions<T> = {},\r",
      "): T {\r",
      "  const {\r",
      "    initialValue = {},\r",
      "    removeNullishValues = true,\r",
      "    removeFalsyValues = false,\r",
      "    write: enableWrite = true,\r",
      "    window = defaultWindow!,\r",
      "  } = options\r",
      "\r",
      "  if (!window)\r",
      "    return reactive(initialValue) as T\r",
      "\r",
      "  const state: Record<string, any> = reactive({})\r",
      "\r",
      "  function getRawParams() {\r",
      "    if (mode === 'history') {\r",
      "      return window.location.search || ''\r",
      "    }\r",
      "    else if (mode === 'hash') {\r",
      "      const hash = window.location.hash || ''\r",
      "      const index = hash.indexOf('?')\r",
      "      return index > 0 ? hash.slice(index) : ''\r",
      "    }\r",
      "    else {\r",
      "      return (window.location.hash || '').replace(/^#/, '')\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function constructQuery(params: URLSearchParams) {\r",
      "    const stringified = params.toString()\r",
      "\r",
      "    if (mode === 'history')\r",
      "      return `${stringified ? `?${stringified}` : ''}${window.location.hash || ''}`\r",
      "    if (mode === 'hash-params')\r",
      "      return `${window.location.search || ''}${stringified ? `#${stringified}` : ''}`\r",
      "    const hash = window.location.hash || '#'\r",
      "    const index = hash.indexOf('?')\r",
      "    if (index > 0)\r",
      "      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : ''}`\r",
      "    return `${hash}${stringified ? `?${stringified}` : ''}`\r",
      "  }\r",
      "\r",
      "  function read() {\r",
      "    return new URLSearchParams(getRawParams())\r",
      "  }\r",
      "\r",
      "  function updateState(params: URLSearchParams) {\r",
      "    const unusedKeys = new Set(Object.keys(state))\r",
      "    for (const key of params.keys()) {\r",
      "      const paramsForKey = params.getAll(key)\r",
      "      state[key] = paramsForKey.length > 1\r",
      "        ? paramsForKey\r",
      "        : (params.get(key) || '')\r",
      "      unusedKeys.delete(key)\r",
      "    }\r",
      "    Array.from(unusedKeys).forEach(key => delete state[key])\r",
      "  }\r",
      "\r",
      "  const { pause, resume } = pausableWatch(\r",
      "    state,\r",
      "    () => {\r",
      "      const params = new URLSearchParams('')\r",
      "      Object.keys(state).forEach((key) => {\r",
      "        const mapEntry = state[key]\r",
      "        if (Array.isArray(mapEntry))\r",
      "          mapEntry.forEach(value => params.append(key, value))\r",
      "        else if (removeNullishValues && mapEntry == null)\r",
      "          params.delete(key)\r",
      "        else if (removeFalsyValues && !mapEntry)\r",
      "          params.delete(key)\r",
      "        else\r",
      "          params.set(key, mapEntry)\r",
      "      })\r",
      "      write(params)\r",
      "    },\r",
      "    { deep: true },\r",
      "  )\r",
      "\r",
      "  function write(params: URLSearchParams, shouldUpdate?: boolean) {\r",
      "    pause()\r",
      "\r",
      "    if (shouldUpdate)\r",
      "      updateState(params)\r",
      "\r",
      "    window.history.replaceState(\r",
      "      window.history.state,\r",
      "      window.document.title,\r",
      "      window.location.pathname + constructQuery(params),\r",
      "    )\r",
      "\r",
      "    resume()\r",
      "  }\r",
      "\r",
      "  function onChanged() {\r",
      "    if (!enableWrite)\r",
      "      return\r",
      "\r",
      "    write(read(), true)\r",
      "  }\r",
      "\r",
      "  useEventListener(window, 'popstate', onChanged, false)\r",
      "  if (mode !== 'history')\r",
      "    useEventListener(window, 'hashchange', onChanged, false)\r",
      "\r",
      "  const initial = read()\r",
      "  if (initial.keys().next().value)\r",
      "    updateState(initial)\r",
      "  else\r",
      "    Object.assign(state, initialValue)\r",
      "\r",
      "  return state as T\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useUrlSearchParams } from '@vueuse/core'\r",
      "\r",
      "const params = useUrlSearchParams('history')\r",
      "params.foo = 'bar'\r",
      "params.vueuse = 'awesome'\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <ul class=\"!m-0\">\r",
      "      <li v-for=\"key in Object.keys(params)\" :key=\"key\">\r",
      "        {{ key }}={{ params[key] }}\r",
      "      </li>\r",
      "    </ul>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useUserMedia - vueuse": {
    "prefix": "hvue useUserMedia - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Sensors\r",
      "related: useDevicesList, usePermission\r",
      "---\r",
      "\r",
      "# useUserMedia\r",
      "\r",
      "Reactive [`mediaDevices.getUserMedia`](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia) streaming.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useUserMedia } from '@vueuse/core'\r",
      "\r",
      "const { stream, start } = useUserMedia()\r",
      "\r",
      "start()\r",
      "```\r",
      "\r",
      "```ts\r",
      "const video = document.getElementById('video')\r",
      "\r",
      "watchEffect(() => {\r",
      "  // preview on a video element\r",
      "  video.srcObject = stream.value\r",
      "})\r",
      "```\r",
      "\r",
      "### Devices\r",
      "\r",
      "```js\r",
      "import { useDevicesList, useUserMedia } from '@vueuse/core'\r",
      "\r",
      "const {\r",
      "  videoInputs: cameras,\r",
      "  audioInputs: microphones,\r",
      "} = useDevicesList({\r",
      "  requestPermissions: true,\r",
      "})\r",
      "const currentCamera = computed(() => cameras.value[0]?.deviceId)\r",
      "const currentMicrophone = computed(() => microphones.value[0]?.deviceId)\r",
      "\r",
      "const { stream } = useUserMedia({\r",
      "  constraints: {\r",
      "    video: { deviceId: currentCamera },\r",
      "    audio: { deviceId: currentMicrophone, }\r",
      "  }\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "/* this implementation is original ported from https://github.com/logaretm/vue-use-web by Abdelrahman Awad */\r",
      "\r",
      "import type { MaybeRef } from '@vueuse/shared'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref, shallowRef, watch } from 'vue-demi'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableNavigator } from '../_configurable'\r",
      "import { defaultNavigator } from '../_configurable'\r",
      "\r",
      "export interface UseUserMediaOptions extends ConfigurableNavigator {\r",
      "  /**\r",
      "   * If the stream is enabled\r",
      "   * @default false\r",
      "   */\r",
      "  enabled?: MaybeRef<boolean>\r",
      "  /**\r",
      "   * Recreate stream when deviceIds or constraints changed\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  autoSwitch?: MaybeRef<boolean>\r",
      "  /**\r",
      "   * MediaStreamConstraints to be applied to the requested MediaStream\r",
      "   * If provided, the constraints will override videoDeviceId and audioDeviceId\r",
      "   *\r",
      "   * @default {}\r",
      "   */\r",
      "  constraints?: MaybeRef<MediaStreamConstraints>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive `mediaDevices.getUserMedia` streaming\r",
      " *\r",
      " * @see https://vueuse.org/useUserMedia\r",
      " * @param options\r",
      " */\r",
      "export function useUserMedia(options: UseUserMediaOptions = {}) {\r",
      "  const enabled = ref(options.enabled ?? false)\r",
      "  const autoSwitch = ref(options.autoSwitch ?? true)\r",
      "  const constraints = ref(options.constraints)\r",
      "  const { navigator = defaultNavigator } = options\r",
      "  const isSupported = useSupported(() => navigator?.mediaDevices?.getUserMedia)\r",
      "\r",
      "  const stream: Ref<MediaStream | undefined> = shallowRef()\r",
      "\r",
      "  function getDeviceOptions(type: 'video' | 'audio') {\r",
      "    switch (type) {\r",
      "      case 'video': {\r",
      "        if (constraints.value)\r",
      "          return constraints.value.video || false\r",
      "        break\r",
      "      }\r",
      "      case 'audio': {\r",
      "        if (constraints.value)\r",
      "          return constraints.value.audio || false\r",
      "        break\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "\r",
      "  async function _start() {\r",
      "    if (!isSupported.value || stream.value)\r",
      "      return\r",
      "    stream.value = await navigator!.mediaDevices.getUserMedia({\r",
      "      video: getDeviceOptions('video'),\r",
      "      audio: getDeviceOptions('audio'),\r",
      "    })\r",
      "    return stream.value\r",
      "  }\r",
      "\r",
      "  function _stop() {\r",
      "    stream.value?.getTracks().forEach(t => t.stop())\r",
      "    stream.value = undefined\r",
      "  }\r",
      "\r",
      "  function stop() {\r",
      "    _stop()\r",
      "    enabled.value = false\r",
      "  }\r",
      "\r",
      "  async function start() {\r",
      "    await _start()\r",
      "    if (stream.value)\r",
      "      enabled.value = true\r",
      "    return stream.value\r",
      "  }\r",
      "\r",
      "  async function restart() {\r",
      "    _stop()\r",
      "    return await start()\r",
      "  }\r",
      "\r",
      "  watch(\r",
      "    enabled,\r",
      "    (v) => {\r",
      "      if (v)\r",
      "        _start()\r",
      "      else _stop()\r",
      "    },\r",
      "    { immediate: true },\r",
      "  )\r",
      "\r",
      "  watch(\r",
      "    constraints,\r",
      "    () => {\r",
      "      if (autoSwitch.value && stream.value)\r",
      "        restart()\r",
      "    },\r",
      "    { immediate: true },\r",
      "  )\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    stream,\r",
      "    start,\r",
      "    stop,\r",
      "    restart,\r",
      "    constraints,\r",
      "    enabled,\r",
      "    autoSwitch,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseUserMediaReturn = ReturnType<typeof useUserMedia>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref, watchEffect } from 'vue'\r",
      "import { useDevicesList, useUserMedia } from '@vueuse/core'\r",
      "\r",
      "const currentCamera = ref<string>()\r",
      "const { videoInputs: cameras } = useDevicesList({\r",
      "  requestPermissions: true,\r",
      "  onUpdated() {\r",
      "    if (!cameras.value.find(i => i.deviceId === currentCamera.value))\r",
      "      currentCamera.value = cameras.value[0]?.deviceId\r",
      "  },\r",
      "})\r",
      "\r",
      "const video = ref<HTMLVideoElement>()\r",
      "const { stream, enabled } = useUserMedia({\r",
      "  constraints: { video: { deviceId: currentCamera } },\r",
      "})\r",
      "\r",
      "watchEffect(() => {\r",
      "  if (video.value)\r",
      "    video.value.srcObject = stream.value!\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"flex flex-col gap-4 text-center\">\r",
      "    <div>\r",
      "      <button @click=\"enabled = !enabled\">\r",
      "        {{ enabled ? 'Stop' : 'Start' }}\r",
      "      </button>\r",
      "    </div>\r",
      "\r",
      "    <div>\r",
      "      <div\r",
      "        v-for=\"camera of cameras\"\r",
      "        :key=\"camera.deviceId\"\r",
      "        class=\"px-2 py-1 cursor-pointer\"\r",
      "        :class=\"{ 'text-primary': currentCamera === camera.deviceId }\"\r",
      "        @click=\"currentCamera = camera.deviceId\"\r",
      "      >\r",
      "        {{ camera.label }}\r",
      "      </div>\r",
      "    </div>\r",
      "    <div>\r",
      "      <video ref=\"video\" muted autoplay controls class=\"h-100 w-auto\" />\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useVirtualList - vueuse": {
    "prefix": "hvue useVirtualList - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Component\r",
      "---\r",
      "\r",
      "# useVirtualList\r",
      "\r",
      "::: warning\r",
      "Consider using [`vue-virtual-scroller`](https://github.com/Akryum/vue-virtual-scroller) instead, if you are looking for more features.\r",
      ":::\r",
      "\r",
      "Create virtual lists with ease. Virtual lists (sometimes called [*virtual scrollers*](https://vue-virtual-scroller-demo.netlify.app/)) allow you to render a large number of items performantly. They only render the minimum number of DOM nodes necessary to show the items within the `container` element by using the `wrapper` element to emulate the container element's full height.\r",
      "\r",
      "## Usage\r",
      "\r",
      "### Simple list\r",
      "\r",
      "```typescript\r",
      "import { useVirtualList } from '@vueuse/core'\r",
      "\r",
      "const { list, containerProps, wrapperProps } = useVirtualList(\r",
      "  Array.from(Array(99999).keys()),\r",
      "  {\r",
      "    // Keep `itemHeight` in sync with the item's row.\r",
      "    itemHeight: 22,\r",
      "  },\r",
      ")\r",
      "```\r",
      "\r",
      "### Config\r",
      "\r",
      "| State      | Type     | Description                                                                                     |\r",
      "|------------|----------|-------------------------------------------------------------------------------------------------|\r",
      "| itemHeight | `number` | ensure that the total height of the `wrapper` element is calculated correctly.*                 |\r",
      "| itemWidth  | `number` | ensure that the total width of the `wrapper` element is calculated correctly.*                  |\r",
      "| overscan   | `number` | number of pre-rendered DOM nodes. Prevents whitespace between items if you scroll very quickly. |\r",
      "\r",
      "\\* The `itemHeight` or `itemWidth` must be kept in sync with the height of each row rendered. If you are seeing extra whitespace or jitter when scrolling to the bottom of the list, ensure the `itemHeight` or `itemWidth` is the same height as the row.\r",
      "\r",
      "### Reactive list\r",
      "\r",
      "```typescript\r",
      "import { useVirtualList, useToggle } from '@vueuse/core'\r",
      "import { computed } from 'vue'\r",
      "\r",
      "const [isEven, toggle] = useToggle()\r",
      "const allItems = Array.from(Array(99999).keys())\r",
      "const filteredList = computed(() => allItems.filter(i => isEven.value ? i % 2 === 0 : i % 2 === 1))\r",
      "\r",
      "const { list, containerProps, wrapperProps } = useVirtualList(\r",
      "  filteredList,\r",
      "  {\r",
      "    itemHeight: 22,\r",
      "  },\r",
      ")\r",
      "```\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <p>Showing {{ isEven ? 'even' : 'odd' }} items</p>\r",
      "  <button @click=\"toggle\">Toggle Even/Odd</button>\r",
      "  <div v-bind=\"containerProps\" style=\"height: 300px\">\r",
      "    <div v-bind=\"wrapperProps\">\r",
      "      <div v-for=\"item in list\" :key=\"item.index\" style=\"height: 22px\">\r",
      "        Row: {{ item.data }}\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Horizontal list\r",
      "\r",
      "```typescript\r",
      "import { useVirtualList } from '@vueuse/core'\r",
      "\r",
      "const allItems = Array.from(Array(99999).keys())\r",
      "\r",
      "const { list, containerProps, wrapperProps } = useVirtualList(\r",
      "  allItems,\r",
      "  {\r",
      "    itemWidth: 200,\r",
      "  },\r",
      ")\r",
      "```\r",
      "\r",
      "```html\r",
      "<template>\r",
      "  <div v-bind=\"containerProps\" style=\"height: 300px\">\r",
      "    <div v-bind=\"wrapperProps\">\r",
      "      <div v-for=\"item in list\" :key=\"item.index\" style=\"width: 200px\">\r",
      "        Row: {{ item.data }}\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseVirtualList :list=\"list\" :options=\"options\" height=\"300px\">\r",
      "  <template #=\"props\">\r",
      "    <!-- you can get current item of list here -->\r",
      "    <div style=\"height: 22px\">Row {{ props.data }}</div>\r",
      "  </template>\r",
      "</UseVirtualList>\r",
      "```\r",
      "\r",
      "To scroll to a specific element, the component exposes `scrollTo(index: number) => void`.\r",
      "# Source TS",
      "```js",
      "import type { MaybeRef } from '@vueuse/shared'\r",
      "import type { ComputedRef, Ref, ShallowRef, StyleValue } from 'vue-demi'\r",
      "import { computed, ref, shallowRef, watch } from 'vue-demi'\r",
      "import { useElementSize } from '../useElementSize'\r",
      "\r",
      "type UseVirtualListItemSize = number | ((index: number) => number)\r",
      "\r",
      "export interface UseHorizontalVirtualListOptions extends UseVirtualListOptionsBase {\r",
      "\r",
      "  /**\r",
      "   * item width, accept a pixel value or a function that returns the height\r",
      "   *\r",
      "   * @default 0\r",
      "   */\r",
      "  itemWidth: UseVirtualListItemSize\r",
      "\r",
      "}\r",
      "\r",
      "export interface UseVerticalVirtualListOptions extends UseVirtualListOptionsBase {\r",
      "  /**\r",
      "   * item height, accept a pixel value or a function that returns the height\r",
      "   *\r",
      "   * @default 0\r",
      "   */\r",
      "  itemHeight: UseVirtualListItemSize\r",
      "}\r",
      "\r",
      "export interface UseVirtualListOptionsBase {\r",
      "  /**\r",
      "   * the extra buffer items outside of the view area\r",
      "   *\r",
      "   * @default 5\r",
      "   */\r",
      "  overscan?: number\r",
      "}\r",
      "\r",
      "export type UseVirtualListOptions = UseHorizontalVirtualListOptions | UseVerticalVirtualListOptions\r",
      "\r",
      "export interface UseVirtualListItem<T> {\r",
      "  data: T\r",
      "  index: number\r",
      "}\r",
      "\r",
      "export interface UseVirtualListReturn<T> {\r",
      "  list: Ref<UseVirtualListItem<T>[]>\r",
      "  scrollTo: (index: number) => void\r",
      "\r",
      "  containerProps: {\r",
      "    ref: Ref<HTMLElement | null>\r",
      "    onScroll: () => void\r",
      "    style: StyleValue\r",
      "  }\r",
      "  wrapperProps: ComputedRef<{\r",
      "    style: {\r",
      "      width: string\r",
      "      height: string\r",
      "      marginTop: string\r",
      "    } | {\r",
      "      width: string\r",
      "      height: string\r",
      "      marginLeft: string\r",
      "      display: string\r",
      "    }\r",
      "  }>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Please consider using [`vue-virtual-scroller`](https://github.com/Akryum/vue-virtual-scroller) if you are looking for more features.\r",
      " */\r",
      "export function useVirtualList<T = any>(list: MaybeRef<T[]>, options: UseVirtualListOptions): UseVirtualListReturn<T> {\r",
      "  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = 'itemHeight' in options\r",
      "    ? useVerticalVirtualList(options, list)\r",
      "    : useHorizontalVirtualList(options, list)\r",
      "\r",
      "  return {\r",
      "    list: currentList,\r",
      "    scrollTo,\r",
      "    containerProps: {\r",
      "      ref: containerRef,\r",
      "      onScroll: () => {\r",
      "        calculateRange()\r",
      "      },\r",
      "      style: containerStyle,\r",
      "    },\r",
      "    wrapperProps,\r",
      "  }\r",
      "}\r",
      "\r",
      "type UseVirtualListContainerRef = Ref<HTMLElement | null>\r",
      "\r",
      "interface UseVirtualElementSizes {\r",
      "  width: Ref<number>\r",
      "  height: Ref<number>\r",
      "}\r",
      "\r",
      "type UseVirtualListArray<T> = UseVirtualListItem<T>[]\r",
      "type UseVirtualListRefArray<T> = Ref<UseVirtualListArray<T>>\r",
      "\r",
      "type UseVirtualListSource<T> = Ref<T[]> | ShallowRef<T[]>\r",
      "\r",
      "interface UseVirtualListState { start: number; end: number }\r",
      "\r",
      "type RefState = Ref<UseVirtualListState>\r",
      "\r",
      "interface UseVirtualListResources<T> {\r",
      "  state: RefState\r",
      "  source: UseVirtualListSource<T>\r",
      "  currentList: UseVirtualListRefArray<T>\r",
      "  size: UseVirtualElementSizes\r",
      "  containerRef: UseVirtualListContainerRef\r",
      "}\r",
      "\r",
      "function useVirtualListResources<T>(list: MaybeRef<T[]>): UseVirtualListResources<T> {\r",
      "  const containerRef = ref<HTMLElement | null>(null)\r",
      "  const size = useElementSize(containerRef)\r",
      "\r",
      "  const currentList: Ref<UseVirtualListItem<T>[]> = ref([])\r",
      "  const source = shallowRef(list)\r",
      "\r",
      "  const state: Ref<{ start: number; end: number }> = ref({ start: 0, end: 10 })\r",
      "\r",
      "  return { state, source, currentList, size, containerRef }\r",
      "}\r",
      "\r",
      "function createGetViewCapacity<T>(state: UseVirtualListResources<T>['state'], source: UseVirtualListResources<T>['source'], itemSize: UseVirtualListItemSize) {\r",
      "  return (containerSize: number) => {\r",
      "    if (typeof itemSize === 'number')\r",
      "      return Math.ceil(containerSize / itemSize)\r",
      "\r",
      "    const { start = 0 } = state.value\r",
      "    let sum = 0\r",
      "    let capacity = 0\r",
      "    for (let i = start; i < source.value.length; i++) {\r",
      "      const size = itemSize(i)\r",
      "      sum += size\r",
      "      capacity = i\r",
      "      if (sum > containerSize)\r",
      "        break\r",
      "    }\r",
      "    return capacity - start\r",
      "  }\r",
      "}\r",
      "\r",
      "function createGetOffset<T>(source: UseVirtualListResources<T>['source'], itemSize: UseVirtualListItemSize) {\r",
      "  return (scrollDirection: number) => {\r",
      "    if (typeof itemSize === 'number')\r",
      "      return Math.floor(scrollDirection / itemSize) + 1\r",
      "\r",
      "    let sum = 0\r",
      "    let offset = 0\r",
      "\r",
      "    for (let i = 0; i < source.value.length; i++) {\r",
      "      const size = itemSize(i)\r",
      "      sum += size\r",
      "      if (sum >= scrollDirection) {\r",
      "        offset = i\r",
      "        break\r",
      "      }\r",
      "    }\r",
      "    return offset + 1\r",
      "  }\r",
      "}\r",
      "\r",
      "function createCalculateRange<T>(type: 'horizontal' | 'vertical', overscan: number, getOffset: ReturnType<typeof createGetOffset>,\r",
      "  getViewCapacity: ReturnType<typeof createGetViewCapacity>,\r",
      "  { containerRef, state, currentList, source }: UseVirtualListResources<T>) {\r",
      "  return () => {\r",
      "    const element = containerRef.value\r",
      "    if (element) {\r",
      "      const offset = getOffset(type === 'vertical' ? element.scrollTop : element.scrollLeft)\r",
      "      const viewCapacity = getViewCapacity(type === 'vertical' ? element.clientHeight : element.clientWidth)\r",
      "\r",
      "      const from = offset - overscan\r",
      "      const to = offset + viewCapacity + overscan\r",
      "      state.value = {\r",
      "        start: from < 0 ? 0 : from,\r",
      "        end: to > source.value.length\r",
      "          ? source.value.length\r",
      "          : to,\r",
      "      }\r",
      "      currentList.value = source.value\r",
      "        .slice(state.value.start, state.value.end)\r",
      "        .map((ele, index) => ({\r",
      "          data: ele,\r",
      "          index: index + state.value.start,\r",
      "        }))\r",
      "    }\r",
      "  }\r",
      "}\r",
      "\r",
      "function createGetDistance<T>(itemSize: UseVirtualListItemSize, source: UseVirtualListResources<T>['source']) {\r",
      "  return (index: number) => {\r",
      "    if (typeof itemSize === 'number') {\r",
      "      const size = index * itemSize\r",
      "      return size\r",
      "    }\r",
      "\r",
      "    const size = source.value\r",
      "      .slice(0, index)\r",
      "      .reduce((sum, _, i) => sum + itemSize(i), 0)\r",
      "\r",
      "    return size\r",
      "  }\r",
      "}\r",
      "\r",
      "function useWatchForSizes<T>(size: UseVirtualElementSizes, list: MaybeRef<T[]>, calculateRange: () => void) {\r",
      "  watch([size.width, size.height, list], () => {\r",
      "    calculateRange()\r",
      "  })\r",
      "}\r",
      "\r",
      "function createComputedTotalSize<T>(itemSize: UseVirtualListItemSize, source: UseVirtualListResources<T>['source']) {\r",
      "  return computed(() => {\r",
      "    if (typeof itemSize === 'number')\r",
      "      return source.value.length * itemSize\r",
      "\r",
      "    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0)\r",
      "  })\r",
      "}\r",
      "\r",
      "const scrollToDictionaryForElementScrollKey = {\r",
      "  horizontal: 'scrollLeft',\r",
      "  vertical: 'scrollTop',\r",
      "} as const\r",
      "\r",
      "function createScrollTo<T>(type: 'horizontal' | 'vertical', calculateRange: () => void, getDistance: ReturnType<typeof createGetDistance>, containerRef: UseVirtualListResources<T>['containerRef']) {\r",
      "  return (index: number) => {\r",
      "    if (containerRef.value) {\r",
      "      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index)\r",
      "      calculateRange()\r",
      "    }\r",
      "  }\r",
      "}\r",
      "\r",
      "function useHorizontalVirtualList<T>(options: UseHorizontalVirtualListOptions, list: MaybeRef<T[]>) {\r",
      "  const resources = useVirtualListResources(list)\r",
      "  const { state, source, currentList, size, containerRef } = resources\r",
      "  const containerStyle: StyleValue = { overflowX: 'auto' }\r",
      "\r",
      "  const { itemWidth, overscan = 5 } = options\r",
      "\r",
      "  const getViewCapacity = createGetViewCapacity(state, source, itemWidth)\r",
      "\r",
      "  const getOffset = createGetOffset(source, itemWidth)\r",
      "\r",
      "  const calculateRange = createCalculateRange('horizontal', overscan, getOffset, getViewCapacity, resources)\r",
      "\r",
      "  const getDistanceLeft = createGetDistance(itemWidth, source)\r",
      "\r",
      "  const offsetLeft = computed(() => getDistanceLeft(state.value.start))\r",
      "\r",
      "  const totalWidth = createComputedTotalSize(itemWidth, source)\r",
      "\r",
      "  useWatchForSizes(size, list, calculateRange)\r",
      "\r",
      "  const scrollTo = createScrollTo('horizontal', calculateRange, getDistanceLeft, containerRef)\r",
      "\r",
      "  const wrapperProps = computed(() => {\r",
      "    return {\r",
      "      style: {\r",
      "        height: '100%',\r",
      "        width: `${totalWidth.value - offsetLeft.value}px`,\r",
      "        marginLeft: `${offsetLeft.value}px`,\r",
      "        display: 'flex',\r",
      "      },\r",
      "    }\r",
      "  })\r",
      "\r",
      "  return {\r",
      "    scrollTo,\r",
      "    calculateRange,\r",
      "    wrapperProps,\r",
      "    containerStyle,\r",
      "    currentList,\r",
      "    containerRef,\r",
      "  }\r",
      "}\r",
      "\r",
      "function useVerticalVirtualList<T>(options: UseVerticalVirtualListOptions, list: MaybeRef<T[]>) {\r",
      "  const resources = useVirtualListResources(list)\r",
      "\r",
      "  const { state, source, currentList, size, containerRef } = resources\r",
      "\r",
      "  const containerStyle: StyleValue = { overflowY: 'auto' }\r",
      "\r",
      "  const { itemHeight, overscan = 5 } = options\r",
      "\r",
      "  const getViewCapacity = createGetViewCapacity(state, source, itemHeight)\r",
      "\r",
      "  const getOffset = createGetOffset(source, itemHeight)\r",
      "\r",
      "  const calculateRange = createCalculateRange('vertical', overscan, getOffset, getViewCapacity, resources)\r",
      "\r",
      "  const getDistanceTop = createGetDistance(itemHeight, source)\r",
      "\r",
      "  const offsetTop = computed(() => getDistanceTop(state.value.start))\r",
      "\r",
      "  const totalHeight = createComputedTotalSize(itemHeight, source)\r",
      "\r",
      "  useWatchForSizes(size, list, calculateRange)\r",
      "\r",
      "  const scrollTo = createScrollTo('vertical', calculateRange, getDistanceTop, containerRef)\r",
      "\r",
      "  const wrapperProps = computed(() => {\r",
      "    return {\r",
      "      style: {\r",
      "        width: '100%',\r",
      "        height: `${totalHeight.value - offsetTop.value}px`,\r",
      "        marginTop: `${offsetTop.value}px`,\r",
      "      },\r",
      "    }\r",
      "  })\r",
      "\r",
      "  return {\r",
      "    calculateRange,\r",
      "    scrollTo,\r",
      "    containerStyle,\r",
      "    wrapperProps,\r",
      "    currentList,\r",
      "    containerRef,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import type { Ref } from 'vue'\r",
      "import { computed, ref } from 'vue'\r",
      "import { useVirtualList } from '@vueuse/core'\r",
      "\r",
      "const index: Ref = ref()\r",
      "const search = ref('')\r",
      "\r",
      "const allItems = Array.from(Array(99999).keys())\r",
      "  .map(i => ({\r",
      "    height: i % 2 === 0 ? 42 : 84,\r",
      "    size: i % 2 === 0 ? 'small' : 'large',\r",
      "  }))\r",
      "\r",
      "const filteredItems = computed(() => {\r",
      "  return allItems.filter(i => i.size.startsWith(search.value.toLowerCase()))\r",
      "})\r",
      "\r",
      "const { list, containerProps, wrapperProps, scrollTo } = useVirtualList(\r",
      "  filteredItems,\r",
      "  {\r",
      "    itemHeight: i => (filteredItems.value[i].height + 8),\r",
      "    overscan: 10,\r",
      "  },\r",
      ")\r",
      "function handleScrollTo() {\r",
      "  scrollTo(index.value)\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div>\r",
      "      <div class=\"inline-block mr-4\">\r",
      "        Jump to index\r",
      "        <input v-model=\"index\" placeholder=\"Index\" type=\"number\">\r",
      "      </div>\r",
      "      <button type=\"button\" @click=\"handleScrollTo\">\r",
      "        Go\r",
      "      </button>\r",
      "    </div>\r",
      "    <div>\r",
      "      <div class=\"inline-block mr-4\">\r",
      "        Filter list by size\r",
      "        <input v-model=\"search\" placeholder=\"e.g. small, medium, large\" type=\"search\">\r",
      "      </div>\r",
      "    </div>\r",
      "    <div v-bind=\"containerProps\" class=\"h-300px overflow-auto p-2 bg-gray-500/5 rounded\">\r",
      "      <div v-bind=\"wrapperProps\">\r",
      "        <div\r",
      "          v-for=\"{ index, data } in list\"\r",
      "          :key=\"index\"\r",
      "          class=\"border border-$c-divider mb-2\"\r",
      "          :style=\"{\r",
      "            height: `${data.height}px`,\r",
      "            display: 'flex',\r",
      "            justifyContent: 'center',\r",
      "            alignItems: 'center',\r",
      "          }\"\r",
      "        >\r",
      "          Row {{ index }} <span opacity=\"70\" m=\"l-1\">({{ data.size }})</span>\r",
      "        </div>\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useWakeLock - vueuse": {
    "prefix": "hvue useWakeLock - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useWakeLock\r",
      "\r",
      "Reactive [Screen Wake Lock API](https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API). Provides a way to prevent devices from dimming or locking the screen when an application needs to keep running.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useWakeLock } from '@vueuse/core'\r",
      "\r",
      "const { isSupported, isActive, request, release } = useWakeLock()\r",
      "```\r",
      "\r",
      "If `request` is called,` isActive` will be **true**, and if `release` is called, or other tab is displayed, or the window is minimized,`isActive` will be **false**.\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useSupported } from '../useSupported'\r",
      "import type { ConfigurableDocument, ConfigurableNavigator } from '../_configurable'\r",
      "import { defaultDocument, defaultNavigator } from '../_configurable'\r",
      "\r",
      "type WakeLockType = 'screen'\r",
      "\r",
      "export interface WakeLockSentinel extends EventTarget {\r",
      "  type: WakeLockType\r",
      "  released: boolean\r",
      "  release: () => Promise<void>\r",
      "}\r",
      "\r",
      "type NavigatorWithWakeLock = Navigator & {\r",
      "  wakeLock: { request: (type: WakeLockType) => Promise<WakeLockSentinel> }\r",
      "}\r",
      "\r",
      "export type UseWakeLockOptions = ConfigurableNavigator & ConfigurableDocument\r",
      "\r",
      "/**\r",
      " * Reactive Screen Wake Lock API.\r",
      " *\r",
      " * @see https://vueuse.org/useWakeLock\r",
      " * @param options\r",
      " */\r",
      "export function useWakeLock(options: UseWakeLockOptions = {}) {\r",
      "  const {\r",
      "    navigator = defaultNavigator,\r",
      "    document = defaultDocument,\r",
      "  } = options\r",
      "  let wakeLock: WakeLockSentinel | null\r",
      "  const isSupported = useSupported(() => navigator && 'wakeLock' in navigator)\r",
      "  const isActive = ref(false)\r",
      "\r",
      "  async function onVisibilityChange() {\r",
      "    if (!isSupported.value || !wakeLock)\r",
      "      return\r",
      "\r",
      "    if (document && document.visibilityState === 'visible')\r",
      "      wakeLock = await (navigator as NavigatorWithWakeLock).wakeLock.request('screen')\r",
      "\r",
      "    isActive.value = !wakeLock.released\r",
      "  }\r",
      "\r",
      "  if (document)\r",
      "    useEventListener(document, 'visibilitychange', onVisibilityChange, { passive: true })\r",
      "\r",
      "  async function request(type: WakeLockType) {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "    wakeLock = await (navigator as NavigatorWithWakeLock).wakeLock.request(type)\r",
      "    isActive.value = !wakeLock.released\r",
      "  }\r",
      "\r",
      "  async function release() {\r",
      "    if (!isSupported.value || !wakeLock)\r",
      "      return\r",
      "    await wakeLock.release()\r",
      "    isActive.value = !wakeLock.released\r",
      "    wakeLock = null\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    isActive,\r",
      "    request,\r",
      "    release,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseWakeLockReturn = ReturnType<typeof useWakeLock>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, reactive } from 'vue'\r",
      "import { useWakeLock } from '@vueuse/core'\r",
      "\r",
      "const wakeLock = reactive(useWakeLock())\r",
      "const text = computed(() => wakeLock.isActive ? 'OFF' : 'ON')\r",
      "function onClick() {\r",
      "  return wakeLock.isActive ? wakeLock.release() : wakeLock.request('screen')\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    Is Supported: <BooleanDisplay :value=\"wakeLock.isSupported\" />\r",
      "  </div>\r",
      "  <div>\r",
      "    Is Active: <BooleanDisplay :value=\"wakeLock.isActive\" />\r",
      "  </div>\r",
      "  <button @click=\"onClick\">\r",
      "    {{ text }}\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useWebNotification - vueuse": {
    "prefix": "hvue useWebNotification - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useWebNotification\r",
      "\r",
      "Reactive [Notification](https://developer.mozilla.org/en-US/docs/Web/API/notification)\r",
      "\r",
      "The Web Notification interface of the Notifications API is used to configure and display desktop notifications to the user.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "const {\r",
      "  isSupported,\r",
      "  notification,\r",
      "  show,\r",
      "  close,\r",
      "  onClick,\r",
      "  onShow,\r",
      "  onError,\r",
      "  onClose,\r",
      "} = useWebNotification({\r",
      "  title: 'Hello, VueUse world!',\r",
      "  dir: 'auto',\r",
      "  lang: 'en',\r",
      "  renotify: true,\r",
      "  tag: 'test',\r",
      "})\r",
      "\r",
      "if (isSupported.value)\r",
      "  show()\r",
      "```\r",
      "\r",
      "This composable also utilizes the createEventHook utility from '@vueuse/shared`:\r",
      "\r",
      "```ts\r",
      "onClick((evt: Event) => {\r",
      "  // Do something with the notification on:click event...\r",
      "})\r",
      "\r",
      "onShow((evt: Event) => {\r",
      "  // Do something with the notification on:show event...\r",
      "})\r",
      "\r",
      "onError((evt: Event) => {\r",
      "  // Do something with the notification on:error event...\r",
      "})\r",
      "\r",
      "onClose((evt: Event) => {\r",
      "  // Do something with the notification on:close event...\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { createEventHook, tryOnMounted, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { EventHook } from '@vueuse/shared'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import { useSupported } from '../useSupported'\r",
      "\r",
      "export interface WebNotificationOptions {\r",
      "  /**\r",
      "   * The title read-only property of the Notification interface indicates\r",
      "   * the title of the notification\r",
      "   *\r",
      "   * @default ''\r",
      "   */\r",
      "  title?: string\r",
      "  /**\r",
      "   * The body string of the notification as specified in the constructor's\r",
      "   * options parameter.\r",
      "   *\r",
      "   * @default ''\r",
      "   */\r",
      "  body?: string\r",
      "  /**\r",
      "   * The text direction of the notification as specified in the constructor's\r",
      "   * options parameter.\r",
      "   *\r",
      "   * @default ''\r",
      "   */\r",
      "  dir?: 'auto' | 'ltr' | 'rtl'\r",
      "  /**\r",
      "   * The language code of the notification as specified in the constructor's\r",
      "   * options parameter.\r",
      "   *\r",
      "   * @default DOMString\r",
      "   */\r",
      "  lang?: string\r",
      "  /**\r",
      "   * The ID of the notification(if any) as specified in the constructor's options\r",
      "   * parameter.\r",
      "   *\r",
      "   * @default ''\r",
      "   */\r",
      "  tag?: string\r",
      "  /**\r",
      "   * The URL of the image used as an icon of the notification as specified\r",
      "   * in the constructor's options parameter.\r",
      "   *\r",
      "   * @default ''\r",
      "   */\r",
      "  icon?: string\r",
      "  /**\r",
      "   * Specifies whether the user should be notified after a new notification\r",
      "   * replaces an old one.\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  renotify?: boolean\r",
      "  /**\r",
      "   * A boolean value indicating that a notification should remain active until the\r",
      "   * user clicks or dismisses it, rather than closing automatically.\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  requireInteraction?: boolean\r",
      "  /**\r",
      "   * The silent read-only property of the Notification interface specifies\r",
      "   * whether the notification should be silent, i.e., no sounds or vibrations\r",
      "   * should be issued, regardless of the device settings.\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  silent?: boolean\r",
      "  /**\r",
      "   * Specifies a vibration pattern for devices with vibration hardware to emit.\r",
      "   * A vibration pattern, as specified in the Vibration API spec\r",
      "   *\r",
      "   * @see https://w3c.github.io/vibration/\r",
      "   */\r",
      "  vibrate?: number[]\r",
      "}\r",
      "\r",
      "export interface UseWebNotificationOptions extends WebNotificationOptions, ConfigurableWindow {\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive useWebNotification\r",
      " *\r",
      " * @see https://vueuse.org/useWebNotification\r",
      " * @see https://developer.mozilla.org/en-US/docs/Web/API/notification\r",
      " * @param title\r",
      " * @param defaultOptions of type WebNotificationOptions\r",
      " * @param methods of type WebNotificationMethods\r",
      " */\r",
      "export function useWebNotification(defaultOptions: UseWebNotificationOptions = {}) {\r",
      "  const {\r",
      "    window = defaultWindow,\r",
      "  } = defaultOptions\r",
      "\r",
      "  const isSupported = useSupported(() => !!window && 'Notification' in window)\r",
      "\r",
      "  const notification: Ref<Notification | null> = ref(null)\r",
      "\r",
      "  // Request permission to use web notifications:\r",
      "  const requestPermission = async () => {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "\r",
      "    if ('permission' in Notification && Notification.permission !== 'denied')\r",
      "      await Notification.requestPermission()\r",
      "  }\r",
      "\r",
      "  const { on: onClick, trigger: clickTrigger }: EventHook = createEventHook<Event>()\r",
      "  const { on: onShow, trigger: showTrigger }: EventHook = createEventHook<Event>()\r",
      "  const { on: onError, trigger: errorTrigger }: EventHook = createEventHook<Event>()\r",
      "  const { on: onClose, trigger: closeTrigger }: EventHook = createEventHook<Event>()\r",
      "\r",
      "  // Show notification method:\r",
      "  const show = async (overrides?: WebNotificationOptions) => {\r",
      "    if (!isSupported.value)\r",
      "      return\r",
      "\r",
      "    await requestPermission()\r",
      "    const options = Object.assign({}, defaultOptions, overrides)\r",
      "    notification.value = new Notification(options.title || '', options)\r",
      "\r",
      "    notification.value.onclick = clickTrigger\r",
      "    notification.value.onshow = showTrigger\r",
      "    notification.value.onerror = errorTrigger\r",
      "    notification.value.onclose = closeTrigger\r",
      "\r",
      "    return notification.value\r",
      "  }\r",
      "\r",
      "  // Close notification method:\r",
      "  const close = (): void => {\r",
      "    if (notification.value)\r",
      "      notification.value.close()\r",
      "    notification.value = null\r",
      "  }\r",
      "\r",
      "  // On mount, attempt to request permission:\r",
      "  tryOnMounted(async () => {\r",
      "    if (isSupported.value)\r",
      "      await requestPermission()\r",
      "  })\r",
      "\r",
      "  // Attempt cleanup of the notification:\r",
      "  tryOnScopeDispose(close)\r",
      "\r",
      "  // Use close() to remove a notification that is no longer relevant to to\r",
      "  // the user (e.g.the user already read the notification on the webpage).\r",
      "  // Most modern browsers dismiss notifications automatically after a few\r",
      "  // moments(around four seconds).\r",
      "  if (isSupported.value && window) {\r",
      "    const document = window.document\r",
      "    useEventListener(document, 'visibilitychange', (e: Event) => {\r",
      "      e.preventDefault()\r",
      "      if (document.visibilityState === 'visible') {\r",
      "        // The tab has become visible so clear the now-stale Notification:\r",
      "        close()\r",
      "      }\r",
      "    })\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    isSupported,\r",
      "    notification,\r",
      "    show,\r",
      "    close,\r",
      "    onClick,\r",
      "    onShow,\r",
      "    onError,\r",
      "    onClose,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseWebNotificationReturn = ReturnType<typeof useWebNotification>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useWebNotification } from '@vueuse/core'\r",
      "import type { UseWebNotificationOptions } from '@vueuse/core'\r",
      "\r",
      "const options: UseWebNotificationOptions = {\r",
      "  title: 'Hello, world from VueUse!',\r",
      "  dir: 'auto',\r",
      "  lang: 'en',\r",
      "  renotify: true,\r",
      "  tag: 'test',\r",
      "}\r",
      "\r",
      "const {\r",
      "  isSupported,\r",
      "  show,\r",
      "} = useWebNotification(options)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <p>\r",
      "      Supported: <BooleanDisplay :value=\"isSupported\" />\r",
      "    </p>\r",
      "  </div>\r",
      "\r",
      "  <div v-if=\"isSupported\">\r",
      "    <button @click=\"show()\">\r",
      "      Show Notification\r",
      "    </button>\r",
      "  </div>\r",
      "  <div v-else>\r",
      "    The Notification Web API is not supported in your browser.\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useWebWorkerFn - vueuse": {
    "prefix": "hvue useWebWorkerFn - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Browser\r",
      "---\r",
      "\r",
      "# useWebWorkerFn\r",
      "\r",
      "Run expensive functions without blocking the UI, using a simple syntax that makes use of Promise. A port of [alewin/useWorker](https://github.com/alewin/useWorker).\r",
      "\r",
      "## Usage\r",
      "\r",
      "### Basic example\r",
      "\r",
      "```js\r",
      "import { useWebWorkerFn } from '@vueuse/core'\r",
      "\r",
      "const { workerFn } = useWebWorkerFn(() => {\r",
      "  // some heavy works to do in web worker\r",
      "})\r",
      "```\r",
      "\r",
      "### With dependencies\r",
      "\r",
      "```ts {7-9}\r",
      "import { useWebWorkerFn } from '@vueuse/core'\r",
      "\r",
      "const { workerFn, workerStatus, workerTerminate } = useWebWorkerFn(\r",
      "  dates => dates.sort(dateFns.compareAsc),\r",
      "  {\r",
      "    timeout: 50000,\r",
      "    dependencies: [\r",
      "      'https://cdnjs.cloudflare.com/ajax/libs/date-fns/1.30.1/date_fns.js', // dateFns\r",
      "    ],\r",
      "  },\r",
      ")\r",
      "```\r",
      "\r",
      "## Web Worker\r",
      "\r",
      "Before you start using this function, we suggest you read the [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) documentation.\r",
      "\r",
      "## Credit\r",
      "\r",
      "This function is a Vue port of https://github.com/alewin/useWorker by Alessio Koci, with the help of [@Donskelle](https://github.com/Donskelle) to migration.\r",
      "# Source TS",
      "```js",
      "/* this implementation is a vue port of https://github.com/alewin/useWorker by Alessio Koci */\r",
      "\r",
      "import { ref } from 'vue-demi'\r",
      "import { tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "import createWorkerBlobUrl from './lib/createWorkerBlobUrl'\r",
      "\r",
      "export type WebWorkerStatus =\r",
      "  | 'PENDING'\r",
      "  | 'SUCCESS'\r",
      "  | 'RUNNING'\r",
      "  | 'ERROR'\r",
      "  | 'TIMEOUT_EXPIRED'\r",
      "\r",
      "export interface UseWebWorkerOptions extends ConfigurableWindow {\r",
      "  /**\r",
      "   * Number of milliseconds before killing the worker\r",
      "   *\r",
      "   * @default undefined\r",
      "   */\r",
      "  timeout?: number\r",
      "  /**\r",
      "   * An array that contains the external dependencies needed to run the worker\r",
      "   */\r",
      "  dependencies?: string[]\r",
      "}\r",
      "\r",
      "/**\r",
      " * Run expensive function without blocking the UI, using a simple syntax that makes use of Promise.\r",
      " *\r",
      " * @see https://vueuse.org/useWebWorkerFn\r",
      " * @param fn\r",
      " * @param options\r",
      " */\r",
      "export function useWebWorkerFn<T extends (...fnArgs: any[]) => any>(fn: T,\r",
      "  options: UseWebWorkerOptions = {}) {\r",
      "  const {\r",
      "    dependencies = [],\r",
      "    timeout,\r",
      "    window = defaultWindow,\r",
      "  } = options\r",
      "\r",
      "  const worker = ref<(Worker & { _url?: string }) | undefined>()\r",
      "  const workerStatus = ref<WebWorkerStatus>('PENDING')\r",
      "  const promise = ref<({ reject?: (result: ReturnType<T> | ErrorEvent) => void;resolve?: (result: ReturnType<T>) => void })>({})\r",
      "  const timeoutId = ref<number>()\r",
      "\r",
      "  const workerTerminate = (status: WebWorkerStatus = 'PENDING') => {\r",
      "    if (worker.value && worker.value._url && window) {\r",
      "      worker.value.terminate()\r",
      "      URL.revokeObjectURL(worker.value._url)\r",
      "      promise.value = {}\r",
      "      worker.value = undefined\r",
      "      window.clearTimeout(timeoutId.value)\r",
      "      workerStatus.value = status\r",
      "    }\r",
      "  }\r",
      "\r",
      "  workerTerminate()\r",
      "\r",
      "  tryOnScopeDispose(workerTerminate)\r",
      "\r",
      "  const generateWorker = () => {\r",
      "    const blobUrl = createWorkerBlobUrl(fn, dependencies)\r",
      "    const newWorker: Worker & { _url?: string } = new Worker(blobUrl)\r",
      "    newWorker._url = blobUrl\r",
      "\r",
      "    newWorker.onmessage = (e: MessageEvent) => {\r",
      "      const { resolve = () => {}, reject = () => {} } = promise.value\r",
      "      const [status, result] = e.data as [WebWorkerStatus, ReturnType<T>]\r",
      "\r",
      "      switch (status) {\r",
      "        case 'SUCCESS':\r",
      "          resolve(result)\r",
      "          workerTerminate(status)\r",
      "          break\r",
      "        default:\r",
      "          reject(result)\r",
      "          workerTerminate('ERROR')\r",
      "          break\r",
      "      }\r",
      "    }\r",
      "\r",
      "    newWorker.onerror = (e: ErrorEvent) => {\r",
      "      const { reject = () => {} } = promise.value\r",
      "\r",
      "      reject(e)\r",
      "      workerTerminate('ERROR')\r",
      "    }\r",
      "\r",
      "    if (timeout) {\r",
      "      timeoutId.value = setTimeout(\r",
      "        () => workerTerminate('TIMEOUT_EXPIRED'),\r",
      "        timeout,\r",
      "      ) as any\r",
      "    }\r",
      "    return newWorker\r",
      "  }\r",
      "\r",
      "  const callWorker = (...fnArgs: Parameters<T>) =>\r",
      "    new Promise<ReturnType<T>>((resolve, reject) => {\r",
      "      promise.value = {\r",
      "        resolve,\r",
      "        reject,\r",
      "      }\r",
      "      worker.value && worker.value.postMessage([[...fnArgs]])\r",
      "\r",
      "      workerStatus.value = 'RUNNING'\r",
      "    })\r",
      "\r",
      "  const workerFn = (...fnArgs: Parameters<T>) => {\r",
      "    if (workerStatus.value === 'RUNNING') {\r",
      "      console.error(\r",
      "        '[useWebWorkerFn] You can only run one instance of the worker at a time.',\r",
      "      )\r",
      "      /* eslint-disable-next-line prefer-promise-reject-errors */\r",
      "      return Promise.reject()\r",
      "    }\r",
      "\r",
      "    worker.value = generateWorker()\r",
      "    return callWorker(...fnArgs)\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    workerFn,\r",
      "    workerStatus,\r",
      "    workerTerminate,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseWebWorkerFnReturn = ReturnType<typeof useWebWorkerFn>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, nextTick, ref } from 'vue'\r",
      "import { useDateFormat, useTimestamp, useWebWorkerFn } from '@vueuse/core'\r",
      "\r",
      "function heavyTask() {\r",
      "  const randomNumber = () => Math.trunc(Math.random() * 5_000_00)\r",
      "  const numbers: number[] = Array(5_000_000).fill(undefined).map(randomNumber)\r",
      "  numbers.sort()\r",
      "  return numbers.slice(0, 5)\r",
      "}\r",
      "\r",
      "const { workerFn, workerStatus, workerTerminate } = useWebWorkerFn(heavyTask)\r",
      "const time = useTimestamp()\r",
      "const computedTime = useDateFormat(time, 'YYYY-MM-DD HH:mm:ss SSS')\r",
      "const running = computed(() => workerStatus.value === 'RUNNING')\r",
      "\r",
      "const data = ref<number[] | null>(null)\r",
      "const runner = ref('')\r",
      "\r",
      "async function baseSort() {\r",
      "  data.value = null\r",
      "  await nextTick()\r",
      "  data.value = heavyTask()\r",
      "  runner.value = 'Main'\r",
      "}\r",
      "\r",
      "async function workerSort() {\r",
      "  data.value = null\r",
      "  await nextTick()\r",
      "  data.value = await workerFn()\r",
      "  runner.value = 'Worker'\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>Current Time: <b>{{ computedTime }}</b></p>\r",
      "  <note class=\"mb-2\">\r",
      "    This is a demo showing sort for large array (5 million numbers) with or w/o WebWorker.<br>Clock stops when UI blocking happens.\r",
      "  </note>\r",
      "  <button @click=\"baseSort\">\r",
      "    Sort in Main Thread\r",
      "  </button>\r",
      "  <button v-if=\"!running\" @click=\"workerSort\">\r",
      "    Sort in Worker\r",
      "  </button>\r",
      "  <button v-else class=\"orange\" @click=\"workerTerminate('PENDING')\">\r",
      "    Terminate Worker\r",
      "  </button>\r",
      "  <p v-if=\"data\">\r",
      "    Thread: <strong>{{ runner }}</strong><br>\r",
      "    Result: <strong>{{ data }}</strong>\r",
      "  </p>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useWindowFocus - vueuse": {
    "prefix": "hvue useWindowFocus - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useWindowFocus\r",
      "\r",
      "Reactively track window focus with `window.onfocus` and `window.onblur` events.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useWindowFocus } from '@vueuse/core'\r",
      "\r",
      "const focused = useWindowFocus()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "```html\r",
      "<UseWindowFocus v-slot=\"{ focused }\">\r",
      "  Document Focus: {{ focused }}\r",
      "</UseWindowFocus>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Reactively track window focus with `window.onfocus` and `window.onblur`.\r",
      " *\r",
      " * @see https://vueuse.org/useWindowFocus\r",
      " * @param options\r",
      " */\r",
      "export function useWindowFocus({ window = defaultWindow }: ConfigurableWindow = {}): Ref<boolean> {\r",
      "  if (!window)\r",
      "    return ref(false)\r",
      "\r",
      "  const focused = ref(window.document.hasFocus())\r",
      "\r",
      "  useEventListener(window, 'blur', () => {\r",
      "    focused.value = false\r",
      "  })\r",
      "\r",
      "  useEventListener(window, 'focus', () => {\r",
      "    focused.value = true\r",
      "  })\r",
      "\r",
      "  return focused\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref, watch } from 'vue'\r",
      "import { useWindowFocus } from '@vueuse/core'\r",
      "\r",
      "const startMessage = 'üí° Click somewhere outside of the document to unfocus.'\r",
      "const message = ref(startMessage)\r",
      "const focused = useWindowFocus()\r",
      "\r",
      "watch(focused, (isFocused) => {\r",
      "  if (isFocused)\r",
      "    message.value = startMessage\r",
      "  else\r",
      "    message.value = '‚Ñπ Tab is unfocused'\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>{{ message }}</div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useWindowScroll - vueuse": {
    "prefix": "hvue useWindowScroll - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useWindowScroll\r",
      "\r",
      "Reactive window scroll\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useWindowScroll } from '@vueuse/core'\r",
      "\r",
      "const { x, y } = useWindowScroll()\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "/**\r",
      " * Reactive window scroll.\r",
      " *\r",
      " * @see https://vueuse.org/useWindowScroll\r",
      " * @param options\r",
      " */\r",
      "export function useWindowScroll({ window = defaultWindow }: ConfigurableWindow = {}) {\r",
      "  if (!window) {\r",
      "    return {\r",
      "      x: ref(0),\r",
      "      y: ref(0),\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const x = ref(window.scrollX)\r",
      "  const y = ref(window.scrollY)\r",
      "\r",
      "  useEventListener(\r",
      "    window,\r",
      "    'scroll',\r",
      "    () => {\r",
      "      x.value = window.scrollX\r",
      "      y.value = window.scrollY\r",
      "    },\r",
      "    {\r",
      "      capture: false,\r",
      "      passive: true,\r",
      "    },\r",
      "  )\r",
      "\r",
      "  return { x, y }\r",
      "}\r",
      "\r",
      "export type UseWindowScrollReturn = ReturnType<typeof useWindowScroll>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useWindowScroll } from '@vueuse/core'\r",
      "\r",
      "const { x, y } = useWindowScroll()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div>\r",
      "      See scroll values in the lower right corner of the screen.\r",
      "    </div>\r",
      "    <div class=\"scroller\" />\r",
      "    <div class=\"float\">\r",
      "      <note class=\"mb-2\">\r",
      "        Scroll value\r",
      "      </note>\r",
      "      x: {{ x }}<br>\r",
      "      y: {{ y }}\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      ".scroller {\r",
      "  position: absolute;\r",
      "  top: 100%;\r",
      "  left: 100%;\r",
      "  width: 10000px;\r",
      "  height: 10000px;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useWindowSize - vueuse": {
    "prefix": "hvue useWindowSize - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Elements\r",
      "---\r",
      "\r",
      "# useWindowSize\r",
      "\r",
      "Reactive window size\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useWindowSize } from '@vueuse/core'\r",
      "\r",
      "const { width, height } = useWindowSize()\r",
      "```\r",
      "\r",
      "## Component Usage\r",
      "\r",
      "```html\r",
      "<UseWindowSize v-slot=\"{ width, height }\">\r",
      "  Width: {{ width }}\r",
      "  Height: {{ height }}\r",
      "</UseWindowSize>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { tryOnMounted } from '@vueuse/shared'\r",
      "import { ref, watch } from 'vue-demi'\r",
      "import { useEventListener } from '../useEventListener'\r",
      "import { useMediaQuery } from '../useMediaQuery'\r",
      "import type { ConfigurableWindow } from '../_configurable'\r",
      "import { defaultWindow } from '../_configurable'\r",
      "\r",
      "export interface UseWindowSizeOptions extends ConfigurableWindow {\r",
      "  initialWidth?: number\r",
      "  initialHeight?: number\r",
      "  /**\r",
      "   * Listen to window `orientationchange` event\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  listenOrientation?: boolean\r",
      "\r",
      "  /**\r",
      "   * Whether the scrollbar should be included in the width and height\r",
      "   * @default true\r",
      "   */\r",
      "  includeScrollbar?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive window size.\r",
      " *\r",
      " * @see https://vueuse.org/useWindowSize\r",
      " * @param options\r",
      " */\r",
      "export function useWindowSize(options: UseWindowSizeOptions = {}) {\r",
      "  const {\r",
      "    window = defaultWindow,\r",
      "    initialWidth = Number.POSITIVE_INFINITY,\r",
      "    initialHeight = Number.POSITIVE_INFINITY,\r",
      "    listenOrientation = true,\r",
      "    includeScrollbar = true,\r",
      "  } = options\r",
      "\r",
      "  const width = ref(initialWidth)\r",
      "  const height = ref(initialHeight)\r",
      "\r",
      "  const update = () => {\r",
      "    if (window) {\r",
      "      if (includeScrollbar) {\r",
      "        width.value = window.innerWidth\r",
      "        height.value = window.innerHeight\r",
      "      }\r",
      "      else {\r",
      "        width.value = window.document.documentElement.clientWidth\r",
      "        height.value = window.document.documentElement.clientHeight\r",
      "      }\r",
      "    }\r",
      "  }\r",
      "\r",
      "  update()\r",
      "  tryOnMounted(update)\r",
      "  useEventListener('resize', update, { passive: true })\r",
      "\r",
      "  if (listenOrientation) {\r",
      "    const matches = useMediaQuery('(orientation: portrait)')\r",
      "    watch(matches, () => update())\r",
      "  }\r",
      "\r",
      "  return { width, height }\r",
      "}\r",
      "\r",
      "export type UseWindowSizeReturn = ReturnType<typeof useWindowSize>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useWindowSize } from '@vueuse/core'\r",
      "\r",
      "const { width, height } = useWindowSize()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>{{ width }} x {{ height }}</p>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue _template - vueuse": {
    "prefix": "hvue _template - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "# useCounter\r",
      "\r",
      "Basic counter with utility functions.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useCounter } from '@vueuse/core'\r",
      "\r",
      "const { count, inc, dec, set, reset } = useCounter()\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { ref } from 'vue-demi'\r",
      "\r",
      "export function useCounter(initialValue = 0) {\r",
      "  const count = ref(initialValue)\r",
      "\r",
      "  const inc = (delta = 1) => (count.value += delta)\r",
      "  const dec = (delta = 1) => (count.value -= delta)\r",
      "  const get = () => count.value\r",
      "  const set = (val: number) => (count.value = val)\r",
      "  const reset = (val = initialValue) => {\r",
      "    initialValue = val\r",
      "    return set(val)\r",
      "  }\r",
      "\r",
      "  return { count, inc, dec, get, set, reset }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useCounter } from '@vueuse/core'\r",
      "\r",
      "const { count, inc, dec } = useCounter()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <p>Count: {{ count }}</p>\r",
      "    <button @click=\"inc()\">\r",
      "      Increment\r",
      "    </button>\r",
      "    <button @click=\"dec()\">\r",
      "      Decrement\r",
      "    </button>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useAxios - vueuse": {
    "prefix": "hvue useAxios - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@Integrations'\r",
      "---\r",
      "\r",
      "# useAxios\r",
      "\r",
      "Wrapper for [`axios`](https://github.com/axios/axios).\r",
      "\r",
      "## Install\r",
      "\r",
      "```bash\r",
      "npm i axios\r",
      "```\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useAxios } from '@vueuse/integrations/useAxios'\r",
      "\r",
      "const { data, isFinished } = useAxios('/api/posts')\r",
      "```\r",
      "\r",
      "or use an instance of axios\r",
      "\r",
      "```ts\r",
      "import axios from 'axios'\r",
      "import { useAxios } from '@vueuse/integrations/useAxios'\r",
      "\r",
      "const instance = axios.create({\r",
      "  baseURL: '/api',\r",
      "})\r",
      "\r",
      "const { data, isFinished } = useAxios('/posts', instance)\r",
      "```\r",
      "\r",
      "use an instance of axios with config options\r",
      "\r",
      "```ts\r",
      "import axios from 'axios'\r",
      "import { useAxios } from '@vueuse/integrations/useAxios'\r",
      "\r",
      "const instance = axios.create({\r",
      "  baseURL: '/api',\r",
      "})\r",
      "\r",
      "const { data, isFinished } = useAxios('/posts', { method: 'POST' }, instance)\r",
      "```\r",
      "\r",
      "When you don't pass the `url`. The default value is `{immediate: false}`\r",
      "```ts\r",
      "import { useAxios } from '@vueuse/integrations/useAxios'\r",
      "\r",
      "const { execute } = useAxios()\r",
      "execute(url)\r",
      "```\r",
      "\r",
      "The `execute` function `url` here is optional, and `url2` will replace the `url1`. \r",
      "```ts\r",
      "import { useAxios } from '@vueuse/integrations/useAxios'\r",
      "\r",
      "const { execute } = useAxios(url1, {}, { immediate: false })\r",
      "execute(url2)\r",
      "```\r",
      "\r",
      "The `execute` function can accept `config` only. \r",
      "```ts\r",
      "import { useAxios } from '@vueuse/integrations/useAxios'\r",
      "\r",
      "const { execute } = useAxios(url1, { method: 'GET' }, { immediate: false })\r",
      "execute({ params: { key: 1 } })\r",
      "execute({ params: { key: 2 } })\r",
      "```\r",
      "\r",
      "The `execute` function resolves with a result of network request.\r",
      "```ts\r",
      "import { useAxios } from '@vueuse/integrations/useAxios'\r",
      "\r",
      "const { execute } = useAxios()\r",
      "const result = await execute(url)\r",
      "```\r",
      "\r",
      "use an instance of axios with `immediate` options\r",
      "\r",
      "```ts\r",
      "import axios from 'axios'\r",
      "import { useAxios } from '@vueuse/integrations/useAxios'\r",
      "\r",
      "const instance = axios.create({\r",
      "  baseURL: '/api',\r",
      "})\r",
      "\r",
      "const { data, isFinished } = useAxios('/posts', { method: 'POST' }, instance, {\r",
      "  immediate: false,\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref, ShallowRef } from 'vue-demi'\r",
      "import { ref, shallowRef } from 'vue-demi'\r",
      "import { noop, until } from '@vueuse/shared'\r",
      "import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelTokenSource } from 'axios'\r",
      "import axios, { AxiosError } from 'axios'\r",
      "\r",
      "export interface UseAxiosReturn<T, R = AxiosResponse<T>, _D = any> {\r",
      "  /**\r",
      "   * Axios Response\r",
      "   */\r",
      "  response: ShallowRef<R | undefined>\r",
      "\r",
      "  /**\r",
      "   * Axios response data\r",
      "   */\r",
      "  data: Ref<T | undefined>\r",
      "\r",
      "  /**\r",
      "   * Indicates if the request has finished\r",
      "   */\r",
      "  isFinished: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * Indicates if the request is currently loading\r",
      "   */\r",
      "  isLoading: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * Indicates if the request was canceled\r",
      "   */\r",
      "  isAborted: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * Any errors that may have occurred\r",
      "   */\r",
      "  error: ShallowRef<unknown | undefined>\r",
      "\r",
      "  /**\r",
      "   * Aborts the current request\r",
      "   */\r",
      "  abort: (message?: string | undefined) => void\r",
      "\r",
      "  /**\r",
      "   * Alias to `abort`\r",
      "   */\r",
      "  cancel: (message?: string | undefined) => void\r",
      "\r",
      "  /**\r",
      "   * Alias to `isAborted`\r",
      "   */\r",
      "  isCanceled: Ref<boolean>\r",
      "}\r",
      "export interface StrictUseAxiosReturn<T, R, D> extends UseAxiosReturn<T, R, D> {\r",
      "  /**\r",
      "   * Manually call the axios request\r",
      "   */\r",
      "  execute: (url?: string | AxiosRequestConfig<D>, config?: AxiosRequestConfig<D>) => Promise<StrictUseAxiosReturn<T, R, D>>\r",
      "}\r",
      "export interface EasyUseAxiosReturn<T, R, D> extends UseAxiosReturn<T, R, D> {\r",
      "  /**\r",
      "   * Manually call the axios request\r",
      "   */\r",
      "  execute: (url: string, config?: AxiosRequestConfig<D>) => Promise<EasyUseAxiosReturn<T, R, D>>\r",
      "}\r",
      "export interface UseAxiosOptions<T = any> {\r",
      "  /**\r",
      "   * Will automatically run axios request when `useAxios` is used\r",
      "   *\r",
      "   */\r",
      "  immediate?: boolean\r",
      "\r",
      "  /**\r",
      "   * Use shallowRef.\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  shallow?: boolean\r",
      "\r",
      "  /**\r",
      "   * Callback when error is caught.\r",
      "   */\r",
      "  onError?: (e: unknown) => void\r",
      "\r",
      "  /**\r",
      "   * Callback when success is caught.\r",
      "   */\r",
      "  onSuccess?: (data: T) => void\r",
      "\r",
      "  /**\r",
      "   * Initial data to use\r",
      "   */\r",
      "  initialData?: T\r",
      "\r",
      "  /**\r",
      "   * Sets the state to initialState before executing the promise.\r",
      "   */\r",
      "  resetOnExecute?: boolean\r",
      "\r",
      "  /**\r",
      "   * Callback when request is finished.\r",
      "   */\r",
      "  onFinish?: () => void\r",
      "}\r",
      "type OverallUseAxiosReturn<T, R, D> = StrictUseAxiosReturn<T, R, D> | EasyUseAxiosReturn<T, R, D>\r",
      "\r",
      "export function useAxios<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>, options?: UseAxiosOptions): StrictUseAxiosReturn<T, R, D> & Promise<StrictUseAxiosReturn<T, R, D>>\r",
      "export function useAxios<T = any, R = AxiosResponse<T>, D = any>(url: string, instance?: AxiosInstance, options?: UseAxiosOptions): StrictUseAxiosReturn<T, R, D> & Promise<StrictUseAxiosReturn<T, R, D>>\r",
      "export function useAxios<T = any, R = AxiosResponse<T>, D = any>(url: string, config: AxiosRequestConfig<D>, instance: AxiosInstance, options?: UseAxiosOptions): StrictUseAxiosReturn<T, R, D> & Promise<StrictUseAxiosReturn<T, R, D>>\r",
      "export function useAxios<T = any, R = AxiosResponse<T>, D = any>(config?: AxiosRequestConfig<D>): EasyUseAxiosReturn<T, R, D> & Promise<EasyUseAxiosReturn<T, R, D>>\r",
      "export function useAxios<T = any, R = AxiosResponse<T>, D = any>(instance?: AxiosInstance): EasyUseAxiosReturn<T, R, D> & Promise<EasyUseAxiosReturn<T, R, D>>\r",
      "export function useAxios<T = any, R = AxiosResponse<T>, D = any>(config?: AxiosRequestConfig<D>, instance?: AxiosInstance): EasyUseAxiosReturn<T, R, D> & Promise<EasyUseAxiosReturn<T, R, D>>\r",
      "\r",
      "/**\r",
      " * Wrapper for axios.\r",
      " *\r",
      " * @see https://vueuse.org/useAxios\r",
      " */\r",
      "export function useAxios<T = any, R = AxiosResponse<T>, D = any>(...args: any[]): OverallUseAxiosReturn<T, R, D> & Promise<OverallUseAxiosReturn<T, R, D>> {\r",
      "  const url: string | undefined = typeof args[0] === 'string' ? args[0] : undefined\r",
      "  const argsPlaceholder = typeof url === 'string' ? 1 : 0\r",
      "  let defaultConfig: AxiosRequestConfig<D> = {}\r",
      "  let instance: AxiosInstance = axios\r",
      "  let options: UseAxiosOptions<T> = {\r",
      "    immediate: !!argsPlaceholder,\r",
      "    shallow: true,\r",
      "  }\r",
      "\r",
      "  const isAxiosInstance = (val: any) => !!val?.request\r",
      "\r",
      "  if (args.length > 0 + argsPlaceholder) {\r",
      "    /**\r",
      "     * Unable to use `instanceof` here because of (https://github.com/axios/axios/issues/737)\r",
      "     * so instead we are checking if there is a `request` on the object to see if it is an\r",
      "     * axios instance\r",
      "     */\r",
      "    if (isAxiosInstance(args[0 + argsPlaceholder]))\r",
      "      instance = args[0 + argsPlaceholder]\r",
      "    else\r",
      "      defaultConfig = args[0 + argsPlaceholder]\r",
      "  }\r",
      "\r",
      "  if (args.length > 1 + argsPlaceholder) {\r",
      "    if (isAxiosInstance(args[1 + argsPlaceholder]))\r",
      "      instance = args[1 + argsPlaceholder]\r",
      "  }\r",
      "  if (\r",
      "    (args.length === 2 + argsPlaceholder && !isAxiosInstance(args[1 + argsPlaceholder]))\r",
      "    || args.length === 3 + argsPlaceholder\r",
      "  )\r",
      "    options = args[args.length - 1]\r",
      "\r",
      "  const {\r",
      "    initialData,\r",
      "    shallow,\r",
      "    onSuccess = noop,\r",
      "    onError = noop,\r",
      "    immediate,\r",
      "    resetOnExecute = false,\r",
      "  } = options\r",
      "\r",
      "  const response = shallowRef<AxiosResponse<T>>()\r",
      "  const data = (shallow ? shallowRef : ref)<T>(initialData!) as Ref<T>\r",
      "  const isFinished = ref(false)\r",
      "  const isLoading = ref(false)\r",
      "  const isAborted = ref(false)\r",
      "  const error = shallowRef<unknown>()\r",
      "\r",
      "  const cancelTokenSource = axios.CancelToken.source\r",
      "  let cancelToken: CancelTokenSource = cancelTokenSource()\r",
      "\r",
      "  const abort = (message?: string) => {\r",
      "    if (isFinished.value || !isLoading.value)\r",
      "      return\r",
      "\r",
      "    cancelToken.cancel(message)\r",
      "    cancelToken = cancelTokenSource()\r",
      "    isAborted.value = true\r",
      "    isLoading.value = false\r",
      "    isFinished.value = false\r",
      "  }\r",
      "\r",
      "  const loading = (loading: boolean) => {\r",
      "    isLoading.value = loading\r",
      "    isFinished.value = !loading\r",
      "  }\r",
      "\r",
      "  /**\r",
      "   * Reset data to initialData\r",
      "   */\r",
      "  const resetData = () => {\r",
      "    if (resetOnExecute)\r",
      "      data.value = initialData!\r",
      "  }\r",
      "\r",
      "  const waitUntilFinished = () =>\r",
      "    new Promise<OverallUseAxiosReturn<T, R, D>>((resolve, reject) => {\r",
      "      until(isFinished).toBe(true)\r",
      "        // eslint-disable-next-line @typescript-eslint/no-use-before-define\r",
      "        .then(() => error.value ? reject(error.value) : resolve(result))\r",
      "    })\r",
      "\r",
      "  const promise = {\r",
      "    then: (...args) => waitUntilFinished().then(...args),\r",
      "    catch: (...args) => waitUntilFinished().catch(...args),\r",
      "  } as Promise<OverallUseAxiosReturn<T, R, D>>\r",
      "\r",
      "  let executeCounter = 0\r",
      "  const execute: OverallUseAxiosReturn<T, R, D>['execute'] = (executeUrl: string | AxiosRequestConfig<D> | undefined = url, config: AxiosRequestConfig<D> = {}) => {\r",
      "    error.value = undefined\r",
      "    const _url = typeof executeUrl === 'string'\r",
      "      ? executeUrl\r",
      "      : url ?? config.url\r",
      "\r",
      "    if (_url === undefined) {\r",
      "      error.value = new AxiosError(AxiosError.ERR_INVALID_URL)\r",
      "      isFinished.value = true\r",
      "      return promise\r",
      "    }\r",
      "    resetData()\r",
      "    abort()\r",
      "    loading(true)\r",
      "\r",
      "    executeCounter += 1\r",
      "    const currentExecuteCounter = executeCounter\r",
      "\r",
      "    instance(_url, { ...defaultConfig, ...typeof executeUrl === 'object' ? executeUrl : config, cancelToken: cancelToken.token })\r",
      "      .then((r: any) => {\r",
      "        response.value = r\r",
      "        const result = r.data\r",
      "        data.value = result\r",
      "        onSuccess(result)\r",
      "      })\r",
      "      .catch((e: any) => {\r",
      "        error.value = e\r",
      "        onError(e)\r",
      "      })\r",
      "      .finally(() => {\r",
      "        options.onFinish?.()\r",
      "        if (currentExecuteCounter === executeCounter)\r",
      "          loading(false)\r",
      "      })\r",
      "    return promise\r",
      "  }\r",
      "\r",
      "  if (immediate && url)\r",
      "    (execute as StrictUseAxiosReturn<T, R, D>['execute'])()\r",
      "\r",
      "  const result = {\r",
      "    response,\r",
      "    data,\r",
      "    error,\r",
      "    isFinished,\r",
      "    isLoading,\r",
      "    cancel: abort,\r",
      "    isAborted,\r",
      "    isCanceled: isAborted,\r",
      "    abort,\r",
      "    execute,\r",
      "  } as OverallUseAxiosReturn<T, R, D>\r",
      "\r",
      "  return {\r",
      "    ...result,\r",
      "    ...promise,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { useAxios } from '.'\r",
      "\r",
      "const { data, isLoading, isFinished, execute } = useAxios(\r",
      "  'https://jsonplaceholder.typicode.com/todos/1',\r",
      ")\r",
      "const text = stringify(data)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"execute()\">\r",
      "    Execute\r",
      "  </button>\r",
      "  <note>Loading: {{ isLoading.toString() }}</note>\r",
      "  <note>Finished: {{ isFinished.toString() }}</note>\r",
      "  <pre lang=\"yaml\">{{ text }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useChangeCase - vueuse": {
    "prefix": "hvue useChangeCase - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@Integrations'\r",
      "---\r",
      "\r",
      "# useChangeCase\r",
      "\r",
      "Reactive wrapper for [`change-case`](https://github.com/blakeembrey/change-case).\r",
      "\r",
      "Subsitutes `useCamelCase`, `usePascalCase`, `useSnakeCase`, `useSentenceCase`, `useCapitalize`, etc.\r",
      "\r",
      "## Install\r",
      "\r",
      "```bash\r",
      "npm i change-case\r",
      "```\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useChangeCase } from '@vueuse/integrations/useChangeCase'\r",
      "\r",
      "// `changeCase` will be a computed\r",
      "const changeCase = useChangeCase('hello world', 'camelCase')\r",
      "changeCase.value // helloWorld\r",
      "changeCase.value = 'vue use'\r",
      "changeCase.value // vueUse\r",
      "// Supported methods\r",
      "// export {\r",
      "//   camelCase,\r",
      "//   capitalCase,\r",
      "//   constantCase,\r",
      "//   dotCase,\r",
      "//   headerCase,\r",
      "//   noCase,\r",
      "//   paramCase,\r",
      "//   pascalCase,\r",
      "//   pathCase,\r",
      "//   sentenceCase,\r",
      "//   snakeCase,\r",
      "// } from 'change-case'\r",
      "```\r",
      "\r",
      "or passing a `ref` to it, the returned `computed` will change along with the source ref's changes.\r",
      "\r",
      "Can be passed into `options` for customization\r",
      "\r",
      "```ts\r",
      "import { ref } from 'vue'\r",
      "import { useChangeCase } from '@vueuse/integrations/useChangeCase'\r",
      "\r",
      "const input = ref('helloWorld')\r",
      "const changeCase = useChangeCase(input, 'camelCase', {\r",
      "  delimiter: '-',\r",
      "})\r",
      "changeCase.value // hello-World\r",
      "ref.value = 'vue use'\r",
      "changeCase.value // vue-Use\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Options } from 'change-case'\r",
      "import type { MaybeRef, MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import type { ComputedRef, WritableComputedRef } from 'vue-demi'\r",
      "import { computed, ref } from 'vue-demi'\r",
      "import * as changeCase from './changeCase'\r",
      "\r",
      "export type ChangeCaseType = keyof typeof changeCase\r",
      "\r",
      "export function useChangeCase(input: MaybeRef<string>, type: ChangeCaseType, options?: Options | undefined): WritableComputedRef<string>\r",
      "export function useChangeCase(input: MaybeRefOrGetter<string>, type: ChangeCaseType, options?: Options | undefined): ComputedRef<string>\r",
      "\r",
      "/**\r",
      " * Reactive wrapper for `change-case`\r",
      " *\r",
      " * @see https://vueuse.org/useChangeCase\r",
      " */\r",
      "export function useChangeCase(input: MaybeRefOrGetter<string>, type: ChangeCaseType, options?: Options | undefined) {\r",
      "  if (typeof input === 'function')\r",
      "    return computed(() => changeCase[type](toValue(input), options))\r",
      "\r",
      "  const text = ref(input)\r",
      "  return computed<string>({\r",
      "    get() {\r",
      "      return changeCase[type](text.value, options)\r",
      "    },\r",
      "    set(value) {\r",
      "      text.value = value\r",
      "    },\r",
      "  })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { computed, ref, shallowReadonly } from 'vue-demi'\r",
      "import { useChangeCase } from '.'\r",
      "import type { ChangeCaseType } from '.'\r",
      "\r",
      "const arr: Array<ChangeCaseType> = [\r",
      "  'camelCase',\r",
      "  'capitalCase',\r",
      "  'constantCase',\r",
      "  'dotCase',\r",
      "  'headerCase',\r",
      "  'noCase',\r",
      "  'paramCase',\r",
      "  'pascalCase',\r",
      "  'pathCase',\r",
      "  'sentenceCase',\r",
      "  'snakeCase',\r",
      "]\r",
      "const types = shallowReadonly(arr)\r",
      "const input = ref('helloWorld')\r",
      "const type = ref<ChangeCaseType>(arr[0])\r",
      "const changeCase = computed(() => {\r",
      "  return useChangeCase(input, type.value)\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <label v-for=\"item in types\" :key=\"item\" class=\"radio\">\r",
      "      <input v-model=\"type\" :value=\"item\" type=\"radio\">\r",
      "      <span>{{ item }}</span>\r",
      "    </label>\r",
      "  </div>\r",
      "  <input v-model=\"input\" type=\"text\">\r",
      "  <pre lang=\"yaml\">{{ changeCase }}</pre>\r",
      "</template>\r",
      "\r",
      "<style scoped>\r",
      "</style>\r",
      "\r",
      "<style scoped lang=\"postcss\">\r",
      "input {\r",
      "  --tw-ring-offset-width: 1px !important;\r",
      "  --tw-ring-color: #8885 !important;\r",
      "  --tw-ring-offset-color: transparent !important;\r",
      "}\r",
      "\r",
      ".radio {\r",
      "  width: 7rem;\r",
      "  @apply ml-2;\r",
      "  @apply inline-flex items-center my-auto cursor-pointer select-none;\r",
      "}\r",
      "\r",
      ".radio input {\r",
      "  appearance: none;\r",
      "  padding: 0;\r",
      "  -webkit-print-color-adjust: exact;\r",
      "  color-adjust: exact;\r",
      "  display: inline-block;\r",
      "  vertical-align: middle;\r",
      "  background-origin: border-box;\r",
      "  user-select: none;\r",
      "  flex-shrink: 0;\r",
      "  height: 1rem;\r",
      "  width: 1rem;\r",
      "  @apply bg-gray-400/30;\r",
      "  @apply rounded-full h-4 w-4 select-none relative;\r",
      "  @apply mr-1;\r",
      "}\r",
      "\r",
      ".radio input:checked::after {\r",
      "  content: \"\";\r",
      "  @apply absolute inset-[3px] rounded-full bg-primary;\r",
      "}\r",
      "\r",
      ".checkbox span {\r",
      "  @apply ml-1.5 text-13px opacity-70;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useFocusTrap - vueuse": {
    "prefix": "hvue useFocusTrap - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@Integrations'\r",
      "---\r",
      "\r",
      "# useFocusTrap\r",
      "\r",
      "Reactive wrapper for [`focus-trap`](https://github.com/focus-trap/focus-trap).\r",
      "\r",
      "For more information on what options can be passed, see [`createOptions`](https://github.com/focus-trap/focus-trap#createfocustrapelement-createoptions) in the `focus-trap` documentation.\r",
      "\r",
      "## Install \r",
      "\r",
      "```bash\r",
      "npm i focus-trap\r",
      "```\r",
      "\r",
      "## Usage\r",
      "\r",
      "**Basic Usage**\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { ref } from 'vue'\r",
      "import { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\r",
      "\r",
      "const target = ref()\r",
      "const { hasFocus, activate, deactivate } = useFocusTrap(target)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <button @click=\"activate()\">Activate</button>\r",
      "    <div ref=\"target\">\r",
      "      <span>Has Focus: {{ hasFocus }}</span>\r",
      "      <input type=\"text\" />\r",
      "      <button @click=\"deactivate()\">Deactivate</button>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "**Automatically Focus**\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { ref } from 'vue'\r",
      "import { useFocusTrap } from '@vueuse/integrations/useFocusTrap'\r",
      "\r",
      "const target = ref()\r",
      "const { hasFocus, activate, deactivate } = useFocusTrap(target, { immediate: true })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div ref=\"target\">...</div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "**Conditional Rendering**\r",
      "\r",
      "This function can't properly activate focus on elements with conditional rendering using `v-if`. This is because they do not exist in the DOM at the time of the focus activation. To solve this you need to activate on the next tick.\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { nextTick, ref } from 'vue'\r",
      "\r",
      "const target = ref()\r",
      "const { activate, deactivate } = useFocusTrap(target, { immediate: true })\r",
      "\r",
      "const show = ref(false)  \r",
      "\r",
      "const reveal = async () => {\r",
      "  show.value = true\r",
      "  \r",
      "  await nextTick()\r",
      "  activate()\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div ref=\"target\" v-if=\"show\">...</div>\r",
      "    \r",
      "    <button @click=\"reveal\">Reveal and Focus</button>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "## Using Component\r",
      "\r",
      "With the `UseFocusTrap` component, Focus Trap will be activated automatically on mounting this component and deactivated on unmount.\r",
      "\r",
      "```html\r",
      "<script setup>\r",
      "import { ref } from 'vue'\r",
      "import { UseFocusTrap } from '@vueuse/integrations/useFocusTrap/component'\r",
      "\r",
      "const show = ref(false)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <UseFocusTrap v-if=\"show\" :options=\"{ immediate: true }\">\r",
      "    <div class=\"modal\">...</div>\r",
      "  </UseFocusTrap>\r",
      "</template>\r",
      "\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Fn, MaybeElementRef } from '@vueuse/core'\r",
      "import { tryOnScopeDispose, unrefElement } from '@vueuse/core'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref, watch } from 'vue-demi'\r",
      "import { createFocusTrap } from 'focus-trap'\r",
      "import type { ActivateOptions, DeactivateOptions, FocusTrap, Options } from 'focus-trap'\r",
      "\r",
      "export interface UseFocusTrapOptions extends Options {\r",
      "  /**\r",
      "   * Immediately activate the trap\r",
      "   */\r",
      "  immediate?: boolean\r",
      "}\r",
      "\r",
      "export interface UseFocusTrapReturn {\r",
      "  /**\r",
      "   * Indicates if the focus trap is currently active\r",
      "   */\r",
      "  hasFocus: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * Indicates if the focus trap is currently paused\r",
      "   */\r",
      "  isPaused: Ref<boolean>\r",
      "\r",
      "  /**\r",
      "   * Activate the focus trap\r",
      "   *\r",
      "   * @see https://github.com/focus-trap/focus-trap#trapactivateactivateoptions\r",
      "   * @param opts Activate focus trap options\r",
      "   */\r",
      "  activate: (opts?: ActivateOptions) => void\r",
      "\r",
      "  /**\r",
      "   * Deactivate the focus trap\r",
      "   *\r",
      "   * @see https://github.com/focus-trap/focus-trap#trapdeactivatedeactivateoptions\r",
      "   * @param opts Deactivate focus trap options\r",
      "   */\r",
      "  deactivate: (opts?: DeactivateOptions) => void\r",
      "\r",
      "  /**\r",
      "   * Pause the focus trap\r",
      "   *\r",
      "   * @see https://github.com/focus-trap/focus-trap#trappause\r",
      "   */\r",
      "  pause: Fn\r",
      "\r",
      "  /**\r",
      "   * Unpauses the focus trap\r",
      "   *\r",
      "   * @see https://github.com/focus-trap/focus-trap#trapunpause\r",
      "   */\r",
      "  unpause: Fn\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive focus-trap\r",
      " *\r",
      " * @see https://vueuse.org/useFocusTrap\r",
      " * @param target The target element to trap focus within\r",
      " * @param options Focus trap options\r",
      " * @param autoFocus Focus trap automatically when mounted\r",
      " */\r",
      "export function useFocusTrap(target: MaybeElementRef, options: UseFocusTrapOptions = {}): UseFocusTrapReturn {\r",
      "  let trap: undefined | FocusTrap\r",
      "\r",
      "  const { immediate, ...focusTrapOptions } = options\r",
      "  const hasFocus = ref(false)\r",
      "  const isPaused = ref(false)\r",
      "\r",
      "  const activate = (opts?: ActivateOptions) => trap && trap.activate(opts)\r",
      "  const deactivate = (opts?: DeactivateOptions) => trap && trap.deactivate(opts)\r",
      "\r",
      "  const pause = () => {\r",
      "    if (trap) {\r",
      "      trap.pause()\r",
      "      isPaused.value = true\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const unpause = () => {\r",
      "    if (trap) {\r",
      "      trap.unpause()\r",
      "      isPaused.value = false\r",
      "    }\r",
      "  }\r",
      "\r",
      "  watch(\r",
      "    () => unrefElement(target),\r",
      "    (el) => {\r",
      "      if (!el)\r",
      "        return\r",
      "\r",
      "      trap = createFocusTrap(el, {\r",
      "        ...focusTrapOptions,\r",
      "        onActivate() {\r",
      "          hasFocus.value = true\r",
      "\r",
      "          // Apply if user provided onActivate option\r",
      "          if (options.onActivate)\r",
      "            options.onActivate()\r",
      "        },\r",
      "        onDeactivate() {\r",
      "          hasFocus.value = false\r",
      "\r",
      "          // Apply if user provided onDeactivate option\r",
      "          if (options.onDeactivate)\r",
      "            options.onDeactivate()\r",
      "        },\r",
      "      })\r",
      "\r",
      "      // Focus if immediate is set to true\r",
      "      if (immediate)\r",
      "        activate()\r",
      "    }, { flush: 'post' })\r",
      "\r",
      "  // Cleanup on unmount\r",
      "  tryOnScopeDispose(() => deactivate())\r",
      "\r",
      "  return {\r",
      "    hasFocus,\r",
      "    isPaused,\r",
      "    activate,\r",
      "    deactivate,\r",
      "    pause,\r",
      "    unpause,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useFocusTrap } from '.'\r",
      "\r",
      "const target = ref()\r",
      "const { hasFocus, activate, deactivate } = useFocusTrap(target)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div class=\"flex flex-col items-center\">\r",
      "    <button @click=\"activate()\">\r",
      "      {{ hasFocus ? 'Focus is trapped within form' : 'Trap focus within form' }}\r",
      "    </button>\r",
      "    <input\r",
      "      type=\"text\"\r",
      "      :placeholder=\"hasFocus ? 'You can\\'t focus me' : 'You can focus me'\"\r",
      "    >\r",
      "\r",
      "    <div\r",
      "      ref=\"target\"\r",
      "      class=\"shadow-lg bg-gray-600 bg-opacity-10 dark:(bg-gray-400 bg-opacity-10) rounded max-w-96 mx-auto p-8\"\r",
      "    >\r",
      "      <div class=\"flex flex-row items-center text-6xl text-center justify-center\">\r",
      "        <twemoji:face-with-monocle v-if=\"hasFocus\" />\r",
      "        <twemoji:sleeping-face v-else />\r",
      "      </div>\r",
      "      <input type=\"text\" class=\"!w-12\" placeholder=\"Email\">\r",
      "      <input type=\"text\" placeholder=\"Nickname\">\r",
      "      <input placeholder=\"Password\" type=\"text\">\r",
      "      <div class=\"flex flex-row justify-center\">\r",
      "        <button @click=\"deactivate()\">\r",
      "          Free Focus\r",
      "        </button>\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useFuse - vueuse": {
    "prefix": "hvue useFuse - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@Integrations'\r",
      "---\r",
      "\r",
      "# useFuse\r",
      "\r",
      "Easily implement fuzzy search using a composable with [Fuse.js](https://github.com/krisk/fuse).\r",
      "\r",
      "From the Fuse.js website:\r",
      "\r",
      "> What is fuzzy searching?\r",
      "> \r",
      "> Generally speaking, fuzzy searching (more formally known as approximate string matching) is the technique of finding strings that are approximately equal to a given pattern (rather than exactly).\r",
      "\r",
      "## Install Fuse.js as a peer dependency\r",
      "\r",
      "### NPM\r",
      "\r",
      "```bash\r",
      "npm install fuse.js\r",
      "```\r",
      "\r",
      "### Yarn\r",
      "\r",
      "```bash\r",
      "yarn add fuse.js\r",
      "```\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { ref } from 'vue'\r",
      "import { useFuse } from '@vueuse/integrations/useFuse'\r",
      "\r",
      "const data = [\r",
      "  'John Smith',\r",
      "  'John Doe',\r",
      "  'Jane Doe',\r",
      "  'Phillip Green',\r",
      "  'Peter Brown',\r",
      "]\r",
      "\r",
      "const input = ref('Jhon D')\r",
      "\r",
      "const { results } = useFuse(input, data)\r",
      "\r",
      "/*\r",
      " * Results:\r",
      " *\r",
      " * { \"item\": \"John Doe\", \"index\": 1 }\r",
      " * { \"item\": \"John Smith\", \"index\": 0 }\r",
      " * { \"item\": \"Jane Doe\", \"index\": 2 }\r",
      " *\r",
      " */\r",
      "```\r",
      "# Source TS",
      "```js",
      "import Fuse from 'fuse.js'\r",
      "import type { ComputedRef } from 'vue-demi'\r",
      "import { computed, ref, watch } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "\r",
      "export type FuseOptions<T> = Fuse.IFuseOptions<T>\r",
      "export interface UseFuseOptions<T> {\r",
      "  fuseOptions?: FuseOptions<T>\r",
      "  resultLimit?: number\r",
      "  matchAllWhenSearchEmpty?: boolean\r",
      "}\r",
      "\r",
      "export function useFuse<DataItem>(\r",
      "  search: MaybeRefOrGetter<string>,\r",
      "  data: MaybeRefOrGetter<DataItem[]>,\r",
      "  options?: MaybeRefOrGetter<UseFuseOptions<DataItem>>,\r",
      ") {\r",
      "  const createFuse = () => {\r",
      "    return new Fuse(\r",
      "      toValue(data) ?? [],\r",
      "      toValue(options)?.fuseOptions,\r",
      "    )\r",
      "  }\r",
      "\r",
      "  const fuse = ref(createFuse())\r",
      "\r",
      "  watch(\r",
      "    () => toValue(options)?.fuseOptions,\r",
      "    () => { fuse.value = createFuse() },\r",
      "    { deep: true },\r",
      "  )\r",
      "\r",
      "  watch(\r",
      "    () => toValue(data),\r",
      "    (newData) => { fuse.value.setCollection(newData) },\r",
      "    { deep: true },\r",
      "  )\r",
      "\r",
      "  const results: ComputedRef<Fuse.FuseResult<DataItem>[]> = computed(() => {\r",
      "    const resolved = toValue(options)\r",
      "    // This will also be recomputed when `data` changes, as it causes a change\r",
      "    // to the Fuse instance, which is tracked here.\r",
      "    if (resolved?.matchAllWhenSearchEmpty && !toValue(search))\r",
      "      return toValue(data).map((item, index) => ({ item, refIndex: index }))\r",
      "\r",
      "    const limit = resolved?.resultLimit\r",
      "    return fuse.value.search(toValue(search), (limit ? { limit } : undefined))\r",
      "  })\r",
      "\r",
      "  return {\r",
      "    fuse,\r",
      "    results,\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseFuseReturn = ReturnType<typeof useFuse>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang='ts'>\r",
      "import { computed, ref, watch } from 'vue'\r",
      "import type { UseFuseOptions } from '.'\r",
      "import { useFuse } from '.'\r",
      "\r",
      "interface DataItem {\r",
      "  firstName: string\r",
      "  lastName: string\r",
      "}\r",
      "\r",
      "const data = ref<DataItem[]>([\r",
      "  {\r",
      "    firstName: 'Roslyn',\r",
      "    lastName: 'Mitchell',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Cathleen',\r",
      "    lastName: 'Matthews',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Carleton',\r",
      "    lastName: 'Harrelson',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Allen',\r",
      "    lastName: 'Moores',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'John',\r",
      "    lastName: 'Washington',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Brooke',\r",
      "    lastName: 'Colton',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Mary',\r",
      "    lastName: 'Rennold',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Nanny',\r",
      "    lastName: 'Field',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Chasity',\r",
      "    lastName: 'Michael',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Oakley',\r",
      "    lastName: 'Giles',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Johanna',\r",
      "    lastName: 'Shepherd',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Maybelle',\r",
      "    lastName: 'Wilkie',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Dawson',\r",
      "    lastName: 'Rowntree',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Manley',\r",
      "    lastName: 'Pond',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Lula',\r",
      "    lastName: 'Sawyer',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Hudson',\r",
      "    lastName: 'Hext',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Alden',\r",
      "    lastName: 'Senior',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Tory',\r",
      "    lastName: 'Hyland',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Constance',\r",
      "    lastName: 'Josephs',\r",
      "  },\r",
      "  {\r",
      "    firstName: 'Larry',\r",
      "    lastName: 'Kinsley',\r",
      "  },\r",
      "])\r",
      "\r",
      "const search = ref('')\r",
      "const filterBy = ref('both')\r",
      "const keys = computed(() => {\r",
      "  if (filterBy.value === 'first')\r",
      "    return ['firstName']\r",
      "  else if (filterBy.value === 'last')\r",
      "    return ['lastName']\r",
      "  else return ['firstName', 'lastName']\r",
      "})\r",
      "\r",
      "const resultLimit = ref<number | undefined>(undefined)\r",
      "const resultLimitString = ref<string>('')\r",
      "watch(resultLimitString, () => {\r",
      "  if (resultLimitString.value === '') {\r",
      "    resultLimit.value = undefined\r",
      "  }\r",
      "  else {\r",
      "    const float = Number.parseFloat(resultLimitString.value)\r",
      "    if (!Number.isNaN(float)) {\r",
      "      resultLimit.value = Math.round(float)\r",
      "      resultLimitString.value = resultLimit.value.toString()\r",
      "    }\r",
      "  }\r",
      "})\r",
      "\r",
      "const exactMatch = ref(false)\r",
      "const isCaseSensitive = ref(false)\r",
      "const matchAllWhenSearchEmpty = ref(true)\r",
      "\r",
      "const options = computed<UseFuseOptions<DataItem>>(() => ({\r",
      "  fuseOptions: {\r",
      "    keys: keys.value,\r",
      "    isCaseSensitive: isCaseSensitive.value,\r",
      "    threshold: exactMatch.value ? 0 : undefined,\r",
      "  },\r",
      "  resultLimit: resultLimit.value,\r",
      "  matchAllWhenSearchEmpty: matchAllWhenSearchEmpty.value,\r",
      "}))\r",
      "\r",
      "const { results } = useFuse(search, data, options)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <input v-model=\"search\" placeholder=\"Search for someone...\" type=\"text\" w-full>\r",
      "    <div flex flex-wrap>\r",
      "      <div bg=\"dark:(dark-300) light-700\" mr-2 border=\"1 light-900 dark:(dark-700)\" rounded relative flex items-center>\r",
      "        <i i-carbon-filter absolute left-2 opacity-70 />\r",
      "        <select v-model=\"filterBy\" px-8 bg-transparent>\r",
      "          <option bg=\"dark:(dark-300) light-700\" value=\"both\">\r",
      "            Full Name\r",
      "          </option>\r",
      "          <option bg=\"dark:(dark-300) light-700\" value=\"first\">\r",
      "            First Name\r",
      "          </option>\r",
      "          <option bg=\"dark:(dark-300) light-700\" value=\"last\">\r",
      "            Last Name\r",
      "          </option>\r",
      "        </select>\r",
      "        <i i-carbon-chevron-down absolute right-2 pointer-events-none opacity-70 />\r",
      "      </div>\r",
      "      <span flex-1 />\r",
      "      <div flex flex-row flex-wrap gap-x-4>\r",
      "        <label class=\"checkbox\">\r",
      "          <input v-model=\"exactMatch\" type=\"checkbox\">\r",
      "          <span>Exact Match</span>\r",
      "        </label>\r",
      "        <label class=\"checkbox\">\r",
      "          <input v-model=\"isCaseSensitive\" type=\"checkbox\">\r",
      "          <span>Case Sensitive</span>\r",
      "        </label>\r",
      "        <label class=\"checkbox\">\r",
      "          <input v-model=\"matchAllWhenSearchEmpty\" type=\"checkbox\">\r",
      "          <span>Match all when empty</span>\r",
      "        </label>\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "  <div mt-4>\r",
      "    <template v-if=\"results.length > 0\">\r",
      "      <div v-for=\"result in results\" :key=\"result.item.firstName + result.item.lastName\" py-2>\r",
      "        <div flex flex-col>\r",
      "          <span>\r",
      "            {{ result.item.firstName }} {{ result.item.lastName }}\r",
      "          </span>\r",
      "          <span text-sm opacity-50>\r",
      "            Score Index: {{ result.refIndex }}\r",
      "          </span>\r",
      "        </div>\r",
      "      </div>\r",
      "    </template>\r",
      "    <template v-else>\r",
      "      <div text-center pt-8 pb-4 opacity-80>\r",
      "        No Results Found\r",
      "      </div>\r",
      "    </template>\r",
      "  </div>\r",
      "</template>\r",
      "\r",
      "<style scoped lang=\"postcss\">\r",
      "input {\r",
      "  --tw-ring-offset-width: 1px !important;\r",
      "  --tw-ring-color: #8885 !important;\r",
      "  --tw-ring-offset-color: transparent !important;\r",
      "}\r",
      "\r",
      ".checkbox {\r",
      "  @apply inline-flex items-center my-auto cursor-pointer select-none;\r",
      "}\r",
      "\r",
      ".checkbox input {\r",
      "  appearance: none;\r",
      "  padding: 0;\r",
      "  -webkit-print-color-adjust: exact;\r",
      "  color-adjust: exact;\r",
      "  display: inline-block;\r",
      "  vertical-align: middle;\r",
      "  background-origin: border-box;\r",
      "  user-select: none;\r",
      "  flex-shrink: 0;\r",
      "  height: 1rem;\r",
      "  width: 1rem;\r",
      "  @apply bg-gray-400/30;\r",
      "  @apply rounded-md h-4 w-4 select-none;\r",
      "}\r",
      "\r",
      ".checkbox input:checked {\r",
      "  background-image: url(\"data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e\");\r",
      "}\r",
      "\r",
      ".checkbox span {\r",
      "  @apply ml-1.5 text-13px opacity-70;\r",
      "}\r",
      "</style>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useJwt - vueuse": {
    "prefix": "hvue useJwt - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@Integrations'\r",
      "---\r",
      "\r",
      "# useJwt\r",
      "\r",
      "Wrapper for [`jwt-decode`](https://github.com/auth0/jwt-decode).\r",
      "\r",
      "## Install\r",
      "\r",
      "```bash\r",
      "npm install jwt-decode\r",
      "```\r",
      "\r",
      "## Usage\r",
      "\r",
      "```typescript\r",
      "import { defineComponent } from 'vue'\r",
      "import { useJwt } from '@vueuse/integrations/useJwt'\r",
      "\r",
      "export default defineComponent({\r",
      "  setup() {\r",
      "    const encodedJwt = ref('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyfQ.L8i6g3PfcHlioHCCPURC9pmXT7gdJpx3kOoyAfNUwCc')\r",
      "    const { header, payload } = useJwt(encodedJwt)\r",
      "\r",
      "    return { header, payload }\r",
      "  },\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef } from 'vue-demi'\r",
      "import { computed } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { toValue } from '@vueuse/shared'\r",
      "import jwt_decode from 'jwt-decode'\r",
      "import type { JwtDecodeOptions, JwtHeader, JwtPayload } from 'jwt-decode'\r",
      "\r",
      "export interface UseJwtOptions<Fallback> {\r",
      "  /**\r",
      "   * Value returned when encounter error on decoding\r",
      "   *\r",
      "   * @default null\r",
      "   */\r",
      "  fallbackValue?: Fallback\r",
      "\r",
      "  /**\r",
      "   * Error callback for decoding\r",
      "   */\r",
      "  onError?: (error: unknown) => void\r",
      "}\r",
      "\r",
      "export interface UseJwtReturn<Payload, Header, Fallback> {\r",
      "  header: ComputedRef<Header | Fallback>\r",
      "  payload: ComputedRef<Payload | Fallback>\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive decoded jwt token.\r",
      " *\r",
      " * @see https://vueuse.org/useJwt\r",
      " * @param jwt\r",
      " */\r",
      "export function useJwt<\r",
      "  Payload extends object = JwtPayload,\r",
      "  Header extends object = JwtHeader,\r",
      "  Fallback = null,\r",
      ">(\r",
      "  encodedJwt: MaybeRefOrGetter<string>,\r",
      "  options: UseJwtOptions<Fallback> = {},\r",
      "): UseJwtReturn<Payload, Header, Fallback> {\r",
      "  const {\r",
      "    onError,\r",
      "    fallbackValue = null,\r",
      "  } = options\r",
      "\r",
      "  const decodeWithFallback = <T extends object>(encodedJwt: string, options?: JwtDecodeOptions): T | Fallback => {\r",
      "    try {\r",
      "      return jwt_decode<T>(encodedJwt, options)\r",
      "    }\r",
      "    catch (err) {\r",
      "      onError?.(err)\r",
      "      return fallbackValue as Fallback\r",
      "    }\r",
      "  }\r",
      "\r",
      "  const header = computed(() => decodeWithFallback<Header>(toValue(encodedJwt), { header: true }))\r",
      "  const payload = computed(() => decodeWithFallback<Payload>(toValue(encodedJwt)))\r",
      "\r",
      "  return {\r",
      "    header,\r",
      "    payload,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "\r",
      "import { useJwt } from '.'\r",
      "\r",
      "const encodedJwt = ref('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyfQ.L8i6g3PfcHlioHCCPURC9pmXT7gdJpx3kOoyAfNUwCc')\r",
      "const { header, payload } = useJwt(encodedJwt)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <p>Header</p>\r",
      "    <pre lang=\"json\" class=\"ml-2\">{{ JSON.stringify(header, null, 2) }}</pre>\r",
      "    <p>Payload</p>\r",
      "    <pre lang=\"json\" class=\"ml-2\">{{ JSON.stringify(payload, null, 2) }}</pre>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useNProgress - vueuse": {
    "prefix": "hvue useNProgress - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@Integrations'\r",
      "---\r",
      "\r",
      "# useNProgress\r",
      "\r",
      "Reactive wrapper for [`nprogress`](https://github.com/rstacruz/nprogress).\r",
      "\r",
      "## Install \r",
      "\r",
      "```bash\r",
      "npm i nprogress\r",
      "```\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js {6}\r",
      "import { useNProgress } from '@vueuse/integrations/useNProgress'\r",
      "\r",
      "const { isLoading } = useNProgress()\r",
      "\r",
      "function toggle() {\r",
      "  isLoading.value = !isLoading.value\r",
      "}\r",
      "```\r",
      "\r",
      "### Passing a progress percentage\r",
      "\r",
      "You can pass a percentage to indicate where the bar should start from.\r",
      "\r",
      "```js {3}\r",
      "import { useNProgress } from '@vueuse/integrations/useNProgress'\r",
      "\r",
      "const { progress } = useNProgress(0.5)\r",
      "\r",
      "function done() {\r",
      "  progress.value = 1.0\r",
      "}\r",
      "```\r",
      "\r",
      "> To change the progress percentage, set `progress.value = n`, where n is a number between 0..1.\r",
      "\r",
      "### Customization\r",
      "\r",
      "Just edit [nprogress.css](http://ricostacruz.com/nprogress/nprogress.css) to your liking. Tip: you probably only want to find and replace occurrences of #29d.\r",
      "\r",
      "You can [configure](https://github.com/rstacruz/nprogress#configuration) it by passing an object as a second parameter.\r",
      "\r",
      "```js {4}\r",
      "import { useNProgress } from '@vueuse/integrations/useNProgress'\r",
      "\r",
      "useNProgress(null, {\r",
      "  minimum: 0.1,\r",
      "  // ...\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { NProgressOptions } from 'nprogress'\r",
      "import nprogress from 'nprogress'\r",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { isClient, tryOnScopeDispose } from '@vueuse/shared'\r",
      "import { computed, ref, watchEffect } from 'vue-demi'\r",
      "\r",
      "export type UseNProgressOptions = Partial<NProgressOptions>\r",
      "\r",
      "/**\r",
      " * Reactive progress bar.\r",
      " *\r",
      " * @see https://vueuse.org/useNProgress\r",
      " */\r",
      "export function useNProgress(\r",
      "  currentProgress: MaybeRefOrGetter<number | null | undefined> = null,\r",
      "  options?: UseNProgressOptions,\r",
      ") {\r",
      "  const progress = ref(currentProgress)\r",
      "  const isLoading = computed({\r",
      "    set: load => load ? nprogress.start() : nprogress.done(),\r",
      "    get: () => typeof progress.value === 'number' && progress.value < 1,\r",
      "  })\r",
      "\r",
      "  if (options)\r",
      "    nprogress.configure(options)\r",
      "\r",
      "  const setProgress = nprogress.set\r",
      "  nprogress.set = (n: number) => {\r",
      "    progress.value = n\r",
      "    return setProgress.call(nprogress, n)\r",
      "  }\r",
      "\r",
      "  watchEffect(() => {\r",
      "    if (typeof progress.value === 'number' && isClient)\r",
      "      setProgress.call(nprogress, progress.value)\r",
      "  })\r",
      "\r",
      "  tryOnScopeDispose(nprogress.remove)\r",
      "\r",
      "  return {\r",
      "    isLoading,\r",
      "    progress,\r",
      "    start: nprogress.start,\r",
      "    done: nprogress.done,\r",
      "    remove: () => {\r",
      "      progress.value = null\r",
      "      nprogress.remove()\r",
      "    },\r",
      "  }\r",
      "}\r",
      "\r",
      "export type UseNProgressReturn = ReturnType<typeof useNProgress>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import './style.css'\r",
      "import { useNProgress } from '.'\r",
      "\r",
      "const { isLoading, progress } = useNProgress()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note class=\"mb-2\">\r",
      "    Click to change progress status\r",
      "  </note>\r",
      "  <button @click=\"isLoading = !isLoading\">\r",
      "    {{ !isLoading ? 'Start' : 'Stop' }}\r",
      "  </button>\r",
      "  <b v-if=\"isLoading\" class=\"ml-2\">{{ ((progress || 0) * 100).toFixed(0) }}%</b>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useQRCode - vueuse": {
    "prefix": "hvue useQRCode - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@Integrations'\r",
      "---\r",
      "\r",
      "# useQRCode\r",
      "\r",
      "Wrapper for [`qrcode`](https://github.com/soldair/node-qrcode).\r",
      "\r",
      "## Install \r",
      "\r",
      "```bash\r",
      "npm i qrcode\r",
      "```\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useQRCode } from '@vueuse/integrations/useQRCode'\r",
      "\r",
      "// `qrcode` will be a ref of data URL\r",
      "const qrcode = useQRCode('text-to-encode')\r",
      "```\r",
      "\r",
      "or passing a `ref` to it, the returned data URL ref will change along with the source ref's changes.\r",
      "\r",
      "```ts\r",
      "import { ref } from 'vue'\r",
      "import { useQRCode } from '@vueuse/integrations/useQRCode'\r",
      "\r",
      "const text = ref('text-to-encode')\r",
      "const qrcode = useQRCode(text)\r",
      "```\r",
      "\r",
      "```html\r",
      "<input v-model=\"text\" type=\"text\">\r",
      "<img :src=\"qrcode\" alt=\"QR Code\" />\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import { isClient, toRef } from '@vueuse/shared'\r",
      "import { ref, watch } from 'vue-demi'\r",
      "import QRCode from 'qrcode'\r",
      "\r",
      "/**\r",
      " * Wrapper for qrcode.\r",
      " *\r",
      " * @see https://vueuse.org/useQRCode\r",
      " * @param text\r",
      " * @param options\r",
      " */\r",
      "export function useQRCode(\r",
      "  text: MaybeRefOrGetter<string>,\r",
      "  options?: QRCode.QRCodeToDataURLOptions,\r",
      ") {\r",
      "  const src = toRef(text)\r",
      "  const result = ref('')\r",
      "\r",
      "  watch(\r",
      "    src,\r",
      "    async (value) => {\r",
      "      if (src.value && isClient)\r",
      "        result.value = await QRCode.toDataURL(value, options)\r",
      "    },\r",
      "    { immediate: true },\r",
      "  )\r",
      "\r",
      "  return result\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useQRCode } from '.'\r",
      "\r",
      "const text = ref('https://vueuse.org')\r",
      "const qrcode = useQRCode(text, {\r",
      "  errorCorrectionLevel: 'H',\r",
      "  margin: 3,\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note>\r",
      "    Text content for QRCode\r",
      "  </note>\r",
      "  <input v-model=\"text\" type=\"text\">\r",
      "  <img v-if=\"text\" class=\"mt-6 mb-2 rounded border\" :src=\"qrcode\" alt=\"QR Code\">\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useSortable - vueuse": {
    "prefix": "hvue useSortable - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@Integrations'\r",
      "---\r",
      "\r",
      "# useSortable\r",
      "\r",
      "Wrapper for [`sortable`](https://github.com/SortableJS/Sortable).\r",
      "\r",
      "For more information on what options can be passed, see [`Sortable.options`](https://github.com/SortableJS/Sortable#options) in the `Sortable` documentation.\r",
      "\r",
      "## Install \r",
      "\r",
      "```bash\r",
      "npm i sortablejs\r",
      "```\r",
      "\r",
      "## Usage\r",
      "\r",
      "### Use template ref\r",
      "\r",
      "```vue\r",
      "<script setup lang=\"ts\">\r",
      "import { useSortable } from '@vueuse/integrations/useSortable'\r",
      "import { ref } from 'vue'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "const list = ref([{ id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 3, name: 'c' }])\r",
      "\r",
      "useSortable(el, list)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\">\r",
      "    <div v-for=\"item in list\" :key=\"item.id\">\r",
      "      {{ item.name }}\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Use specifies the selector to operate on\r",
      "\r",
      "```vue\r",
      "<script setup lang=\"ts\">\r",
      "import { useSortable } from '@vueuse/integrations/useSortable'\r",
      "import { ref } from 'vue'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "const list = ref([{ id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 3, name: 'c' }])\r",
      "\r",
      "const animation = 200\r",
      "\r",
      "const { option } = useSortable(el, list, {\r",
      "  handle: '.handle',\r",
      "  // or option set\r",
      "  // animation\r",
      "})\r",
      "\r",
      "// You can use the option method to set and get the option of Sortable\r",
      "option('animation', animation)\r",
      "// option('animation') // 200\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div ref=\"el\">\r",
      "    <div v-for=\"item in list\" :key=\"item.id\">\r",
      "      <span>{{ item.name }}</span>\r",
      "      <span class=\"handle\">*</span>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Use a selector to get the root element\r",
      "\r",
      "```vue\r",
      "<script setup lang=\"ts\">\r",
      "import { useSortable } from '@vueuse/integrations/useSortable'\r",
      "import { ref } from 'vue'\r",
      "\r",
      "const list = ref([{ id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 3, name: 'c' }])\r",
      "\r",
      "useSortable('#dv', list)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div id=\"dv\">\r",
      "    <div v-for=\"item in list\" :key=\"item.id\">\r",
      "      <span>{{ item.name }}</span>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Tips\r",
      "\r",
      "If you want to handle the onUpdate yourself, you can pass in onUpdate parameters, and we also exposed a function to move the item position.\r",
      "\r",
      "```ts\r",
      "import { moveArrayElement } from '@vueuse/integrations/useSortable'\r",
      "\r",
      "useSortable(el, list, {\r",
      "  onUpdate: (e) => {\r",
      "    // do something\r",
      "    moveArrayElement(list.value, e.oldIndex, e.newIndex)\r",
      "    // nextTick required here as moveArrayElement is executed in a microtas\r",
      "    // so we need to wait until the next tick until that is finished.\r",
      "    nextTick(() => {\r",
      "      /* do something */\r",
      "    })\r",
      "  }\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { defaultDocument, toValue, tryOnMounted, tryOnScopeDispose, unrefElement } from '@vueuse/core'\r",
      "import type { ConfigurableDocument, MaybeRefOrGetter } from '@vueuse/core'\r",
      "import Sortable, { type Options } from 'sortablejs'\r",
      "import { nextTick } from 'vue-demi'\r",
      "\r",
      "export interface UseSortableReturn {\r",
      "  /**\r",
      "   * start sortable instance\r",
      "   */\r",
      "  start: () => void\r",
      "  /**\r",
      "   * destroy sortable instance\r",
      "   */\r",
      "  stop: () => void\r",
      "\r",
      "  /**\r",
      "   * Options getter/setter\r",
      "   * @param name a Sortable.Options property.\r",
      "   * @param value a value.\r",
      "   */\r",
      "  option<K extends keyof Sortable.Options>(name: K, value: Sortable.Options[K]): void\r",
      "  option<K extends keyof Sortable.Options>(name: K): Sortable.Options[K]\r",
      "}\r",
      "\r",
      "export type UseSortableOptions = Options & ConfigurableDocument\r",
      "\r",
      "export function useSortable<T>(selector: string, list: MaybeRefOrGetter<T[]>,\r",
      "  options?: UseSortableOptions): UseSortableReturn\r",
      "export function useSortable<T>(el: MaybeRefOrGetter<HTMLElement | null | undefined>, list: MaybeRefOrGetter<T[]>,\r",
      "  options?: UseSortableOptions): UseSortableReturn\r",
      "/**\r",
      " * Wrapper for sortablejs.\r",
      " * @param el\r",
      " * @param list\r",
      " * @param options\r",
      " */\r",
      "export function useSortable<T>(\r",
      "  el: MaybeRefOrGetter<HTMLElement | null | undefined> | string,\r",
      "  list: MaybeRefOrGetter<T[]>,\r",
      "  options: UseSortableOptions = {},\r",
      "): UseSortableReturn {\r",
      "  let sortable: Sortable\r",
      "\r",
      "  const { document = defaultDocument, ...resetOptions } = options\r",
      "\r",
      "  const defaultOptions: Options = {\r",
      "    onUpdate: (e) => {\r",
      "      moveArrayElement(list, e.oldIndex!, e.newIndex!)\r",
      "    },\r",
      "  }\r",
      "\r",
      "  const start = () => {\r",
      "    const target = (typeof el === 'string' ? document?.querySelector(el) : unrefElement(el))\r",
      "    if (!target)\r",
      "      return\r",
      "    sortable = new Sortable(target as HTMLElement, { ...defaultOptions, ...resetOptions })\r",
      "  }\r",
      "\r",
      "  const stop = () => sortable?.destroy()\r",
      "\r",
      "  const option = <K extends keyof Options>(name: K, value?: Options[K]) => {\r",
      "    if (value !== undefined)\r",
      "      sortable?.option(name, value)\r",
      "    else\r",
      "      return sortable?.option(name)\r",
      "  }\r",
      "\r",
      "  tryOnMounted(start)\r",
      "\r",
      "  tryOnScopeDispose(stop)\r",
      "\r",
      "  return { stop, start, option }\r",
      "}\r",
      "\r",
      "export function moveArrayElement<T>(\r",
      "  list: MaybeRefOrGetter<T[]>,\r",
      "  from: number,\r",
      "  to: number,\r",
      "): void {\r",
      "  const array = toValue(list)\r",
      "  if (to >= 0 && to < array.length) {\r",
      "    const element = array.splice(from, 1)[0]\r",
      "    nextTick(() => array.splice(to, 0, element))\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useSortable } from '.'\r",
      "\r",
      "const el = ref<HTMLElement | null>(null)\r",
      "const list = ref([{ id: 1, name: 'a' }, { id: 2, name: 'b' }, { id: 3, name: 'c' }])\r",
      "\r",
      "const { option } = useSortable(el, list, {\r",
      "  animation: 150,\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"option('animation', 150)\">\r",
      "    on animation\r",
      "  </button>\r",
      "  <button @click=\"option('animation', 0)\">\r",
      "    off animation\r",
      "  </button>\r",
      "  <div ref=\"el\" class=\"flex flex-col gap-2 p-4 w-300px h-200px m-auto bg-gray-500/5 rounded\">\r",
      "    <div v-for=\"item in list\" :key=\"item.id\" class=\"h20 bg-gray-500/5 rounded p-3\">\r",
      "      {{ item.name }}\r",
      "    </div>\r",
      "  </div>\r",
      "  <div class=\"text-center\">\r",
      "    {{ JSON.stringify(list) }}\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useClamp - vueuse": {
    "prefix": "hvue useClamp - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@Math'\r",
      "---\r",
      "\r",
      "# useClamp\r",
      "\r",
      "Reactively clamp a value between two other values.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useClamp } from '@vueuse/math'\r",
      "\r",
      "const min = ref(0)\r",
      "const max = ref(10)\r",
      "const value = useClamp(0, min, max)\r",
      "```\r",
      "\r",
      "You can also pass a `ref` and the returned `computed` will be updated when the source ref changes:\r",
      "\r",
      "```ts\r",
      "import { useClamp } from '@vueuse/math'\r",
      "\r",
      "const number = ref(0)\r",
      "const clamped = useClamp(number, 0, 10)\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef, Ref } from 'vue-demi'\r",
      "import { computed, isReadonly, ref } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter, ReadonlyRefOrGetter } from '@vueuse/shared'\r",
      "import { clamp, toValue } from '@vueuse/shared'\r",
      "\r",
      "export function useClamp(\r",
      "  value: ReadonlyRefOrGetter<number>,\r",
      "  min: MaybeRefOrGetter<number>,\r",
      "  max: MaybeRefOrGetter<number>,\r",
      "): ComputedRef<number>\r",
      "\r",
      "export function useClamp(\r",
      "  value: MaybeRefOrGetter<number>,\r",
      "  min: MaybeRefOrGetter<number>,\r",
      "  max: MaybeRefOrGetter<number>,\r",
      "): Ref<number>\r",
      "\r",
      "/**\r",
      " * Reactively clamp a value between two other values.\r",
      " *\r",
      " * @see https://vueuse.org/useClamp\r",
      " * @param value number\r",
      " * @param min\r",
      " * @param max\r",
      " */\r",
      "export function useClamp(value: MaybeRefOrGetter<number>, min: MaybeRefOrGetter<number>, max: MaybeRefOrGetter<number>) {\r",
      "  if (typeof value === 'function' || isReadonly(value))\r",
      "    return computed(() => clamp(toValue(value), toValue(min), toValue(max)))\r",
      "\r",
      "  const _value = ref(value)\r",
      "  return computed<number>({\r",
      "    get() {\r",
      "      return _value.value = clamp(_value.value, toValue(min), toValue(max))\r",
      "    },\r",
      "    set(value) {\r",
      "      _value.value = clamp(value, toValue(min), toValue(max))\r",
      "    },\r",
      "  })\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useClamp } from '@vueuse/math'\r",
      "\r",
      "const min = ref(0)\r",
      "const max = ref(10)\r",
      "\r",
      "const value = useClamp(0, min, max)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    min:\r",
      "    <input v-model=\"min\" type=\"number\">\r",
      "    max:\r",
      "    <input v-model=\"max\" type=\"number\">\r",
      "    value:{{ value }}\r",
      "    <div>\r",
      "      <button @click=\"value--\">\r",
      "        Decrement\r",
      "      </button>\r",
      "      <button @click=\"value++\">\r",
      "        Increment\r",
      "      </button>\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useProjection - vueuse": {
    "prefix": "hvue useProjection - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@Math'\r",
      "related: createGenericProjection\r",
      "---\r",
      "\r",
      "# useProjection\r",
      "\r",
      "Reactive numeric projection from one domain to another.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useProjection } from '@vueuse/math'\r",
      "\r",
      "const input = ref(0)\r",
      "const projected = useProjection(input, [0, 10], [0, 100])\r",
      "\r",
      "input.value = 5 // projected.value === 50\r",
      "input.value = 10 // projected.value === 100\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { MaybeRefOrGetter } from '@vueuse/shared'\r",
      "import type { ProjectorFunction } from '../createGenericProjection'\r",
      "import { createProjection } from '../createProjection'\r",
      "\r",
      "/**\r",
      " * Reactive numeric projection from one domain to another.\r",
      " *\r",
      " * @see https://vueuse.org/useProjection\r",
      " */\r",
      "export function useProjection(\r",
      "  input: MaybeRefOrGetter<number>,\r",
      "  fromDomain: MaybeRefOrGetter<readonly [number, number]>,\r",
      "  toDomain: MaybeRefOrGetter<readonly [number, number]>,\r",
      "  projector?: ProjectorFunction<number, number>,\r",
      ") {\r",
      "  return createProjection(fromDomain, toDomain, projector)(input)\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue-demi'\r",
      "import { useProjection } from '.'\r",
      "\r",
      "const from = ref<[number, number]>([0, 10])\r",
      "const to = ref<[number, number]>([10, 100])\r",
      "const input = ref(0)\r",
      "\r",
      "const output = useProjection(input, from, to)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <div>\r",
      "      Projection from [{{ from[0] }}, {{ from[1] }}] to [{{ to[0] }}, {{ to[1] }}]\r",
      "    </div>\r",
      "    <div>\r",
      "      <input id=\"input\" v-model.number=\"input\" type=\"range\" :min=\"from[0]\" :max=\"from[1]\">\r",
      "    </div>\r",
      "    <div>\r",
      "      Input: {{ input }}\r",
      "    </div>\r",
      "    <div>\r",
      "      Output: {{ output }}\r",
      "    </div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useSubject - vueuse": {
    "prefix": "hvue useSubject - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: '@RxJS'\r",
      "---\r",
      "\r",
      "# useSubject\r",
      "\r",
      "Bind an RxJS [`Subject`](https://rxjs.dev/guide/subject) to a `ref` and propagate value changes both ways.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useSubject } from '@vueuse/rxjs'\r",
      "import { Subject } from 'rxjs'\r",
      "\r",
      "const subject = new Subject()\r",
      "\r",
      "// setup()\r",
      "const subjectRef = useSubject(subject)\r",
      "```\r",
      "\r",
      "If you want to add custom error handling to a Subject that might error, you can supply an optional `onError` configuration. Without this, RxJS will treat any error in the supplied observable as an \"unhandled error\" and it will be thrown in a new call stack and reported to `window.onerror` (or `process.on('error')` if you happen to be in node).\r",
      "\r",
      "```ts\r",
      "import { useSubject } from '@vueuse/rxjs'\r",
      "import { Subject } from 'rxjs'\r",
      "\r",
      "const subject = new Subject()\r",
      "\r",
      "// setup()\r",
      "const subjectRef = useSubject(subject,\r",
      "  {\r",
      "    onError: (err) => {\r",
      "      console.log(err.message) // \"oops\"\r",
      "    },\r",
      "  },\r",
      ")\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Subject } from 'rxjs'\r",
      "import { BehaviorSubject } from 'rxjs'\r",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref, watch } from 'vue-demi'\r",
      "import { tryOnScopeDispose } from '@vueuse/shared'\r",
      "import type { UseObservableOptions } from '../useObservable'\r",
      "\r",
      "export interface UseSubjectOptions<I = undefined> extends Omit<UseObservableOptions<I>, 'initialValue'> {\r",
      "}\r",
      "\r",
      "export function useSubject<H>(subject: BehaviorSubject<H>, options?: UseSubjectOptions): Ref<H>\r",
      "export function useSubject<H>(subject: Subject<H>, options?: UseSubjectOptions): Ref<H | undefined>\r",
      "export function useSubject<H>(subject: Subject<H>, options?: UseSubjectOptions) {\r",
      "  const value = ref(\r",
      "    subject instanceof BehaviorSubject\r",
      "      ? subject.value\r",
      "      : undefined,\r",
      "  ) as typeof subject extends BehaviorSubject<H> ? Ref<H> : Ref<H | undefined>\r",
      "\r",
      "  const subscription = subject.subscribe({\r",
      "    next(val) { value.value = val },\r",
      "    error: options?.onError,\r",
      "  })\r",
      "\r",
      "  watch(value, (nextValue) => {\r",
      "    subject.next(nextValue)\r",
      "  })\r",
      "\r",
      "  tryOnScopeDispose(() => {\r",
      "    subscription.unsubscribe()\r",
      "  })\r",
      "\r",
      "  return value\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { tryOnScopeDispose } from '@vueuse/shared'\r",
      "import { BehaviorSubject } from 'rxjs'\r",
      "import { onMounted, watch } from 'vue'\r",
      "import { useSubject } from '.'\r",
      "\r",
      "const countSubject = new BehaviorSubject(0)\r",
      "const count = useSubject(countSubject)\r",
      "\r",
      "onMounted(() => {\r",
      "  watch(count, value => console.info('from watcher:', value))\r",
      "\r",
      "  const subscription = countSubject.subscribe(value => console.info('from subscriber: ', value))\r",
      "  tryOnScopeDispose(() => {\r",
      "    subscription.unsubscribe()\r",
      "  })\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"count++\">\r",
      "    count is: {{ count }}\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue computedEager - vueuse": {
    "prefix": "hvue computedEager - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Reactivity\r",
      "alias: eagerComputed\r",
      "---\r",
      "\r",
      "# computedEager\r",
      "\r",
      "Eager computed without lazy evaluation.\r",
      "\r",
      "Learn more at [Vue: When a computed property can be the wrong tool](https://dev.to/linusborg/vue-when-a-computed-property-can-be-the-wrong-tool-195j).\r",
      "\r",
      "- Use `computed()` when you have a complex calculation going on, which can actually profit from caching and lazy evaluation and should only be (re-)calculated if really necessary.\r",
      "- Use `computedEager()` when you have a simple operation, with a rarely changing return value ‚Äì often a boolean.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { computedEager } from '@vueuse/core'\r",
      "\r",
      "const todos = ref([])\r",
      "const hasOpenTodos = computedEager(() => !!todos.length)\r",
      "\r",
      "console.log(hasOpenTodos.value) // false\r",
      "toTodos.value.push({ title: 'Learn Vue' })\r",
      "console.log(hasOpenTodos.value) // true\r",
      "```\r",
      "# Source TS",
      "```js",
      "// ported from https://dev.to/linusborg/vue-when-a-computed-property-can-be-the-wrong-tool-195j\r",
      "// by @linusborg https://github.com/LinusBorg\r",
      "\r",
      "import type { Ref, WatchOptionsBase } from 'vue-demi'\r",
      "import { readonly, shallowRef, watchEffect } from 'vue-demi'\r",
      "\r",
      "export function computedEager<T>(fn: () => T, options?: WatchOptionsBase): Readonly<Ref<T>> {\r",
      "  const result = shallowRef()\r",
      "\r",
      "  watchEffect(() => {\r",
      "    result.value = fn()\r",
      "  }, {\r",
      "    ...options,\r",
      "    flush: options?.flush ?? 'sync',\r",
      "  })\r",
      "\r",
      "  return readonly(result)\r",
      "}\r",
      "\r",
      "// alias\r",
      "export { computedEager as eagerComputed }\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { count } from './demo/state'\r",
      "import LazyDemo from './demo/LazyDemo.vue'\r",
      "import EagerDemo from './demo/EagerDemo.vue'\r",
      "\r",
      "const lazyRenders = ref(0)\r",
      "const eagerRenders = ref(0)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div grid grid-cols-2>\r",
      "    <div>\r",
      "      <span text-primary font-bold>Lazy Computed</span>\r",
      "      <div font-mono>\r",
      "        <LazyDemo @update=\"lazyRenders++\" />\r",
      "        <div>\r",
      "          Renders: {{ lazyRenders }}\r",
      "        </div>\r",
      "      </div>\r",
      "    </div>\r",
      "    <div>\r",
      "      <span text-primary font-bold>Eager Computed</span>\r",
      "      <div font-mono>\r",
      "        <EagerDemo @update=\"eagerRenders++\" />\r",
      "        <div>Renders: {{ eagerRenders }}</div>\r",
      "      </div>\r",
      "    </div>\r",
      "  </div>\r",
      "\r",
      "  <div mt-4 font-mono>\r",
      "    Count: {{ count }}\r",
      "  </div>\r",
      "  <button secondary @click=\"count--\">\r",
      "    Decrement\r",
      "  </button>\r",
      "  <button @click=\"count++\">\r",
      "    Increment\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue createGlobalState - vueuse": {
    "prefix": "hvue createGlobalState - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: State\r",
      "related: createSharedComposable\r",
      "---\r",
      "\r",
      "# createGlobalState\r",
      "\r",
      "Keep states in the global scope to be reusable across Vue instances.\r",
      "\r",
      "## Usage\r",
      "\r",
      "### Without Persistence (Store in Memory)\r",
      "\r",
      "```js\r",
      "// store.js\r",
      "import { ref } from 'vue'\r",
      "import { createGlobalState } from '@vueuse/core'\r",
      "\r",
      "export const useGlobalState = createGlobalState(\r",
      "  () => {\r",
      "    const count = ref(0)\r",
      "    return { count }\r",
      "  }\r",
      ")\r",
      "```\r",
      "\r",
      "A bigger example:\r",
      "\r",
      "```js\r",
      "// store.js\r",
      "import { computed, ref } from 'vue'\r",
      "import { createGlobalState } from '@vueuse/core'\r",
      "\r",
      "export const useGlobalState = createGlobalState(\r",
      "  () => {\r",
      "    // state\r",
      "    const count = ref(0)\r",
      "\r",
      "    // getters\r",
      "    const doubleCount = computed(() => count.value * 2)\r",
      "\r",
      "    // actions\r",
      "    function increment() {\r",
      "      count.value++\r",
      "    }\r",
      "\r",
      "    return { count, doubleCount, increment }\r",
      "  }\r",
      ")\r",
      "```\r",
      "\r",
      "\r",
      "### With Persistence\r",
      "\r",
      "Store in `localStorage` with `useStorage()`:\r",
      "\r",
      "```js\r",
      "// store.js\r",
      "import { createGlobalState, useStorage } from '@vueuse/core'\r",
      "\r",
      "export const useGlobalState = createGlobalState(\r",
      "  () => useStorage('vueuse-local-storage', 'initialValue'),\r",
      ")\r",
      "```\r",
      "\r",
      "```js\r",
      "// component.js\r",
      "import { useGlobalState } from './store'\r",
      "\r",
      "export default defineComponent({\r",
      "  setup() {\r",
      "    const state = useGlobalState()\r",
      "    return { state }\r",
      "  },\r",
      "})\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { effectScope } from 'vue-demi'\r",
      "import type { AnyFn } from '../utils'\r",
      "\r",
      "/**\r",
      " * Keep states in the global scope to be reusable across Vue instances.\r",
      " *\r",
      " * @see https://vueuse.org/createGlobalState\r",
      " * @param stateFactory A factory function to create the state\r",
      " */\r",
      "export function createGlobalState<Fn extends AnyFn>(\r",
      "  stateFactory: Fn,\r",
      "): Fn {\r",
      "  let initialized = false\r",
      "  let state: any\r",
      "  const scope = effectScope(true)\r",
      "\r",
      "  return ((...args: any[]) => {\r",
      "    if (!initialized) {\r",
      "      state = scope.run(() => stateFactory(...args))!\r",
      "      initialized = true\r",
      "    }\r",
      "    return state\r",
      "  }) as Fn\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { stringify } from '@vueuse/docs-utils'\r",
      "import { createGlobalState, useStorage } from '@vueuse/core'\r",
      "\r",
      "const useState = createGlobalState(() =>\r",
      "  useStorage('vue-use-locale-storage', {\r",
      "    name: 'Banana',\r",
      "    color: 'Yellow',\r",
      "    size: 'Medium',\r",
      "  }),\r",
      ")\r",
      "\r",
      "const state = useState()\r",
      "const text = stringify(state)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <input v-model=\"state.name\" type=\"text\">\r",
      "    <input v-model=\"state.color\" type=\"text\">\r",
      "    <input v-model=\"state.size\" type=\"text\">\r",
      "\r",
      "    <pre lang=\"yaml\">{{ text }}</pre>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue createInjectionState - vueuse": {
    "prefix": "hvue createInjectionState - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: State\r",
      "---\r",
      "\r",
      "# createInjectionState\r",
      "\r",
      "Create global state that can be injected into components.\r",
      "\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "// useCounterStore.ts\r",
      "import { computed, ref } from 'vue'\r",
      "import { createInjectionState } from '@vueuse/shared'\r",
      "\r",
      "const [useProvideCounterStore, useCounterStore] = createInjectionState((initialValue: number) => {\r",
      "  // state\r",
      "  const count = ref(initialValue)\r",
      "\r",
      "  // getters\r",
      "  const double = computed(() => count.value * 2)\r",
      "\r",
      "  // actions\r",
      "  function increment() {\r",
      "    count.value++\r",
      "  }\r",
      "\r",
      "  return { count, double, increment }\r",
      "})\r",
      "\r",
      "export { useProvideCounterStore }\r",
      "// If you want to hide `useCounterStore` and wrap it in default value logic or throw error logic, please don't export `useCounterStore`\r",
      "export { useCounterStore }\r",
      "\r",
      "export function useCounterStoreWithDefaultValue() {\r",
      "  return useCounterStore() ?? {\r",
      "    count: ref(0),\r",
      "    double: ref(0),\r",
      "    increment: () => {},\r",
      "  }\r",
      "}\r",
      "\r",
      "export function useCounterStoreOrThrow() {\r",
      "  const counterStore = useCounterStore()\r",
      "  if (counterStore == null)\r",
      "    throw new Error('Please call `useProvideCounterStore` on the appropriate parent component')\r",
      "  return counterStore\r",
      "}\r",
      "```\r",
      "\r",
      "```vue\r",
      "<!-- RootComponent.vue -->\r",
      "<script setup lang=\"ts\">\r",
      "import { useProvideCounterStore } from './useCounterStore'\r",
      "\r",
      "useProvideCounterStore(0)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <slot />\r",
      "  </div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "```vue\r",
      "<!-- CountComponent.vue -->\r",
      "<script setup lang=\"ts\">\r",
      "import { useCounterStore } from './useCounterStore'\r",
      "\r",
      "// use non-null assertion operator to ignore the case that store is not provided.\r",
      "const { count, double } = useCounterStore()!\r",
      "// if you want to allow component to working without providing store, you can use follow code instead:\r",
      "// const { count, double } = useCounterStore() ?? { count: ref(0), double: ref(0) }\r",
      "// also, you can use another hook to provide default value\r",
      "// const { count, double } = useCounterStoreWithDefaultValue()\r",
      "// or throw error\r",
      "// const { count, double } = useCounterStoreOrThrow()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <ul>\r",
      "    <li>\r",
      "      count: {{ count }}\r",
      "    </li>\r",
      "    <li>\r",
      "      double: {{ double }}\r",
      "    </li>\r",
      "  </ul>\r",
      "</template>\r",
      "```\r",
      "\r",
      "```vue\r",
      "<!-- ButtonComponent.vue -->\r",
      "<script setup lang=\"ts\">\r",
      "import { useCounterStore } from './useCounterStore'\r",
      "\r",
      "// use non-null assertion operator to ignore the case that store is not provided.\r",
      "const { increment } = useCounterStore()!\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"increment\">\r",
      "    +\r",
      "  </button>\r",
      "</template>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { type InjectionKey, inject, provide } from 'vue-demi'\r",
      "\r",
      "/**\r",
      " * Create global state that can be injected into components.\r",
      " *\r",
      " * @see https://vueuse.org/createInjectionState\r",
      " *\r",
      " */\r",
      "export function createInjectionState<Arguments extends Array<any>, Return>(\r",
      "  composable: (...args: Arguments) => Return,\r",
      "): readonly [useProvidingState: (...args: Arguments) => Return, useInjectedState: () => Return | undefined] {\r",
      "  const key: string | InjectionKey<Return> = Symbol('InjectionState')\r",
      "  const useProvidingState = (...args: Arguments) => {\r",
      "    const state = composable(...args)\r",
      "    provide(key, state)\r",
      "    return state\r",
      "  }\r",
      "  const useInjectedState = () => inject(key)\r",
      "  return [useProvidingState, useInjectedState]\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import RootComponent from './demo/RootComponent.vue'\r",
      "import CountComponent from './demo/CountComponent.vue'\r",
      "import ButtonComponent from './demo/ButtonComponent.vue'\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <RootComponent>\r",
      "      <ButtonComponent />\r",
      "      <CountComponent />\r",
      "    </RootComponent>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue refAutoReset - vueuse": {
    "prefix": "hvue refAutoReset - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Reactivity\r",
      "alias: autoResetRef\r",
      "---\r",
      "\r",
      "# refAutoReset\r",
      "\r",
      "A ref which will be reset to the default value after some time.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { refAutoReset } from '@vueuse/core'\r",
      "\r",
      "const message = refAutoReset('default message', 1000)\r",
      "\r",
      "function setMessage() {\r",
      "  // here the value will change to 'message has set' but after 1000ms, it will change to 'default message'\r",
      "  message.value = 'message has set'\r",
      "}\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { customRef } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '../utils'\r",
      "import { toValue } from '../toValue'\r",
      "import { tryOnScopeDispose } from '../tryOnScopeDispose'\r",
      "\r",
      "/**\r",
      " * Create a ref which will be reset to the default value after some time.\r",
      " *\r",
      " * @see https://vueuse.org/refAutoReset\r",
      " * @param defaultValue The value which will be set.\r",
      " * @param afterMs      A zero-or-greater delay in milliseconds.\r",
      " */\r",
      "export function refAutoReset<T>(defaultValue: T, afterMs: MaybeRefOrGetter<number> = 10000): Ref<T> {\r",
      "  return customRef<T>((track, trigger) => {\r",
      "    let value: T = defaultValue\r",
      "    let timer: any\r",
      "\r",
      "    const resetAfter = () =>\r",
      "      setTimeout(() => {\r",
      "        value = defaultValue\r",
      "        trigger()\r",
      "      }, toValue(afterMs))\r",
      "\r",
      "    tryOnScopeDispose(() => {\r",
      "      clearTimeout(timer)\r",
      "    })\r",
      "\r",
      "    return {\r",
      "      get() {\r",
      "        track()\r",
      "        return value\r",
      "      },\r",
      "      set(newValue) {\r",
      "        value = newValue\r",
      "        trigger()\r",
      "\r",
      "        clearTimeout(timer)\r",
      "        timer = resetAfter()\r",
      "      },\r",
      "    }\r",
      "  })\r",
      "}\r",
      "\r",
      "// alias\r",
      "export { refAutoReset as autoResetRef }\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { refAutoReset } from '@vueuse/core'\r",
      "\r",
      "const message = refAutoReset('Default message', 1000)\r",
      "\r",
      "function setMessage() {\r",
      "  message.value = 'Changed'\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <button @click=\"setMessage()\">\r",
      "      Change Message\r",
      "    </button>\r",
      "    <p>\r",
      "      {{ message }}\r",
      "    </p>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue refDebounced - vueuse": {
    "prefix": "hvue refDebounced - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Reactivity\r",
      "alias: useDebounce, debouncedRef\r",
      "---\r",
      "\r",
      "# refDebounced\r",
      "\r",
      "Debounce execution of a ref value.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js {4}\r",
      "import { refDebounced } from '@vueuse/core'\r",
      "\r",
      "const input = ref('foo')\r",
      "const debounced = refDebounced(input, 1000)\r",
      "\r",
      "input.value = 'bar'\r",
      "console.log(debounced.value) // 'foo'\r",
      "\r",
      "await sleep(1100)\r",
      "\r",
      "console.log(debounced.value) // 'bar'\r",
      "```\r",
      "You can also pass an optional 3rd parameter including maxWait option. See `useDebounceFn` for details.\r",
      "\r",
      "## Recommended Reading\r",
      "\r",
      "- [**Debounce vs Throttle**: Definitive Visual Guide](https://redd.one/blog/debounce-vs-throttle)\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref, watch } from 'vue-demi'\r",
      "import { useDebounceFn } from '../useDebounceFn'\r",
      "import type { DebounceFilterOptions, MaybeRefOrGetter } from '../utils'\r",
      "\r",
      "/**\r",
      " * Debounce updates of a ref.\r",
      " *\r",
      " * @return A new debounced ref.\r",
      " */\r",
      "export function refDebounced<T>(value: Ref<T>, ms: MaybeRefOrGetter<number> = 200, options: DebounceFilterOptions = {}): Readonly<Ref<T>> {\r",
      "  const debounced = ref(value.value as T) as Ref<T>\r",
      "\r",
      "  const updater = useDebounceFn(() => {\r",
      "    debounced.value = value.value\r",
      "  }, ms, options)\r",
      "\r",
      "  watch(value, () => updater())\r",
      "\r",
      "  return debounced\r",
      "}\r",
      "\r",
      "// alias\r",
      "export {\r",
      "  refDebounced as useDebounce,\r",
      "  refDebounced as debouncedRef,\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref, watch } from 'vue'\r",
      "import { refDebounced } from '@vueuse/core'\r",
      "\r",
      "const input = ref('')\r",
      "const debounced = refDebounced(input, 1000)\r",
      "const updated = ref(0)\r",
      "\r",
      "watch(debounced, () => (updated.value += 1))\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <input v-model=\"input\" placeholder=\"Try to type anything...\" type=\"text\">\r",
      "    <note>Delay is set to 1000ms for this demo.</note>\r",
      "\r",
      "    <p>Debounced: {{ debounced }}</p>\r",
      "    <p>Times Updated: {{ updated }}</p>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue refThrottled - vueuse": {
    "prefix": "hvue refThrottled - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Reactivity\r",
      "alias: useThrottle, throttledRef\r",
      "---\r",
      "\r",
      "# refThrottled\r",
      "\r",
      "Throttle changing of a ref value.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { refThrottled } from '@vueuse/core'\r",
      "\r",
      "const input = ref('')\r",
      "const throttled = refThrottled(input, 1000)\r",
      "```\r",
      "\r",
      "### Trailing\r",
      "\r",
      "If you don't want to watch trailing changes, set 3rd param `false` (it's `true` by default):\r",
      "\r",
      "```js\r",
      "import { refThrottled } from '@vueuse/core'\r",
      "\r",
      "const input = ref('')\r",
      "const throttled = refThrottled(input, 1000, false)\r",
      "```\r",
      "\r",
      "### Leading\r",
      "\r",
      "Allows the callback to be invoked immediately (on the leading edge of the `ms` timeout). If you don't want this behavior, set the 4th param `false` (it's `true` by default):\r",
      "\r",
      "```js\r",
      "import { refThrottled } from '@vueuse/core'\r",
      "\r",
      "const input = ref('')\r",
      "const throttled = refThrottled(input, 1000, undefined, false)\r",
      "```\r",
      "\r",
      "## Recommended Reading\r",
      "\r",
      "- [Debounce vs Throttle: Definitive Visual Guide](https://redd.one/blog/debounce-vs-throttle)\r",
      "- [Debouncing and Throttling Explained Through Examples](https://css-tricks.com/debouncing-throttling-explained-examples/)\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref, watch } from 'vue-demi'\r",
      "import { useThrottleFn } from '../useThrottleFn'\r",
      "\r",
      "/**\r",
      " * Throttle execution of a function. Especially useful for rate limiting\r",
      " * execution of handlers on events like resize and scroll.\r",
      " *\r",
      " * @param value Ref value to be watched with throttle effect\r",
      " * @param  delay  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\r",
      " * @param [trailing=true] if true, update the value again after the delay time is up\r",
      " * @param [leading=true] if true, update the value on the leading edge of the ms timeout\r",
      " */\r",
      "export function refThrottled<T>(value: Ref<T>, delay = 200, trailing = true, leading = true) {\r",
      "  if (delay <= 0)\r",
      "    return value\r",
      "\r",
      "  const throttled: Ref<T> = ref(value.value as T) as Ref<T>\r",
      "\r",
      "  const updater = useThrottleFn(() => {\r",
      "    throttled.value = value.value\r",
      "  }, delay, trailing, leading)\r",
      "\r",
      "  watch(value, () => updater())\r",
      "\r",
      "  return throttled\r",
      "}\r",
      "\r",
      "// alias\r",
      "export {\r",
      "  refThrottled as useThrottle,\r",
      "  refThrottled as throttledRef,\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref, watch } from 'vue'\r",
      "import { refThrottled } from '@vueuse/core'\r",
      "\r",
      "const trailing = ref(true)\r",
      "const leading = ref(false)\r",
      "const input = ref('')\r",
      "const throttled = refThrottled(input, 1000, trailing.value, leading.value)\r",
      "const updated = ref(0)\r",
      "\r",
      "watch(throttled, () => {\r",
      "  updated.value += 1\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <input v-model=\"input\" placeholder=\"Try to type anything...\" type=\"text\">\r",
      "    <note>Delay is set to 1000ms for this demo.</note>\r",
      "\r",
      "    <p>Throttled: {{ throttled }}</p>\r",
      "    <p>Times Updated: {{ updated }}</p>\r",
      "    <p>Trailing: {{ trailing }}</p>\r",
      "    <p>Leading: {{ leading }}</p>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue syncRef - vueuse": {
    "prefix": "hvue syncRef - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Reactivity\r",
      "related: syncRefs\r",
      "---\r",
      "\r",
      "# syncRef\r",
      "\r",
      "Two-way refs synchronization.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { syncRef } from '@vueuse/core'\r",
      "\r",
      "const a = ref('a')\r",
      "const b = ref('b')\r",
      "\r",
      "const stop = syncRef(a, b)\r",
      "\r",
      "console.log(a.value) // a\r",
      "\r",
      "b.value = 'foo'\r",
      "\r",
      "console.log(a.value) // foo\r",
      "\r",
      "a.value = 'bar'\r",
      "\r",
      "console.log(b.value) // bar\r",
      "```\r",
      "\r",
      "### One directional\r",
      "\r",
      "```ts\r",
      "import { syncRef } from '@vueuse/core'\r",
      "\r",
      "const a = ref('a')\r",
      "const b = ref('b')\r",
      "\r",
      "const stop = syncRef(a, b, { direction: 'rtl' })\r",
      "```\r",
      "\r",
      "### Custom Transform\r",
      "\r",
      "```ts\r",
      "import { syncRef } from '@vueuse/core'\r",
      "\r",
      "const a = ref(10)\r",
      "const b = ref(2)\r",
      "\r",
      "const stop = syncRef(a, b, {\r",
      "  transform: {\r",
      "    ltr: left => left * 2,\r",
      "    rtl: right => right / 2\r",
      "  }\r",
      "})\r",
      "\r",
      "console.log(b.value) // 20\r",
      "\r",
      "b.value = 30\r",
      "\r",
      "console.log(a.value) // 15\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref, WatchStopHandle } from 'vue-demi'\r",
      "import { watch } from 'vue-demi'\r",
      "import type { ConfigurableFlushSync } from '../utils'\r",
      "\r",
      "export interface SyncRefOptions<L, R = L> extends ConfigurableFlushSync {\r",
      "  /**\r",
      "   * Watch deeply\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  deep?: boolean\r",
      "  /**\r",
      "   * Sync values immediately\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "\r",
      "  /**\r",
      "   * Direction of syncing. Value will be redefined if you define syncConvertors\r",
      "   *\r",
      "   * @default 'both'\r",
      "   */\r",
      "  direction?: 'ltr' | 'rtl' | 'both'\r",
      "\r",
      "  /**\r",
      "   * Custom transform function\r",
      "   */\r",
      "  transform?: {\r",
      "    ltr?: (left: L) => R\r",
      "    rtl?: (right: R) => L\r",
      "  }\r",
      "}\r",
      "\r",
      "/**\r",
      " * Two-way refs synchronization.\r",
      " *\r",
      " * @param left\r",
      " * @param right\r",
      " */\r",
      "export function syncRef<L, R = L>(left: Ref<L>, right: Ref<R>, options: SyncRefOptions<L, R> = {}) {\r",
      "  const {\r",
      "    flush = 'sync',\r",
      "    deep = false,\r",
      "    immediate = true,\r",
      "    direction = 'both',\r",
      "    transform = {},\r",
      "  } = options\r",
      "\r",
      "  let watchLeft: WatchStopHandle\r",
      "  let watchRight: WatchStopHandle\r",
      "\r",
      "  const transformLTR = transform.ltr ?? (v => v)\r",
      "  const transformRTL = transform.rtl ?? (v => v)\r",
      "\r",
      "  if (direction === 'both' || direction === 'ltr') {\r",
      "    watchLeft = watch(\r",
      "      left,\r",
      "      newValue => right.value = transformLTR(newValue) as R,\r",
      "      { flush, deep, immediate },\r",
      "    )\r",
      "  }\r",
      "\r",
      "  if (direction === 'both' || direction === 'rtl') {\r",
      "    watchRight = watch(\r",
      "      right,\r",
      "      newValue => left.value = transformRTL(newValue) as L,\r",
      "      { flush, deep, immediate },\r",
      "    )\r",
      "  }\r",
      "\r",
      "  return () => {\r",
      "    watchLeft?.()\r",
      "    watchRight?.()\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { syncRef } from '@vueuse/core'\r",
      "\r",
      "const a = ref('')\r",
      "const b = ref('')\r",
      "\r",
      "syncRef(a, b)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <input v-model=\"a\" placeholder=\"A\" type=\"text\">\r",
      "  <input v-model=\"b\" placeholder=\"B\" type=\"text\">\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue syncRefs - vueuse": {
    "prefix": "hvue syncRefs - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Reactivity\r",
      "related: syncRef\r",
      "---\r",
      "\r",
      "# syncRefs\r",
      "\r",
      "Keep target refs in sync with a source ref\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { syncRefs } from '@vueuse/core'\r",
      "\r",
      "const source = ref('hello')\r",
      "const target = ref('target')\r",
      "\r",
      "const stop = syncRefs(source, target)\r",
      "\r",
      "console.log(target.value) // hello\r",
      "\r",
      "source.value = 'foo'\r",
      "\r",
      "console.log(target.value) // foo\r",
      "```\r",
      "\r",
      "## Watch options\r",
      "\r",
      "The options for `syncRefs` are similar to `watch`'s `WatchOptions` but with different default values.\r",
      "\r",
      "```ts\r",
      "export interface SyncRefOptions {\r",
      "  /**\r",
      "   * Timing for syncing, same as watch's flush option\r",
      "   *\r",
      "   * @default 'sync'\r",
      "   */\r",
      "  flush?: WatchOptions['flush']\r",
      "  /**\r",
      "   * Watch deeply\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  deep?: boolean\r",
      "  /**\r",
      "   * Sync values immediately\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "}\r",
      "```\r",
      "\r",
      "When setting `{ flush: 'pre' }`, the target reference will be updated at [the end of the current \"tick\"](https://vuejs.org/guide/essentials/watchers.html#callback-flush-timing) before rendering starts.\r",
      "\r",
      "```ts\r",
      "import { syncRefs } from '@vueuse/core'\r",
      "\r",
      "const source = ref('hello')\r",
      "const target = ref('target')\r",
      "\r",
      "syncRefs(source, target, { flush: 'pre' })\r",
      "\r",
      "console.log(target.value) // hello\r",
      "\r",
      "source.value = 'foo'\r",
      "\r",
      "console.log(target.value) // hello <- still unchanged, because of flush 'pre'\r",
      "\r",
      "await nextTick()\r",
      "\r",
      "console.log(target.value) // foo <- changed!\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref, WatchSource } from 'vue-demi'\r",
      "import { watch } from 'vue-demi'\r",
      "import type { ConfigurableFlushSync } from '../utils'\r",
      "\r",
      "export interface SyncRefsOptions extends ConfigurableFlushSync {\r",
      "  /**\r",
      "   * Watch deeply\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  deep?: boolean\r",
      "  /**\r",
      "   * Sync values immediately\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Keep target ref(s) in sync with the source ref\r",
      " *\r",
      " * @param source source ref\r",
      " * @param targets\r",
      " */\r",
      "export function syncRefs<T>(\r",
      "  source: WatchSource<T>,\r",
      "  targets: Ref<T> | Ref<T>[],\r",
      "  options: SyncRefsOptions = {},\r",
      ") {\r",
      "  const {\r",
      "    flush = 'sync',\r",
      "    deep = false,\r",
      "    immediate = true,\r",
      "  } = options\r",
      "  if (!Array.isArray(targets))\r",
      "    targets = [targets]\r",
      "\r",
      "  return watch(\r",
      "    source,\r",
      "    newValue => (targets as Ref<T>[]).forEach(target => target.value = newValue),\r",
      "    { flush, deep, immediate },\r",
      "  )\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { syncRefs } from '@vueuse/core'\r",
      "\r",
      "const source = ref('')\r",
      "const target1 = ref('')\r",
      "const target2 = ref('')\r",
      "\r",
      "syncRefs(source, [target1, target2])\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <input v-model=\"source\" placeholder=\"Source\" type=\"text\">\r",
      "    <input v-model=\"target1\" placeholder=\"Target1\" type=\"text\">\r",
      "    <input v-model=\"target2\" placeholder=\"Target2\" type=\"text\">\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue until - vueuse": {
    "prefix": "hvue until - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Watch\r",
      "---\r",
      "\r",
      "# until\r",
      "\r",
      "Promised one-time watch for changes\r",
      "\r",
      "## Usage\r",
      "\r",
      "#### Wait for some async data to be ready\r",
      "\r",
      "```js\r",
      "import { until, useAsyncState } from '@vueuse/core'\r",
      "\r",
      "const { state, isReady } = useAsyncState(\r",
      "  fetch('https://jsonplaceholder.typicode.com/todos/1').then(t => t.json()),\r",
      "  {},\r",
      ")\r",
      "\r",
      ";(async () => {\r",
      "  await until(isReady).toBe(true)\r",
      "\r",
      "  console.log(state) // state is now ready!\r",
      "})()\r",
      "```\r",
      "\r",
      "#### Wait for custom conditions\r",
      "\r",
      "> You can use `invoke` to call the async function.\r",
      "\r",
      "```js\r",
      "import { invoke, until, useCounter } from '@vueuse/core'\r",
      "\r",
      "const { count } = useCounter()\r",
      "\r",
      "invoke(async () => {\r",
      "  await until(count).toMatch(v => v > 7)\r",
      "\r",
      "  alert('Counter is now larger than 7!')\r",
      "})\r",
      "```\r",
      "\r",
      "#### Timeout\r",
      "\r",
      "```ts\r",
      "// will be resolve until ref.value === true or 1000ms passed\r",
      "await until(ref).toBe(true, { timeout: 1000 })\r",
      "\r",
      "// will throw if timeout\r",
      "try {\r",
      "  await until(ref).toBe(true, { timeout: 1000, throwOnTimeout: true })\r",
      "  // ref.value === true\r",
      "}\r",
      "catch (e) {\r",
      "  // timeout\r",
      "}\r",
      "```\r",
      "\r",
      "#### More Examples\r",
      "\r",
      "```ts\r",
      "await until(ref).toBe(true)\r",
      "await until(ref).toMatch(v => v > 10 && v < 100)\r",
      "await until(ref).changed()\r",
      "await until(ref).changedTimes(10)\r",
      "await until(ref).toBeTruthy()\r",
      "await until(ref).toBeNull()\r",
      "\r",
      "await until(ref).not.toBeNull()\r",
      "await until(ref).not.toBeTruthy()\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { WatchOptions, WatchSource } from 'vue-demi'\r",
      "import { isRef, watch } from 'vue-demi'\r",
      "import { toValue } from '../toValue'\r",
      "import type { ElementOf, MaybeRefOrGetter, ShallowUnwrapRef } from '../utils'\r",
      "import { promiseTimeout } from '../utils'\r",
      "\r",
      "export interface UntilToMatchOptions {\r",
      "  /**\r",
      "   * Milliseconds timeout for promise to resolve/reject if the when condition does not meet.\r",
      "   * 0 for never timed out\r",
      "   *\r",
      "   * @default 0\r",
      "   */\r",
      "  timeout?: number\r",
      "\r",
      "  /**\r",
      "   * Reject the promise when timeout\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  throwOnTimeout?: boolean\r",
      "\r",
      "  /**\r",
      "   * `flush` option for internal watch\r",
      "   *\r",
      "   * @default 'sync'\r",
      "   */\r",
      "  flush?: WatchOptions['flush']\r",
      "\r",
      "  /**\r",
      "   * `deep` option for internal watch\r",
      "   *\r",
      "   * @default 'false'\r",
      "   */\r",
      "  deep?: WatchOptions['deep']\r",
      "}\r",
      "\r",
      "export interface UntilBaseInstance<T, Not extends boolean = false> {\r",
      "  toMatch<U extends T = T>(\r",
      "    condition: (v: T) => v is U,\r",
      "    options?: UntilToMatchOptions\r",
      "  ): Not extends true ? Promise<Exclude<T, U>> : Promise<U>\r",
      "  toMatch(\r",
      "    condition: (v: T) => boolean,\r",
      "    options?: UntilToMatchOptions\r",
      "  ): Promise<T>\r",
      "  changed(options?: UntilToMatchOptions): Promise<T>\r",
      "  changedTimes(n?: number, options?: UntilToMatchOptions): Promise<T>\r",
      "}\r",
      "\r",
      "type Falsy = false | void | null | undefined | 0 | 0n | ''\r",
      "\r",
      "export interface UntilValueInstance<T, Not extends boolean = false> extends UntilBaseInstance<T, Not> {\r",
      "  readonly not: UntilValueInstance<T, Not extends true ? false : true>\r",
      "\r",
      "  toBe<P = T>(value: MaybeRefOrGetter<P>, options?: UntilToMatchOptions): Not extends true ? Promise<T> : Promise<P>\r",
      "  toBeTruthy(options?: UntilToMatchOptions): Not extends true ? Promise<T & Falsy> : Promise<Exclude<T, Falsy>>\r",
      "  toBeNull(options?: UntilToMatchOptions): Not extends true ? Promise<Exclude<T, null>> : Promise<null>\r",
      "  toBeUndefined(options?: UntilToMatchOptions): Not extends true ? Promise<Exclude<T, undefined>> : Promise<undefined>\r",
      "  toBeNaN(options?: UntilToMatchOptions): Promise<T>\r",
      "}\r",
      "\r",
      "export interface UntilArrayInstance<T> extends UntilBaseInstance<T> {\r",
      "  readonly not: UntilArrayInstance<T>\r",
      "\r",
      "  toContains(value: MaybeRefOrGetter<ElementOf<ShallowUnwrapRef<T>>>, options?: UntilToMatchOptions): Promise<T>\r",
      "}\r",
      "\r",
      "function createUntil<T>(r: any, isNot = false) {\r",
      "  function toMatch(\r",
      "    condition: (v: any) => boolean,\r",
      "    { flush = 'sync', deep = false, timeout, throwOnTimeout }: UntilToMatchOptions = {},\r",
      "  ): Promise<T> {\r",
      "    let stop: (() => void) | null = null\r",
      "    const watcher = new Promise<T>((resolve) => {\r",
      "      stop = watch(\r",
      "        r,\r",
      "        (v) => {\r",
      "          if (condition(v) !== isNot) {\r",
      "            stop?.()\r",
      "            resolve(v)\r",
      "          }\r",
      "        },\r",
      "        {\r",
      "          flush,\r",
      "          deep,\r",
      "          immediate: true,\r",
      "        },\r",
      "      )\r",
      "    })\r",
      "\r",
      "    const promises = [watcher]\r",
      "    if (timeout != null) {\r",
      "      promises.push(\r",
      "        promiseTimeout(timeout, throwOnTimeout)\r",
      "          .then(() => toValue(r))\r",
      "          .finally(() => stop?.()),\r",
      "      )\r",
      "    }\r",
      "\r",
      "    return Promise.race(promises)\r",
      "  }\r",
      "\r",
      "  function toBe<P>(value: MaybeRefOrGetter<P | T>, options?: UntilToMatchOptions) {\r",
      "    if (!isRef(value))\r",
      "      return toMatch(v => v === value, options)\r",
      "\r",
      "    const { flush = 'sync', deep = false, timeout, throwOnTimeout } = options ?? {}\r",
      "    let stop: (() => void) | null = null\r",
      "    const watcher = new Promise<T>((resolve) => {\r",
      "      stop = watch(\r",
      "        [r, value],\r",
      "        ([v1, v2]) => {\r",
      "          if (isNot !== (v1 === v2)) {\r",
      "            stop?.()\r",
      "            resolve(v1)\r",
      "          }\r",
      "        },\r",
      "        {\r",
      "          flush,\r",
      "          deep,\r",
      "          immediate: true,\r",
      "        },\r",
      "      )\r",
      "    })\r",
      "\r",
      "    const promises = [watcher]\r",
      "    if (timeout != null) {\r",
      "      promises.push(\r",
      "        promiseTimeout(timeout, throwOnTimeout)\r",
      "          .then(() => toValue(r))\r",
      "          .finally(() => {\r",
      "            stop?.()\r",
      "            return toValue(r)\r",
      "          }),\r",
      "      )\r",
      "    }\r",
      "\r",
      "    return Promise.race(promises)\r",
      "  }\r",
      "\r",
      "  function toBeTruthy(options?: UntilToMatchOptions) {\r",
      "    return toMatch(v => Boolean(v), options)\r",
      "  }\r",
      "\r",
      "  function toBeNull(options?: UntilToMatchOptions) {\r",
      "    return toBe<null>(null, options)\r",
      "  }\r",
      "\r",
      "  function toBeUndefined(options?: UntilToMatchOptions) {\r",
      "    return toBe<undefined>(undefined, options)\r",
      "  }\r",
      "\r",
      "  function toBeNaN(options?: UntilToMatchOptions) {\r",
      "    return toMatch(Number.isNaN, options)\r",
      "  }\r",
      "\r",
      "  function toContains(\r",
      "    value: any,\r",
      "    options?: UntilToMatchOptions,\r",
      "  ) {\r",
      "    return toMatch((v) => {\r",
      "      const array = Array.from(v as any)\r",
      "      return array.includes(value) || array.includes(toValue(value))\r",
      "    }, options)\r",
      "  }\r",
      "\r",
      "  function changed(options?: UntilToMatchOptions) {\r",
      "    return changedTimes(1, options)\r",
      "  }\r",
      "\r",
      "  function changedTimes(n = 1, options?: UntilToMatchOptions) {\r",
      "    let count = -1 // skip the immediate check\r",
      "    return toMatch(() => {\r",
      "      count += 1\r",
      "      return count >= n\r",
      "    }, options)\r",
      "  }\r",
      "\r",
      "  if (Array.isArray(toValue(r))) {\r",
      "    const instance: UntilArrayInstance<T> = {\r",
      "      toMatch,\r",
      "      toContains,\r",
      "      changed,\r",
      "      changedTimes,\r",
      "      get not() {\r",
      "        return createUntil(r, !isNot) as UntilArrayInstance<T>\r",
      "      },\r",
      "    }\r",
      "    return instance\r",
      "  }\r",
      "  else {\r",
      "    const instance: UntilValueInstance<T, boolean> = {\r",
      "      toMatch,\r",
      "      toBe,\r",
      "      toBeTruthy: toBeTruthy as any,\r",
      "      toBeNull: toBeNull as any,\r",
      "      toBeNaN,\r",
      "      toBeUndefined: toBeUndefined as any,\r",
      "      changed,\r",
      "      changedTimes,\r",
      "      get not() {\r",
      "        return createUntil(r, !isNot) as UntilValueInstance<T, boolean>\r",
      "      },\r",
      "    }\r",
      "\r",
      "    return instance\r",
      "  }\r",
      "}\r",
      "\r",
      "/**\r",
      " * Promised one-time watch for changes\r",
      " *\r",
      " * @see https://vueuse.org/until\r",
      " * @example\r",
      " * ```\r",
      " * const { count } = useCounter()\r",
      " *\r",
      " * await until(count).toMatch(v => v > 7)\r",
      " *\r",
      " * alert('Counter is now larger than 7!')\r",
      " * ```\r",
      " */\r",
      "export function until<T extends unknown[]>(r: WatchSource<T> | MaybeRefOrGetter<T>): UntilArrayInstance<T>\r",
      "export function until<T>(r: WatchSource<T> | MaybeRefOrGetter<T>): UntilValueInstance<T>\r",
      "export function until<T>(r: any): UntilValueInstance<T> | UntilArrayInstance<T> {\r",
      "  return createUntil(r)\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { invoke, until, useCounter } from '@vueuse/shared'\r",
      "\r",
      "const { count, inc, dec } = useCounter()\r",
      "\r",
      "invoke(async () => {\r",
      "  await until(count).toBe(7)\r",
      "\r",
      "  alert('You got 7!')\r",
      "})\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <note>Add to 7 to show the alert.</note>\r",
      "  <p>Count: {{ count }}</p>\r",
      "  <button @click=\"inc()\">\r",
      "    Increment\r",
      "  </button>\r",
      "  <button @click=\"dec()\">\r",
      "    Decrement\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useCounter - vueuse": {
    "prefix": "hvue useCounter - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useCounter\r",
      "\r",
      "Basic counter with utility functions.\r",
      "\r",
      "## Basic Usage\r",
      "\r",
      "```js\r",
      "import { useCounter } from '@vueuse/core'\r",
      "\r",
      "const { count, inc, dec, set, reset } = useCounter()\r",
      "```\r",
      "\r",
      "## Usage with options\r",
      "\r",
      "```js\r",
      "import { useCounter } from '@vueuse/core'\r",
      "\r",
      "const { count, inc, dec, set, reset } = useCounter(1, { min: 0, max: 16 })\r",
      "```\r",
      "# Source TS",
      "```js",
      "// eslint-disable-next-line no-restricted-imports\r",
      "import { ref, unref } from 'vue-demi'\r",
      "\r",
      "import type { MaybeRef } from 'vue-demi'\r",
      "\r",
      "export interface UseCounterOptions {\r",
      "  min?: number\r",
      "  max?: number\r",
      "}\r",
      "\r",
      "/**\r",
      " * Basic counter with utility functions.\r",
      " *\r",
      " * @see https://vueuse.org/useCounter\r",
      " * @param [initialValue=0]\r",
      " * @param {Object} options\r",
      " */\r",
      "export function useCounter(initialValue: MaybeRef<number> = 0, options: UseCounterOptions = {}) {\r",
      "  let _initialValue = unref(initialValue)\r",
      "  const count = ref(initialValue)\r",
      "\r",
      "  const {\r",
      "    max = Number.POSITIVE_INFINITY,\r",
      "    min = Number.NEGATIVE_INFINITY,\r",
      "  } = options\r",
      "\r",
      "  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta)\r",
      "  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta)\r",
      "  const get = () => count.value\r",
      "  const set = (val: number) => (count.value = Math.max(min, Math.min(max, val)))\r",
      "  const reset = (val = _initialValue) => {\r",
      "    _initialValue = val\r",
      "    return set(val)\r",
      "  }\r",
      "\r",
      "  return { count, inc, dec, get, set, reset }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useCounter } from '@vueuse/core'\r",
      "\r",
      "const { count, inc, dec, set, reset } = useCounter()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <p>Count: {{ count }}</p>\r",
      "    <button @click=\"inc()\">\r",
      "      Increment\r",
      "    </button>\r",
      "    <button @click=\"dec()\">\r",
      "      Decrement\r",
      "    </button>\r",
      "    <button @click=\"inc(5)\">\r",
      "      Increment (+5)\r",
      "    </button>\r",
      "    <button @click=\"dec(5)\">\r",
      "      Decrement (-5)\r",
      "    </button>\r",
      "    <button @click=\"set(100)\">\r",
      "      Set (100)\r",
      "    </button>\r",
      "    <button @click=\"reset()\">\r",
      "      Reset\r",
      "    </button>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDateFormat - vueuse": {
    "prefix": "hvue useDateFormat - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Time\r",
      "---\r",
      "\r",
      "# useDateFormat\r",
      "\r",
      "Get the formatted date according to the string of tokens passed in, inspired by [dayjs](https://github.com/iamkun/dayjs).\r",
      "\r",
      "**List of all available formats (HH:mm:ss by default):**\r",
      "\r",
      "| Format | Output           | Description                           |\r",
      "|--------| ---------------- |---------------------------------------|\r",
      "| `YY`   | 18               | Two-digit year                        |\r",
      "| `YYYY` | 2018             | Four-digit year                       |\r",
      "| `M`    | 1-12             | The month, beginning at 1             |\r",
      "| `MM`   | 01-12            | The month, 2-digits                   |\r",
      "| `MMM`  | Jan-Dec          | The abbreviated month name            |\r",
      "| `MMMM` | January-December | The full month name                   |\r",
      "| `D`    | 1-31             | The day of the month                  |\r",
      "| `DD`   | 01-31            | The day of the month, 2-digits        |\r",
      "| `H`    | 0-23             | The hour                              |\r",
      "| `HH`   | 00-23            | The hour, 2-digits                    |\r",
      "| `h`    | 1-12             | The hour, 12-hour clock               |\r",
      "| `hh`   | 01-12            | The hour, 12-hour clock, 2-digits     |\r",
      "| `m`    | 0-59             | The minute                            |\r",
      "| `mm`   | 00-59            | The minute, 2-digits                  |\r",
      "| `s`    | 0-59             | The second                            |\r",
      "| `ss`   | 00-59            | The second, 2-digits                  |\r",
      "| `SSS`  | 000-999          | The millisecond, 3-digits             |\r",
      "| `A`    | AM PM            | The meridiem                          |\r",
      "| `AA`   | A.M. P.M.        | The meridiem, periods                 |\r",
      "| `a`    | am pm            | The meridiem, lowercase               |\r",
      "| `aa`   | a.m. p.m.        | The meridiem, lowercase and periods   |\r",
      "| `d`    | 0-6              | The day of the week, with Sunday as 0 |\r",
      "| `dd`   | S-S              | The min name of the day of the week   |\r",
      "| `ddd`  | Sun-Sat          | The short name of the day of the week |\r",
      "| `dddd` | Sunday-Saturday  | The name of the day of the week       |\r",
      "\r",
      "- Meridiem is customizable by defining `customMeridiem` in `options`.\r",
      "\r",
      "## Usage\r",
      "\r",
      "### Basic\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "\r",
      "import { useNow, useDateFormat } from '@vueuse/core'\r",
      "\r",
      "const formatted = useDateFormat(useNow(), 'YYYY-MM-DD HH:mm:ss')\r",
      "\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>{{ formatted }}</div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Use with locales\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "\r",
      "import { useNow, useDateFormat } from '@vueuse/core'\r",
      "\r",
      "const formatted = useDateFormat(useNow(), 'YYYY-MM-DD (ddd)', { locales: 'en-US' })\r",
      "\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>{{ formatted }}</div>\r",
      "</template>\r",
      "```\r",
      "\r",
      "### Use with custom meridiem\r",
      "\r",
      "```html\r",
      "<script setup lang=\"ts\">\r",
      "\r",
      "import { useDateFormat } from '@vueuse/core'\r",
      "\r",
      "const customMeridiem = (hours: number, minutes: number, isLowercase?: boolean, hasPeriod?: boolean) => {\r",
      "  const m = hours > 11 ? (isLowercase ? 'ŒºŒº' : 'ŒúŒú') : (isLowercase ? 'œÄŒº' : 'Œ†Œú')\r",
      "  return hasPeriod ? m.split('').reduce((acc, current) => acc += `${current}.`, '') : m\r",
      "}\r",
      "\r",
      "const am = useDateFormat('2022-01-01 05:05:05', 'hh:mm:ss A', { customMeridiem })\r",
      "// am.value = '05:05:05 Œ†Œú'\r",
      "const pm = useDateFormat('2022-01-01 17:05:05', 'hh:mm:ss AA', { customMeridiem })\r",
      "// pm.value = '05:05:05 Œú.Œú.'\r",
      "</script>\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { computed } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter } from '../utils'\r",
      "import { toValue } from '../toValue'\r",
      "\r",
      "export type DateLike = Date | number | string | undefined\r",
      "\r",
      "export interface UseDateFormatOptions {\r",
      "  /**\r",
      "   * The locale(s) to used for dd/ddd/dddd/MMM/MMMM format\r",
      "   *\r",
      "   * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument).\r",
      "   */\r",
      "  locales?: Intl.LocalesArgument\r",
      "\r",
      "  /**\r",
      "   * A custom function to re-modify the way to display meridiem\r",
      "   *\r",
      "   */\r",
      "  customMeridiem?: (hours: number, minutes: number, isLowercase?: boolean, hasPeriod?: boolean) => string\r",
      "}\r",
      "\r",
      "const REGEX_PARSE = /*#__PURE__*/ /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/\r",
      "const REGEX_FORMAT = /*#__PURE__*/ /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g\r",
      "\r",
      "function defaultMeridiem(hours: number, minutes: number, isLowercase?: boolean, hasPeriod?: boolean) {\r",
      "  let m = (hours < 12 ? 'AM' : 'PM')\r",
      "  if (hasPeriod)\r",
      "    m = m.split('').reduce((acc, curr) => acc += `${curr}.`, '')\r",
      "  return isLowercase ? m.toLowerCase() : m\r",
      "}\r",
      "\r",
      "export function formatDate(date: Date, formatStr: string, options: UseDateFormatOptions = {}) {\r",
      "  const years = date.getFullYear()\r",
      "  const month = date.getMonth()\r",
      "  const days = date.getDate()\r",
      "  const hours = date.getHours()\r",
      "  const minutes = date.getMinutes()\r",
      "  const seconds = date.getSeconds()\r",
      "  const milliseconds = date.getMilliseconds()\r",
      "  const day = date.getDay()\r",
      "  const meridiem = options.customMeridiem ?? defaultMeridiem\r",
      "  const matches: Record<string, () => string | number> = {\r",
      "    YY: () => String(years).slice(-2),\r",
      "    YYYY: () => years,\r",
      "    M: () => month + 1,\r",
      "    MM: () => `${month + 1}`.padStart(2, '0'),\r",
      "    MMM: () => date.toLocaleDateString(options.locales, { month: 'short' }),\r",
      "    MMMM: () => date.toLocaleDateString(options.locales, { month: 'long' }),\r",
      "    D: () => String(days),\r",
      "    DD: () => `${days}`.padStart(2, '0'),\r",
      "    H: () => String(hours),\r",
      "    HH: () => `${hours}`.padStart(2, '0'),\r",
      "    h: () => `${hours % 12 || 12}`.padStart(1, '0'),\r",
      "    hh: () => `${hours % 12 || 12}`.padStart(2, '0'),\r",
      "    m: () => String(minutes),\r",
      "    mm: () => `${minutes}`.padStart(2, '0'),\r",
      "    s: () => String(seconds),\r",
      "    ss: () => `${seconds}`.padStart(2, '0'),\r",
      "    SSS: () => `${milliseconds}`.padStart(3, '0'),\r",
      "    d: () => day,\r",
      "    dd: () => date.toLocaleDateString(options.locales, { weekday: 'narrow' }),\r",
      "    ddd: () => date.toLocaleDateString(options.locales, { weekday: 'short' }),\r",
      "    dddd: () => date.toLocaleDateString(options.locales, { weekday: 'long' }),\r",
      "    A: () => meridiem(hours, minutes),\r",
      "    AA: () => meridiem(hours, minutes, false, true),\r",
      "    a: () => meridiem(hours, minutes, true),\r",
      "    aa: () => meridiem(hours, minutes, true, true),\r",
      "  }\r",
      "  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 ?? matches[match]?.() ?? match)\r",
      "}\r",
      "\r",
      "export function normalizeDate(date: DateLike) {\r",
      "  if (date === null)\r",
      "    return new Date(Number.NaN) // null is invalid\r",
      "  if (date === undefined)\r",
      "    return new Date()\r",
      "  if (date instanceof Date)\r",
      "    return new Date(date)\r",
      "  if (typeof date === 'string' && !/Z$/i.test(date)) {\r",
      "    const d = date.match(REGEX_PARSE) as any\r",
      "    if (d) {\r",
      "      const m = d[2] - 1 || 0\r",
      "      const ms = (d[7] || '0').substring(0, 3)\r",
      "      return new Date(d[1], m, d[3]\r",
      "        || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms)\r",
      "    }\r",
      "  }\r",
      "\r",
      "  return new Date(date)\r",
      "}\r",
      "\r",
      "/**\r",
      " * Get the formatted date according to the string of tokens passed in.\r",
      " *\r",
      " * @see https://vueuse.org/useDateFormat\r",
      " * @param date - The date to format, can either be a `Date` object, a timestamp, or a string\r",
      " * @param formatStr - The combination of tokens to format the date\r",
      " * @param options - UseDateFormatOptions\r",
      " */\r",
      "\r",
      "export function useDateFormat(date: MaybeRefOrGetter<DateLike>, formatStr: MaybeRefOrGetter<string> = 'HH:mm:ss', options: UseDateFormatOptions = {}) {\r",
      "  return computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options))\r",
      "}\r",
      "\r",
      "export type UseDateFormatReturn = ReturnType<typeof useDateFormat>\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useDateFormat, useNow } from '@vueuse/core'\r",
      "\r",
      "const formatter = ref('YYYY-MM-DD HH:mm:ss')\r",
      "const formatted = useDateFormat(useNow(), formatter)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p class=\"text-20px font-bold text-emerald-500\">\r",
      "    {{ formatted }}\r",
      "  </p>\r",
      "  <div class=\"flex items-center\">\r",
      "    <span class=\"mr-5px text-18px\">\r",
      "      Formatter Editor :\r",
      "    </span>\r",
      "    <input v-model=\"formatter\" type=\"text\">\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useDebounceFn - vueuse": {
    "prefix": "hvue useDebounceFn - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "related: useThrottleFn\r",
      "---\r",
      "\r",
      "# useDebounceFn\r",
      "\r",
      "Debounce execution of a function.\r",
      ">\r",
      "> Debounce is an overloaded waiter: if you keep asking him your requests will be ignored until you stop and give him some time to think about your latest inquiry.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useDebounceFn } from '@vueuse/core'\r",
      "\r",
      "const debouncedFn = useDebounceFn(() => {\r",
      "  // do something\r",
      "}, 1000)\r",
      "\r",
      "window.addEventListener('resize', debouncedFn)\r",
      "```\r",
      "\r",
      "You can also pass a 3rd parameter to this, with a maximum wait time, similar to [lodash debounce](https://lodash.com/docs/4.17.15#debounce)\r",
      "\r",
      "```js\r",
      "import { useDebounceFn } from '@vueuse/core'\r",
      "\r",
      "// If no invokation after 5000ms due to repeated input,\r",
      "// the function will be called anyway.\r",
      "const debouncedFn = useDebounceFn(() => {\r",
      "  // do something\r",
      "}, 1000, { maxWait: 5000 })\r",
      "\r",
      "window.addEventListener('resize', debouncedFn)\r",
      "```\r",
      "\r",
      "Optionally, you can get the return value of the function using promise operations.\r",
      "\r",
      "```js\r",
      "import { useDebounceFn } from '@vueuse/core'\r",
      "\r",
      "const debouncedRequest = useDebounceFn(() => 'response', 1000)\r",
      "\r",
      "debouncedRequest().then((value) => {\r",
      "  console.log(value) // 'response'\r",
      "})\r",
      "\r",
      "// or use async/await\r",
      "async function doRequest() {\r",
      "  const value = await debouncedRequest()\r",
      "  console.log(value) // 'response'\r",
      "}\r",
      "```\r",
      "\r",
      "Since unhandled rejection error is quite annoying when developer doesn't need the return value, the promise will **NOT** be rejected if the function is canceled **by default**. You need to specify the option `rejectOnCancel: true` to capture the rejection.\r",
      "\r",
      "```js\r",
      "import { useDebounceFn } from '@vueuse/core'\r",
      "\r",
      "const debouncedRequest = useDebounceFn(() => 'response', 1000, { rejectOnCancel: true })\r",
      "\r",
      "debouncedRequest()\r",
      "  .then((value) => {\r",
      "    // do something\r",
      "  })\r",
      "  .catch(() => {\r",
      "    // do something when canceled\r",
      "  })\r",
      "\r",
      "// calling it again will cancel the previous request and gets rejected\r",
      "setTimeout(debouncedRequest, 500)\r",
      "```\r",
      "## Recommended Reading\r",
      "\r",
      "- [**Debounce vs Throttle**: Definitive Visual Guide](https://redd.one/blog/debounce-vs-throttle)\r",
      "# Source TS",
      "```js",
      "import type { DebounceFilterOptions, FunctionArgs, MaybeRefOrGetter, PromisifyFn } from '../utils'\r",
      "import { createFilterWrapper, debounceFilter } from '../utils'\r",
      "\r",
      "/**\r",
      " * Debounce execution of a function.\r",
      " *\r",
      " * @see https://vueuse.org/useDebounceFn\r",
      " * @param  fn          A function to be executed after delay milliseconds debounced.\r",
      " * @param  ms          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\r",
      " * @param  opts        options\r",
      " *\r",
      " * @return A new, debounce, function.\r",
      " */\r",
      "export function useDebounceFn<T extends FunctionArgs>(\r",
      "  fn: T,\r",
      "  ms: MaybeRefOrGetter<number> = 200,\r",
      "  options: DebounceFilterOptions = {},\r",
      "): PromisifyFn<T> {\r",
      "  return createFilterWrapper(\r",
      "    debounceFilter(ms, options),\r",
      "    fn,\r",
      "  )\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useDebounceFn } from '@vueuse/core'\r",
      "\r",
      "const updated = ref(0)\r",
      "const clicked = ref(0)\r",
      "const debouncedFn = useDebounceFn(() => {\r",
      "  updated.value += 1\r",
      "}, 1000, { maxWait: 5000 })\r",
      "\r",
      "function clickedFn() {\r",
      "  clicked.value += 1\r",
      "  debouncedFn()\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <button @click=\"clickedFn\">\r",
      "    Smash me!\r",
      "  </button>\r",
      "  <note>Delay is set to 1000ms and maxWait is set to 5000ms for this demo.</note>\r",
      "\r",
      "  <p>Button clicked: {{ clicked }}</p>\r",
      "  <p>Event handler called: {{ updated }}</p>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useInterval - vueuse": {
    "prefix": "hvue useInterval - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Animation\r",
      "---\r",
      "\r",
      "# useInterval\r",
      "\r",
      "Reactive counter increases on every interval\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js {4}\r",
      "import { useInterval } from '@vueuse/core'\r",
      "\r",
      "// count will increase every 200ms\r",
      "const counter = useInterval(200)\r",
      "```\r",
      "\r",
      "```ts\r",
      "const { counter, reset, pause, resume } = useInterval(200, { controls: true })\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { ref } from 'vue-demi'\r",
      "import type { MaybeRefOrGetter, Pausable } from '../utils'\r",
      "import { useIntervalFn } from '../useIntervalFn'\r",
      "\r",
      "export interface UseIntervalOptions<Controls extends boolean> {\r",
      "  /**\r",
      "   * Expose more controls\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  controls?: Controls\r",
      "\r",
      "  /**\r",
      "   * Execute the update immediately on calling\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "\r",
      "  /**\r",
      "   * Callback on every interval\r",
      "   */\r",
      "  callback?: (count: number) => void\r",
      "}\r",
      "\r",
      "export interface UseIntervalControls {\r",
      "  counter: Ref<number>\r",
      "  reset: () => void\r",
      "}\r",
      "\r",
      "/**\r",
      " * Reactive counter increases on every interval\r",
      " *\r",
      " * @see https://vueuse.org/useInterval\r",
      " * @param interval\r",
      " * @param options\r",
      " */\r",
      "export function useInterval(interval?: MaybeRefOrGetter<number>, options?: UseIntervalOptions<false>): Ref<number>\r",
      "export function useInterval(interval: MaybeRefOrGetter<number>, options: UseIntervalOptions<true>): UseIntervalControls & Pausable\r",
      "export function useInterval(interval: MaybeRefOrGetter<number> = 1000, options: UseIntervalOptions<boolean> = {}) {\r",
      "  const {\r",
      "    controls: exposeControls = false,\r",
      "    immediate = true,\r",
      "    callback,\r",
      "  } = options\r",
      "\r",
      "  const counter = ref(0)\r",
      "  const update = () => counter.value += 1\r",
      "  const reset = () => {\r",
      "    counter.value = 0\r",
      "  }\r",
      "  const controls = useIntervalFn(\r",
      "    callback\r",
      "      ? () => {\r",
      "          update()\r",
      "          callback(counter.value)\r",
      "        }\r",
      "      : update,\r",
      "    interval,\r",
      "    { immediate },\r",
      "  )\r",
      "\r",
      "  if (exposeControls) {\r",
      "    return {\r",
      "      counter,\r",
      "      reset,\r",
      "      ...controls,\r",
      "    }\r",
      "  }\r",
      "  else {\r",
      "    return counter\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useInterval } from '@vueuse/core'\r",
      "\r",
      "const counter = useInterval(200)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <p>Interval fired: {{ counter }}</p>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useIntervalFn - vueuse": {
    "prefix": "hvue useIntervalFn - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Animation\r",
      "---\r",
      "\r",
      "# useIntervalFn\r",
      "\r",
      "Wrapper for `setInterval` with controls\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useIntervalFn } from '@vueuse/core'\r",
      "\r",
      "const { pause, resume, isActive } = useIntervalFn(() => {\r",
      "  /* your function */\r",
      "}, 1000)\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { isRef, ref, watch } from 'vue-demi'\r",
      "import { toValue } from '../toValue'\r",
      "import { tryOnScopeDispose } from '../tryOnScopeDispose'\r",
      "import type { Fn, MaybeRefOrGetter, Pausable } from '../utils'\r",
      "import { isClient } from '../utils'\r",
      "\r",
      "export interface UseIntervalFnOptions {\r",
      "  /**\r",
      "   * Start the timer immediately\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "\r",
      "  /**\r",
      "   * Execute the callback immediate after calling this function\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  immediateCallback?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Wrapper for `setInterval` with controls\r",
      " *\r",
      " * @param cb\r",
      " * @param interval\r",
      " * @param options\r",
      " */\r",
      "export function useIntervalFn(cb: Fn, interval: MaybeRefOrGetter<number> = 1000, options: UseIntervalFnOptions = {}): Pausable {\r",
      "  const {\r",
      "    immediate = true,\r",
      "    immediateCallback = false,\r",
      "  } = options\r",
      "\r",
      "  let timer: ReturnType<typeof setInterval> | null = null\r",
      "  const isActive = ref(false)\r",
      "\r",
      "  function clean() {\r",
      "    if (timer) {\r",
      "      clearInterval(timer)\r",
      "      timer = null\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function pause() {\r",
      "    isActive.value = false\r",
      "    clean()\r",
      "  }\r",
      "\r",
      "  function resume() {\r",
      "    const intervalValue = toValue(interval)\r",
      "    if (intervalValue <= 0)\r",
      "      return\r",
      "    isActive.value = true\r",
      "    if (immediateCallback)\r",
      "      cb()\r",
      "    clean()\r",
      "    timer = setInterval(cb, intervalValue)\r",
      "  }\r",
      "\r",
      "  if (immediate && isClient)\r",
      "    resume()\r",
      "\r",
      "  if (isRef(interval) || typeof interval === 'function') {\r",
      "    const stopWatch = watch(interval, () => {\r",
      "      if (isActive.value && isClient)\r",
      "        resume()\r",
      "    })\r",
      "    tryOnScopeDispose(stopWatch)\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(pause)\r",
      "\r",
      "  return {\r",
      "    isActive,\r",
      "    pause,\r",
      "    resume,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useIntervalFn } from '@vueuse/core'\r",
      "import { rand } from '@vueuse/shared'\r",
      "\r",
      "const greetings = ['Hello', 'Hi', 'Yo!', 'Hey', 'Hola', '„Åì„Çì„Å´„Å°„ÅØ', 'Bonjour', 'Salut!', '‰Ω†Â•Ω', '–ü—Ä–∏–≤–µ—Ç']\r",
      "const word = ref('Hello')\r",
      "const interval = ref(500)\r",
      "\r",
      "const { pause, resume, isActive } = useIntervalFn(() => {\r",
      "  word.value = greetings[rand(0, greetings.length - 1)]\r",
      "}, interval)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>{{ word }}</p>\r",
      "  <p>\r",
      "    interval:\r",
      "    <input v-model=\"interval\" type=\"number\" placeholder=\"interval\">\r",
      "  </p>\r",
      "  <button v-if=\"isActive\" class=\"orange\" @click=\"pause\">\r",
      "    Pause\r",
      "  </button>\r",
      "  <button v-if=\"!isActive\" @click=\"resume\">\r",
      "    Resume\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useLastChanged - vueuse": {
    "prefix": "hvue useLastChanged - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: State\r",
      "---\r",
      "\r",
      "# useLastChanged\r",
      "\r",
      "Records the timestamp of the last change\r",
      "\r",
      "## Usage\r",
      "\r",
      "```ts\r",
      "import { useLastChanged } from '@vueuse/core'\r",
      "\r",
      "const a = ref(0)\r",
      "\r",
      "const lastChanged = useLastChanged(a)\r",
      "\r",
      "a.value = 1\r",
      "\r",
      "console.log(lastChanged.value)\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref, WatchOptions, WatchSource } from 'vue-demi'\r",
      "import { ref, watch } from 'vue-demi'\r",
      "import { timestamp } from '../utils'\r",
      "\r",
      "export interface UseLastChangedOptions<\r",
      "  Immediate extends boolean,\r",
      "  InitialValue extends number | null | undefined = undefined,\r",
      "> extends WatchOptions<Immediate> {\r",
      "  initialValue?: InitialValue\r",
      "}\r",
      "\r",
      "/**\r",
      " * Records the timestamp of the last change\r",
      " *\r",
      " * @see https://vueuse.org/useLastChanged\r",
      " */\r",
      "export function useLastChanged(source: WatchSource, options?: UseLastChangedOptions<false>): Ref<number | null>\r",
      "export function useLastChanged(source: WatchSource, options: UseLastChangedOptions<true>): Ref<number>\r",
      "export function useLastChanged(source: WatchSource, options: UseLastChangedOptions<boolean, number>): Ref<number>\r",
      "export function useLastChanged(source: WatchSource, options: UseLastChangedOptions<boolean, any> = {}): Ref<number | null> | Ref<number> {\r",
      "  const ms = ref<number | null>(options.initialValue ?? null)\r",
      "\r",
      "  watch(\r",
      "    source,\r",
      "    () => ms.value = timestamp(),\r",
      "    options,\r",
      "  )\r",
      "\r",
      "  return ms\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { timestamp, useLastChanged, useTimeAgo } from '@vueuse/core'\r",
      "import { ref } from 'vue'\r",
      "\r",
      "const input = ref('')\r",
      "const ms = useLastChanged(input, { initialValue: timestamp() - 1000 * 60 * 5 })\r",
      "const timeago = useTimeAgo(ms)\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <input v-model=\"input\" type=\"text\" placeholder=\"Type anything...\">\r",
      "    <div>Last changed: <span class=\"text-primary\">{{ timeago }}</span> <span class=\"opacity-50 font-mono\">({{ ms }})</span></div>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useThrottleFn - vueuse": {
    "prefix": "hvue useThrottleFn - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "related: refThrottled, refDebounced, useDebounceFn\r",
      "---\r",
      "\r",
      "# useThrottleFn\r",
      "\r",
      "Throttle execution of a function. Especially useful for rate limiting execution of handlers on events like resize and scroll.\r",
      ">\r",
      "> Throttle is a spring that throws balls: after a ball flies out it needs some time to shrink back, so it cannot throw any more balls unless it's ready.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useThrottleFn } from '@vueuse/core'\r",
      "\r",
      "const throttledFn = useThrottleFn(() => {\r",
      "  // do something, it will be called at most 1 time per second\r",
      "}, 1000)\r",
      "\r",
      "window.addEventListener('resize', throttledFn)\r",
      "```\r",
      "\r",
      "## Recommended Reading\r",
      "\r",
      "- [**Debounce vs Throttle**: Definitive Visual Guide](https://redd.one/blog/debounce-vs-throttle)\r",
      "# Source TS",
      "```js",
      "import type { FunctionArgs, MaybeRefOrGetter, PromisifyFn } from '../utils'\r",
      "import { createFilterWrapper, throttleFilter } from '../utils'\r",
      "\r",
      "/**\r",
      " * Throttle execution of a function. Especially useful for rate limiting\r",
      " * execution of handlers on events like resize and scroll.\r",
      " *\r",
      " * @param   fn             A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\r",
      " *                                    to `callback` when the throttled-function is executed.\r",
      " * @param   ms             A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\r",
      " *\r",
      " * @param [trailing=false] if true, call fn again after the time is up\r",
      " *\r",
      " * @param [leading=true] if true, call fn on the leading edge of the ms timeout\r",
      " *\r",
      " * @param [rejectOnCancel=false] if true, reject the last call if it's been cancel\r",
      " *\r",
      " * @return  A new, throttled, function.\r",
      " */\r",
      "export function useThrottleFn<T extends FunctionArgs>(\r",
      "  fn: T,\r",
      "  ms: MaybeRefOrGetter<number> = 200,\r",
      "  trailing = false,\r",
      "  leading = true,\r",
      "  rejectOnCancel = false,\r",
      "): PromisifyFn<T> {\r",
      "  return createFilterWrapper(\r",
      "    throttleFilter(ms, trailing, leading, rejectOnCancel),\r",
      "    fn,\r",
      "  )\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useThrottleFn } from '@vueuse/core'\r",
      "\r",
      "const updated = ref(0)\r",
      "const clicked = ref(0)\r",
      "const throttledFn = useThrottleFn(() => {\r",
      "  updated.value += 1\r",
      "}, 1000)\r",
      "\r",
      "function clickedFn() {\r",
      "  clicked.value += 1\r",
      "  throttledFn()\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <button @click=\"clickedFn\">\r",
      "      Smash me!\r",
      "    </button>\r",
      "    <note>Delay is set to 1000ms for this demo.</note>\r",
      "\r",
      "    <p>Button clicked: {{ clicked }}</p>\r",
      "    <p>Event handler called: {{ updated }}</p>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTimeout - vueuse": {
    "prefix": "hvue useTimeout - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Animation\r",
      "---\r",
      "\r",
      "# useTimeout\r",
      "\r",
      "Update value after a given time with controls.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { promiseTimeout, useTimeout } from '@vueuse/core'\r",
      "\r",
      "const ready = useTimeout(1000)\r",
      "```\r",
      "\r",
      "```js\r",
      "const { ready, start, stop } = useTimeout(1000, { controls: true })\r",
      "```\r",
      "\r",
      "```js\r",
      "console.log(ready.value) // false\r",
      "\r",
      "await promiseTimeout(1200)\r",
      "\r",
      "console.log(ready.value) // true\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { ComputedRef } from 'vue-demi'\r",
      "import { computed } from 'vue-demi'\r",
      "import type { UseTimeoutFnOptions } from '../useTimeoutFn'\r",
      "import { useTimeoutFn } from '../useTimeoutFn'\r",
      "import type { Fn, Stoppable } from '../utils'\r",
      "import { noop } from '../utils'\r",
      "\r",
      "export interface UseTimeoutOptions<Controls extends boolean> extends UseTimeoutFnOptions {\r",
      "  /**\r",
      "   * Expose more controls\r",
      "   *\r",
      "   * @default false\r",
      "   */\r",
      "  controls?: Controls\r",
      "  /**\r",
      "   * Callback on timeout\r",
      "   */\r",
      "  callback?: Fn\r",
      "}\r",
      "\r",
      "/**\r",
      " * Update value after a given time with controls.\r",
      " *\r",
      " * @see   {@link https://vueuse.org/useTimeout}\r",
      " * @param interval\r",
      " * @param options\r",
      " */\r",
      "export function useTimeout(interval?: number, options?: UseTimeoutOptions<false>): ComputedRef<boolean>\r",
      "export function useTimeout(interval: number, options: UseTimeoutOptions<true>): { ready: ComputedRef<boolean> } & Stoppable\r",
      "export function useTimeout(interval = 1000, options: UseTimeoutOptions<boolean> = {}) {\r",
      "  const {\r",
      "    controls: exposeControls = false,\r",
      "    callback,\r",
      "  } = options\r",
      "\r",
      "  const controls = useTimeoutFn(\r",
      "    callback ?? noop,\r",
      "    interval,\r",
      "    options,\r",
      "  )\r",
      "\r",
      "  const ready = computed(() => !controls.isPending.value)\r",
      "\r",
      "  if (exposeControls) {\r",
      "    return {\r",
      "      ready,\r",
      "      ...controls,\r",
      "    }\r",
      "  }\r",
      "  else {\r",
      "    return ready\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useTimeout } from '@vueuse/core'\r",
      "\r",
      "const { ready, start } = useTimeout(1000, { controls: true })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <p>Ready: {{ ready.toString() }}</p>\r",
      "    <button :disabled=\"!ready\" @click=\"start()\">\r",
      "      Start Again\r",
      "    </button>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useTimeoutFn - vueuse": {
    "prefix": "hvue useTimeoutFn - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Animation\r",
      "---\r",
      "\r",
      "# useTimeoutFn\r",
      "\r",
      "Wrapper for `setTimeout` with controls.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useTimeoutFn } from '@vueuse/core'\r",
      "\r",
      "const { isPending, start, stop } = useTimeoutFn(() => {\r",
      "  /* ... */\r",
      "}, 3000)\r",
      "```\r",
      "# Source TS",
      "```js",
      "import { readonly, ref } from 'vue-demi'\r",
      "import type { AnyFn, MaybeRefOrGetter, Stoppable } from '../utils'\r",
      "import { toValue } from '../toValue'\r",
      "import { tryOnScopeDispose } from '../tryOnScopeDispose'\r",
      "import { isClient } from '../utils'\r",
      "\r",
      "export interface UseTimeoutFnOptions {\r",
      "  /**\r",
      "   * Start the timer immediate after calling this function\r",
      "   *\r",
      "   * @default true\r",
      "   */\r",
      "  immediate?: boolean\r",
      "}\r",
      "\r",
      "/**\r",
      " * Wrapper for `setTimeout` with controls.\r",
      " *\r",
      " * @param cb\r",
      " * @param interval\r",
      " * @param options\r",
      " */\r",
      "export function useTimeoutFn<CallbackFn extends AnyFn>(\r",
      "  cb: CallbackFn,\r",
      "  interval: MaybeRefOrGetter<number>,\r",
      "  options: UseTimeoutFnOptions = {},\r",
      "): Stoppable<Parameters<CallbackFn> | []> {\r",
      "  const {\r",
      "    immediate = true,\r",
      "  } = options\r",
      "\r",
      "  const isPending = ref(false)\r",
      "\r",
      "  let timer: ReturnType<typeof setTimeout> | null = null\r",
      "\r",
      "  function clear() {\r",
      "    if (timer) {\r",
      "      clearTimeout(timer)\r",
      "      timer = null\r",
      "    }\r",
      "  }\r",
      "\r",
      "  function stop() {\r",
      "    isPending.value = false\r",
      "    clear()\r",
      "  }\r",
      "\r",
      "  function start(...args: Parameters<CallbackFn> | []) {\r",
      "    clear()\r",
      "    isPending.value = true\r",
      "    timer = setTimeout(() => {\r",
      "      isPending.value = false\r",
      "      timer = null\r",
      "\r",
      "      cb(...args)\r",
      "    }, toValue(interval))\r",
      "  }\r",
      "\r",
      "  if (immediate) {\r",
      "    isPending.value = true\r",
      "    if (isClient)\r",
      "      start()\r",
      "  }\r",
      "\r",
      "  tryOnScopeDispose(stop)\r",
      "\r",
      "  return {\r",
      "    isPending: readonly(isPending),\r",
      "    start,\r",
      "    stop,\r",
      "  }\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { useTimeoutFn } from '@vueuse/core'\r",
      "\r",
      "const defaultText = 'Please wait for 3 seconds'\r",
      "const text = ref(defaultText)\r",
      "const { start, isPending } = useTimeoutFn(() => {\r",
      "  text.value = 'Fired!'\r",
      "}, 3000)\r",
      "\r",
      "function restart() {\r",
      "  text.value = defaultText\r",
      "  start()\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <p>{{ text }}</p>\r",
      "  <button :class=\"{ disabled: isPending }\" @click=\"restart()\">\r",
      "    Restart\r",
      "  </button>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useToggle - vueuse": {
    "prefix": "hvue useToggle - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Utilities\r",
      "---\r",
      "\r",
      "# useToggle\r",
      "\r",
      "A boolean switcher with utility functions.\r",
      "\r",
      "## Usage\r",
      "\r",
      "```js\r",
      "import { useToggle } from '@vueuse/core'\r",
      "\r",
      "const [value, toggle] = useToggle()\r",
      "```\r",
      "\r",
      "When you pass a ref, `useToggle` will return a simple toggle function instead:\r",
      "\r",
      "```js\r",
      "import { useDark, useToggle } from '@vueuse/core'\r",
      "\r",
      "const isDark = useDark()\r",
      "const toggleDark = useToggle(isDark)\r",
      "```\r",
      "\r",
      "Note: be aware that the toggle function accepts the first argument as the override value. You might want to avoid directly passing the function to events in the template, as the event object will pass in.\r",
      "\r",
      "```html\r",
      "<!-- caution: $event will be pass in -->\r",
      "<button @click=\"toggleDark\" />\r",
      "<!-- recommended to do this -->\r",
      "<button @click=\"toggleDark()\" />\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { Ref } from 'vue-demi'\r",
      "import { isRef, ref } from 'vue-demi'\r",
      "import type { MaybeRef, MaybeRefOrGetter } from '../utils'\r",
      "import { toValue } from '../toValue'\r",
      "\r",
      "export interface UseToggleOptions<Truthy, Falsy> {\r",
      "  truthyValue?: MaybeRefOrGetter<Truthy>\r",
      "  falsyValue?: MaybeRefOrGetter<Falsy>\r",
      "}\r",
      "\r",
      "export function useToggle<Truthy, Falsy, T = Truthy | Falsy>(initialValue: Ref<T>, options?: UseToggleOptions<Truthy, Falsy>): (value?: T) => T\r",
      "export function useToggle<Truthy = true, Falsy = false, T = Truthy | Falsy>(initialValue?: T, options?: UseToggleOptions<Truthy, Falsy>): [Ref<T>, (value?: T) => T]\r",
      "\r",
      "/**\r",
      " * A boolean ref with a toggler\r",
      " *\r",
      " * @see https://vueuse.org/useToggle\r",
      " * @param [initialValue=false]\r",
      " */\r",
      "export function useToggle(\r",
      "  initialValue: MaybeRef<boolean> = false,\r",
      "  options: UseToggleOptions<true, false> = {},\r",
      ") {\r",
      "  const {\r",
      "    truthyValue = true,\r",
      "    falsyValue = false,\r",
      "  } = options\r",
      "\r",
      "  const valueIsRef = isRef(initialValue)\r",
      "  const _value = ref(initialValue) as Ref<boolean>\r",
      "\r",
      "  function toggle(value?: boolean) {\r",
      "    // has arguments\r",
      "    if (arguments.length) {\r",
      "      _value.value = value!\r",
      "      return _value.value\r",
      "    }\r",
      "    else {\r",
      "      const truthy = toValue(truthyValue)\r",
      "      _value.value = _value.value === truthy\r",
      "        ? toValue(falsyValue)\r",
      "        : truthy\r",
      "      return _value.value\r",
      "    }\r",
      "  }\r",
      "\r",
      "  if (valueIsRef)\r",
      "    return toggle\r",
      "  else\r",
      "    return [_value, toggle] as const\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { useToggle } from '@vueuse/core'\r",
      "\r",
      "const [value, toggle] = useToggle()\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <p>Value: {{ value ? 'ON' : 'OFF' }}</p>\r",
      "    <button @click=\"toggle()\">\r",
      "      Toggle\r",
      "    </button>\r",
      "    <button @click=\"value = true\">\r",
      "      Set ON\r",
      "    </button>\r",
      "    <button @click=\"value = false\">\r",
      "      Set OFF\r",
      "    </button>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue watchDebounced - vueuse": {
    "prefix": "hvue watchDebounced - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Watch\r",
      "alias: debouncedWatch\r",
      "---\r",
      "\r",
      "# watchDebounced\r",
      "\r",
      "Debounced watch\r",
      "\r",
      "## Usage\r",
      "\r",
      "Similar to `watch`, but offering extra options `debounce` and `maxWait` which will be applied to the callback function.\r",
      "\r",
      "```ts\r",
      "import { watchDebounced } from '@vueuse/core'\r",
      "\r",
      "watchDebounced(\r",
      "  source,\r",
      "  () => { console.log('changed!') },\r",
      "  { debounce: 500, maxWait: 1000 },\r",
      ")\r",
      "```\r",
      "\r",
      "It's essentially a shorthand for the following code:\r",
      "\r",
      "```ts\r",
      "import { debounceFilter, watchWithFilter } from '@vueuse/core'\r",
      "\r",
      "watchWithFilter(\r",
      "  source,\r",
      "  () => { console.log('changed!') },\r",
      "  {\r",
      "    eventFilter: debounceFilter(500, { maxWait: 1000 }),\r",
      "  },\r",
      ")\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { WatchCallback, WatchOptions, WatchSource, WatchStopHandle } from 'vue-demi'\r",
      "import type { DebounceFilterOptions, MapOldSources, MapSources, MaybeRefOrGetter } from '../utils'\r",
      "import { debounceFilter } from '../utils'\r",
      "import { watchWithFilter } from '../watchWithFilter'\r",
      "\r",
      "export interface WatchDebouncedOptions<Immediate> extends WatchOptions<Immediate>, DebounceFilterOptions {\r",
      "  debounce?: MaybeRefOrGetter<number>\r",
      "}\r",
      "\r",
      "// overloads\r",
      "export function watchDebounced<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchDebouncedOptions<Immediate>): WatchStopHandle\r",
      "export function watchDebounced<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchDebouncedOptions<Immediate>): WatchStopHandle\r",
      "export function watchDebounced<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchDebouncedOptions<Immediate>): WatchStopHandle\r",
      "\r",
      "// implementation\r",
      "export function watchDebounced<Immediate extends Readonly<boolean> = false>(\r",
      "  source: any,\r",
      "  cb: any,\r",
      "  options: WatchDebouncedOptions<Immediate> = {},\r",
      "): WatchStopHandle {\r",
      "  const {\r",
      "    debounce = 0,\r",
      "    maxWait = undefined,\r",
      "    ...watchOptions\r",
      "  } = options\r",
      "\r",
      "  return watchWithFilter(\r",
      "    source,\r",
      "    cb,\r",
      "    {\r",
      "      ...watchOptions,\r",
      "      eventFilter: debounceFilter(debounce, { maxWait }),\r",
      "    },\r",
      "  )\r",
      "}\r",
      "\r",
      "// alias\r",
      "export { watchDebounced as debouncedWatch }\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { watchDebounced } from '@vueuse/core'\r",
      "\r",
      "const input = ref('')\r",
      "const updated = ref(0)\r",
      "\r",
      "watchDebounced(input, () => {\r",
      "  updated.value += 1\r",
      "}, { debounce: 1000, maxWait: 5000 })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <input v-model=\"input\" placeholder=\"Try to type anything...\" type=\"text\">\r",
      "    <note>Delay is set to 1000ms and maxWait is set to 5000ms for this demo.</note>\r",
      "\r",
      "    <p>Input: {{ input }}</p>\r",
      "    <p>Times Updated: {{ updated }}</p>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue watchIgnorable - vueuse": {
    "prefix": "hvue watchIgnorable - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Watch\r",
      "alias: ignorableWatch\r",
      "---\r",
      "\r",
      "# watchIgnorable\r",
      "\r",
      "Ignorable watch\r",
      "\r",
      "## Usage\r",
      "\r",
      "Extended `watch` that returns extra `ignoreUpdates(updater)` and `ignorePrevAsyncUpdates()` to ignore particular updates to the source.\r",
      "\r",
      "```ts\r",
      "import { watchIgnorable } from '@vueuse/core'\r",
      "import { nextTick, ref } from 'vue'\r",
      "\r",
      "const source = ref('foo')\r",
      "\r",
      "const { stop, ignoreUpdates } = watchIgnorable(\r",
      "  source,\r",
      "  v => console.log(`Changed to ${v}!`),\r",
      ")\r",
      "\r",
      "source.value = 'bar'\r",
      "await nextTick() // logs: Changed to bar!\r",
      "\r",
      "ignoreUpdates(() => {\r",
      "  source.value = 'foobar'\r",
      "})\r",
      "await nextTick() // (nothing happened)\r",
      "\r",
      "source.value = 'hello'\r",
      "await nextTick() // logs: Changed to hello!\r",
      "\r",
      "ignoreUpdates(() => {\r",
      "  source.value = 'ignored'\r",
      "})\r",
      "source.value = 'logged'\r",
      "\r",
      "await nextTick() // logs: Changed to logged!\r",
      "```\r",
      "\r",
      "## Flush timing\r",
      "\r",
      "`watchIgnorable` accepts the same options as `watch` and uses the same defaults.\r",
      "So, by default the composable works using `flush: 'pre'`.\r",
      "\r",
      "## `ignorePrevAsyncUpdates`\r",
      "\r",
      "This feature is only for async flush `'pre'` and `'post'`. If `flush: 'sync'` is used, `ignorePrevAsyncUpdates()` is a no-op as the watch will trigger immediately after each update to the source. It is still provided for sync flush so the code can be more generic.\r",
      "\r",
      "```ts\r",
      "import { watchIgnorable } from '@vueuse/core'\r",
      "import { nextTick, ref } from 'vue'\r",
      "\r",
      "const source = ref('foo')\r",
      "\r",
      "const { ignorePrevAsyncUpdates } = watchIgnorable(\r",
      "  source,\r",
      "  v => console.log(`Changed to ${v}!`),\r",
      ")\r",
      "\r",
      "source.value = 'bar'\r",
      "await nextTick() // logs: Changed to bar!\r",
      "\r",
      "source.value = 'good'\r",
      "source.value = 'by'\r",
      "ignorePrevAsyncUpdates()\r",
      "\r",
      "await nextTick() // (nothing happened)\r",
      "\r",
      "source.value = 'prev'\r",
      "ignorePrevAsyncUpdates()\r",
      "source.value = 'after'\r",
      "\r",
      "await nextTick() // logs: Changed to after!\r",
      "```\r",
      "\r",
      "## Recommended Readings\r",
      "\r",
      "- [Ignorable Watch](https://patak.dev/vue/ignorable-watch.html) - by [@matias-capeletto](https://github.com/matias-capeletto)\r",
      "# Source TS",
      "```js",
      "import type { WatchCallback, WatchSource, WatchStopHandle } from 'vue-demi'\r",
      "import { ref, watch } from 'vue-demi'\r",
      "import type { Fn, MapOldSources, MapSources } from '../utils'\r",
      "import { bypassFilter, createFilterWrapper } from '../utils'\r",
      "import type { WatchWithFilterOptions } from '../watchWithFilter'\r",
      "\r",
      "// watchIgnorable(source,callback,options) composable\r",
      "//\r",
      "// Extended watch that exposes a ignoreUpdates(updater) function that allows to update the source without triggering effects\r",
      "\r",
      "export type IgnoredUpdater = (updater: () => void) => void\r",
      "\r",
      "export interface WatchIgnorableReturn {\r",
      "  ignoreUpdates: IgnoredUpdater\r",
      "  ignorePrevAsyncUpdates: () => void\r",
      "  stop: WatchStopHandle\r",
      "}\r",
      "\r",
      "export function watchIgnorable<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): WatchIgnorableReturn\r",
      "export function watchIgnorable<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchIgnorableReturn\r",
      "export function watchIgnorable<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchIgnorableReturn\r",
      "\r",
      "export function watchIgnorable<Immediate extends Readonly<boolean> = false>(\r",
      "  source: any,\r",
      "  cb: any,\r",
      "  options: WatchWithFilterOptions<Immediate> = {},\r",
      "): WatchIgnorableReturn {\r",
      "  const {\r",
      "    eventFilter = bypassFilter,\r",
      "    ...watchOptions\r",
      "  } = options\r",
      "\r",
      "  const filteredCb = createFilterWrapper(\r",
      "    eventFilter,\r",
      "    cb,\r",
      "  )\r",
      "\r",
      "  let ignoreUpdates: IgnoredUpdater\r",
      "  let ignorePrevAsyncUpdates: () => void\r",
      "  let stop: () => void\r",
      "\r",
      "  if (watchOptions.flush === 'sync') {\r",
      "    const ignore = ref(false)\r",
      "\r",
      "    // no op for flush: sync\r",
      "    ignorePrevAsyncUpdates = () => {}\r",
      "\r",
      "    ignoreUpdates = (updater: () => void) => {\r",
      "      // Call the updater function and count how many sync updates are performed,\r",
      "      // then add them to the ignore count\r",
      "      ignore.value = true\r",
      "      updater()\r",
      "      ignore.value = false\r",
      "    }\r",
      "\r",
      "    stop = watch(\r",
      "      source,\r",
      "      (...args) => {\r",
      "        if (!ignore.value)\r",
      "          filteredCb(...args)\r",
      "      },\r",
      "      watchOptions,\r",
      "    )\r",
      "  }\r",
      "  else {\r",
      "    // flush 'pre' and 'post'\r",
      "\r",
      "    const disposables: Fn[] = []\r",
      "\r",
      "    // counters for how many following changes to be ignored\r",
      "    // ignoreCounter is incremented before there is a history operation\r",
      "    // affecting the source ref value (undo, redo, revert).\r",
      "    // syncCounter is incremented in sync with every change to the\r",
      "    // source ref value. This let us know how many times the ref\r",
      "    // was modified and support chained sync operations. If there\r",
      "    // are more sync triggers than the ignore count, the we now\r",
      "    // there are modifications in the source ref value that we\r",
      "    // need to commit\r",
      "    const ignoreCounter = ref(0)\r",
      "    const syncCounter = ref(0)\r",
      "\r",
      "    ignorePrevAsyncUpdates = () => {\r",
      "      ignoreCounter.value = syncCounter.value\r",
      "    }\r",
      "\r",
      "    // Sync watch to count modifications to the source\r",
      "    disposables.push(\r",
      "      watch(\r",
      "        source,\r",
      "        () => {\r",
      "          syncCounter.value++\r",
      "        },\r",
      "        { ...watchOptions, flush: 'sync' },\r",
      "      ),\r",
      "    )\r",
      "\r",
      "    ignoreUpdates = (updater: () => void) => {\r",
      "      // Call the updater function and count how many sync updates are performed,\r",
      "      // then add them to the ignore count\r",
      "      const syncCounterPrev = syncCounter.value\r",
      "      updater()\r",
      "      ignoreCounter.value += syncCounter.value - syncCounterPrev\r",
      "    }\r",
      "\r",
      "    disposables.push(\r",
      "      watch(\r",
      "        source,\r",
      "        (...args) => {\r",
      "          // If a history operation was performed (ignoreCounter > 0) and there are\r",
      "          // no other changes to the source ref value afterwards, then ignore this commit\r",
      "          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value\r",
      "          ignoreCounter.value = 0\r",
      "          syncCounter.value = 0\r",
      "          if (ignore)\r",
      "            return\r",
      "\r",
      "          filteredCb(...args)\r",
      "        },\r",
      "        watchOptions,\r",
      "      ),\r",
      "    )\r",
      "\r",
      "    stop = () => {\r",
      "      disposables.forEach(fn => fn())\r",
      "    }\r",
      "  }\r",
      "\r",
      "  return { stop, ignoreUpdates, ignorePrevAsyncUpdates }\r",
      "}\r",
      "\r",
      "// alias\r",
      "export { watchIgnorable as ignorableWatch }\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { watchIgnorable } from '@vueuse/core'\r",
      "\r",
      "const log = ref('')\r",
      "const source = ref(0)\r",
      "\r",
      "const { ignoreUpdates } = watchIgnorable(\r",
      "  source,\r",
      "  v => (log.value += `Changed to \"${v}\"\\n`),\r",
      "  { flush: 'sync' },\r",
      ")\r",
      "\r",
      "function clear() {\r",
      "  source.value = 0\r",
      "  log.value = ''\r",
      "}\r",
      "function update() {\r",
      "  source.value++\r",
      "}\r",
      "function ignoredUpdate() {\r",
      "  ignoreUpdates(() => {\r",
      "    source.value++\r",
      "  })\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Value: {{ source }}</div>\r",
      "  <button @click=\"update\">\r",
      "    Update\r",
      "  </button>\r",
      "  <button class=\"orange\" @click=\"ignoredUpdate\">\r",
      "    Ignored Update\r",
      "  </button>\r",
      "  <button @click=\"clear\">\r",
      "    Reset\r",
      "  </button>\r",
      "\r",
      "  <br>\r",
      "\r",
      "  <note>Log</note>\r",
      "\r",
      "  <pre>{{ log }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue watchPausable - vueuse": {
    "prefix": "hvue watchPausable - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Watch\r",
      "alias: pausableWatch\r",
      "---\r",
      "\r",
      "# watchPausable\r",
      "\r",
      "Pausable watch\r",
      "\r",
      "## Usage\r",
      "\r",
      "Use as normal the `watch`, but return extra `pause()` and `resume()` functions to control.\r",
      "\r",
      "```ts\r",
      "import { watchPausable } from '@vueuse/core'\r",
      "import { nextTick, ref } from 'vue'\r",
      "\r",
      "const source = ref('foo')\r",
      "\r",
      "const { stop, pause, resume } = watchPausable(\r",
      "  source,\r",
      "  v => console.log(`Changed to ${v}!`),\r",
      ")\r",
      "\r",
      "source.value = 'bar'\r",
      "await nextTick() // Changed to bar!\r",
      "\r",
      "pause()\r",
      "\r",
      "source.value = 'foobar'\r",
      "await nextTick() // (nothing happend)\r",
      "\r",
      "resume()\r",
      "\r",
      "source.value = 'hello'\r",
      "await nextTick() // Changed to hello!\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { WatchCallback, WatchSource, WatchStopHandle } from 'vue-demi'\r",
      "import type { MapOldSources, MapSources, Pausable } from '../utils'\r",
      "import { pausableFilter } from '../utils'\r",
      "import type { WatchWithFilterOptions } from '../watchWithFilter'\r",
      "import { watchWithFilter } from '../watchWithFilter'\r",
      "\r",
      "export interface WatchPausableReturn extends Pausable {\r",
      "  stop: WatchStopHandle\r",
      "}\r",
      "\r",
      "// overloads\r",
      "export function watchPausable<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchWithFilterOptions<Immediate>): WatchPausableReturn\r",
      "export function watchPausable<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchPausableReturn\r",
      "export function watchPausable<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchWithFilterOptions<Immediate>): WatchPausableReturn\r",
      "\r",
      "// implementation\r",
      "export function watchPausable<Immediate extends Readonly<boolean> = false>(\r",
      "  source: any,\r",
      "  cb: any,\r",
      "  options: WatchWithFilterOptions<Immediate> = {},\r",
      "): WatchPausableReturn {\r",
      "  const {\r",
      "    eventFilter: filter,\r",
      "    ...watchOptions\r",
      "  } = options\r",
      "\r",
      "  const { eventFilter, pause, resume, isActive } = pausableFilter(filter)\r",
      "  const stop = watchWithFilter(\r",
      "    source,\r",
      "    cb,\r",
      "    {\r",
      "      ...watchOptions,\r",
      "      eventFilter,\r",
      "    },\r",
      "  )\r",
      "\r",
      "  return { stop, pause, resume, isActive }\r",
      "}\r",
      "\r",
      "// alias\r",
      "export { watchPausable as pausableWatch }\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { onStartTyping, watchPausable } from '@vueuse/core'\r",
      "\r",
      "const input = ref<HTMLInputElement | null>()\r",
      "const log = ref('')\r",
      "\r",
      "const source = ref('')\r",
      "\r",
      "const watcher = watchPausable(\r",
      "  source,\r",
      "  v => (log.value += `Changed to \"${v}\"\\n`),\r",
      ")\r",
      "\r",
      "onStartTyping(() => input.value?.focus())\r",
      "\r",
      "function clear() {\r",
      "  log.value = ''\r",
      "}\r",
      "function pause() {\r",
      "  log.value += 'Paused\\n'\r",
      "  watcher.pause()\r",
      "}\r",
      "function resume() {\r",
      "  log.value += 'Resumed\\n'\r",
      "  watcher.resume()\r",
      "}\r",
      "\r",
      "const { isActive } = watcher\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <note class=\"mb-2\">\r",
      "      Type something below to trigger the watch\r",
      "    </note>\r",
      "    <input\r",
      "      ref=\"input\"\r",
      "      v-model=\"source\"\r",
      "      type=\"text\"\r",
      "    >\r",
      "\r",
      "    <button :disabled=\"!isActive\" class=\"orange\" @click=\"pause\">\r",
      "      Pause\r",
      "    </button>\r",
      "    <button :disabled=\"isActive\" @click=\"resume\">\r",
      "      Resume\r",
      "    </button>\r",
      "    <button @click=\"clear\">\r",
      "      Clear Log\r",
      "    </button>\r",
      "\r",
      "    <br>\r",
      "    <br>\r",
      "\r",
      "    <note>Log</note>\r",
      "\r",
      "    <pre>{{ log }}</pre>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue watchThrottled - vueuse": {
    "prefix": "hvue watchThrottled - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Watch\r",
      "alias: throttledWatch\r",
      "---\r",
      "\r",
      "# watchThrottled\r",
      "\r",
      "Throttled watch.\r",
      "\r",
      "## Usage\r",
      "\r",
      "Similar to `watch`, but offering an extra option `throttle` which will be applied to the callback function.\r",
      "\r",
      "```ts\r",
      "import { watchThrottled } from '@vueuse/core'\r",
      "\r",
      "watchThrottled(\r",
      "  source,\r",
      "  () => { console.log('changed!') },\r",
      "  { throttle: 500 },\r",
      ")\r",
      "```\r",
      "\r",
      "It's essentially a shorthand for the following code:\r",
      "\r",
      "```ts\r",
      "import { throttleFilter, watchWithFilter } from '@vueuse/core'\r",
      "\r",
      "watchWithFilter(\r",
      "  source,\r",
      "  () => { console.log('changed!') },\r",
      "  {\r",
      "    eventFilter: throttleFilter(500),\r",
      "  },\r",
      ")\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { WatchCallback, WatchOptions, WatchSource, WatchStopHandle } from 'vue-demi'\r",
      "import type { MapOldSources, MapSources, MaybeRefOrGetter } from '../utils'\r",
      "import { throttleFilter } from '../utils'\r",
      "import { watchWithFilter } from '../watchWithFilter'\r",
      "\r",
      "export interface WatchThrottledOptions<Immediate> extends WatchOptions<Immediate> {\r",
      "  throttle?: MaybeRefOrGetter<number>\r",
      "  trailing?: boolean\r",
      "  leading?: boolean\r",
      "}\r",
      "\r",
      "// overloads\r",
      "export function watchThrottled<T extends Readonly<WatchSource<unknown>[]>, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T>, MapOldSources<T, Immediate>>, options?: WatchThrottledOptions<Immediate>): WatchStopHandle\r",
      "export function watchThrottled<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchThrottledOptions<Immediate>): WatchStopHandle\r",
      "export function watchThrottled<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, Immediate extends true ? T | undefined : T>, options?: WatchThrottledOptions<Immediate>): WatchStopHandle\r",
      "\r",
      "// implementation\r",
      "export function watchThrottled<Immediate extends Readonly<boolean> = false>(\r",
      "  source: any,\r",
      "  cb: any,\r",
      "  options: WatchThrottledOptions<Immediate> = {},\r",
      "): WatchStopHandle {\r",
      "  const {\r",
      "    throttle = 0,\r",
      "    trailing = true,\r",
      "    leading = true,\r",
      "    ...watchOptions\r",
      "  } = options\r",
      "\r",
      "  return watchWithFilter(\r",
      "    source,\r",
      "    cb,\r",
      "    {\r",
      "      ...watchOptions,\r",
      "      eventFilter: throttleFilter(throttle, trailing, leading),\r",
      "    },\r",
      "  )\r",
      "}\r",
      "\r",
      "// alias\r",
      "export { watchThrottled as throttledWatch }\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { watchThrottled } from '@vueuse/core'\r",
      "\r",
      "const input = ref('')\r",
      "const updated = ref(0)\r",
      "\r",
      "watchThrottled(input, () => {\r",
      "  updated.value += 1\r",
      "}, { throttle: 1000 })\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>\r",
      "    <input v-model=\"input\" placeholder=\"Try to type anything...\" type=\"text\">\r",
      "    <note>Delay is set to 1000ms for this demo.</note>\r",
      "\r",
      "    <p>Input: {{ input }}</p>\r",
      "    <p>Times Updated: {{ updated }}</p>\r",
      "  </div>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue watchTriggerable - vueuse": {
    "prefix": "hvue watchTriggerable - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "---\r",
      "category: Watch\r",
      "---\r",
      "\r",
      "# watchTriggerable\r",
      "\r",
      "Watch that can be triggered manually\r",
      "\r",
      "## Usage\r",
      "\r",
      "A `watch` wrapper that supports manual triggering of `WatchCallback`, which returns an additional `trigger` to execute a `WatchCallback` immediately.\r",
      "\r",
      "```ts\r",
      "import { watchTriggerable } from '@vueuse/core'\r",
      "import { nextTick, ref } from 'vue'\r",
      "\r",
      "const source = ref(0)\r",
      "\r",
      "const { trigger, ignoreUpdates } = watchTriggerable(\r",
      "  source,\r",
      "  v => console.log(`Changed to ${v}!`),\r",
      ")\r",
      "\r",
      "source.value = 'bar'\r",
      "await nextTick() // logs: Changed to bar!\r",
      "\r",
      "// Execution of WatchCallback via `trigger` does not require waiting\r",
      "trigger() // logs: Changed to bar!\r",
      "```\r",
      "\r",
      "### `onCleanup`\r",
      "When you want to manually call a `watch` that uses the onCleanup parameter; simply taking the `WatchCallback` out and calling it doesn't make it easy to implement the `onCleanup` parameter.\r",
      "\r",
      "Using `watchTriggerable` will solve this problem.\r",
      "```ts\r",
      "import { watchTriggerable } from '@vueuse/core'\r",
      "import { ref } from 'vue'\r",
      "\r",
      "const source = ref(0)\r",
      "\r",
      "const { trigger } = watchTriggerable(\r",
      "  source,\r",
      "  async (v, _, onCleanup) => {\r",
      "    let canceled = false\r",
      "    onCleanup(() => canceled = true)\r",
      "\r",
      "    await new Promise(resolve => setTimeout(resolve, 500))\r",
      "    if (canceled)\r",
      "      return\r",
      "\r",
      "    console.log(`The value is \"${v}\"\\n`)\r",
      "  },\r",
      ")\r",
      "\r",
      "source.value = 1 // no log\r",
      "await trigger() // logs (after 500 ms): The value is \"1\"\r",
      "```\r",
      "# Source TS",
      "```js",
      "import type { WatchSource } from 'vue-demi'\r",
      "import { isReactive } from 'vue-demi'\r",
      "import type { MapOldSources, MapSources } from '../utils'\r",
      "import type { WatchIgnorableReturn } from '../watchIgnorable'\r",
      "import { watchIgnorable } from '../watchIgnorable'\r",
      "import type { WatchWithFilterOptions } from '../watchWithFilter'\r",
      "import { toValue } from '../toValue'\r",
      "\r",
      "// Watch that can be triggered manually\r",
      "// A `watch` wrapper that supports manual triggering of `WatchCallback`, which returns an additional `trigger` to execute a `WatchCallback` immediately.\r",
      "\r",
      "export interface WatchTriggerableReturn<FnReturnT = void> extends WatchIgnorableReturn {\r",
      "  /** Execute `WatchCallback` immediately */\r",
      "  trigger: () => FnReturnT\r",
      "}\r",
      "\r",
      "type OnCleanup = (cleanupFn: () => void) => void\r",
      "\r",
      "export type WatchTriggerableCallback<V = any, OV = any, R = void> = (value: V, oldValue: OV, onCleanup: OnCleanup) => R\r",
      "\r",
      "export function watchTriggerable<T extends Readonly<WatchSource<unknown>[]>, FnReturnT>(sources: [...T], cb: WatchTriggerableCallback<MapSources<T>, MapOldSources<T, true>, FnReturnT>, options?: WatchWithFilterOptions<boolean>): WatchTriggerableReturn<FnReturnT>\r",
      "export function watchTriggerable<T, FnReturnT>(source: WatchSource<T>, cb: WatchTriggerableCallback<T, T | undefined, FnReturnT>, options?: WatchWithFilterOptions<boolean>): WatchTriggerableReturn<FnReturnT>\r",
      "export function watchTriggerable<T extends object, FnReturnT>(source: T, cb: WatchTriggerableCallback<T, T | undefined, FnReturnT>, options?: WatchWithFilterOptions<boolean>): WatchTriggerableReturn<FnReturnT>\r",
      "\r",
      "export function watchTriggerable<Immediate extends Readonly<boolean> = false>(\r",
      "  source: any,\r",
      "  cb: any,\r",
      "  options: WatchWithFilterOptions<Immediate> = {},\r",
      "): WatchTriggerableReturn {\r",
      "  let cleanupFn: (() => void) | undefined\r",
      "\r",
      "  function onEffect() {\r",
      "    if (!cleanupFn)\r",
      "      return\r",
      "\r",
      "    const fn = cleanupFn\r",
      "    cleanupFn = undefined\r",
      "    fn()\r",
      "  }\r",
      "\r",
      "  /** Register the function `cleanupFn` */\r",
      "  function onCleanup(callback: () => void) {\r",
      "    cleanupFn = callback\r",
      "  }\r",
      "\r",
      "  const _cb = (\r",
      "    value: any,\r",
      "    oldValue: any,\r",
      "  ) => {\r",
      "    // When a new side effect occurs, clean up the previous side effect\r",
      "    onEffect()\r",
      "\r",
      "    return cb(value, oldValue, onCleanup)\r",
      "  }\r",
      "  const res = watchIgnorable(source, _cb, options)\r",
      "  const { ignoreUpdates } = res\r",
      "\r",
      "  const trigger = () => {\r",
      "    let res: any\r",
      "    ignoreUpdates(() => {\r",
      "      res = _cb(getWatchSources(source), getOldValue(source))\r",
      "    })\r",
      "    return res\r",
      "  }\r",
      "\r",
      "  return {\r",
      "    ...res,\r",
      "    trigger,\r",
      "  }\r",
      "}\r",
      "\r",
      "function getWatchSources(sources: any) {\r",
      "  if (isReactive(sources))\r",
      "    return sources\r",
      "  if (Array.isArray(sources))\r",
      "    return sources.map(item => toValue(item))\r",
      "  return toValue(sources)\r",
      "}\r",
      "\r",
      "// For calls triggered by trigger, the old value is unknown, so it cannot be returned\r",
      "function getOldValue(source: any) {\r",
      "  return Array.isArray(source)\r",
      "    ? source.map(() => undefined)\r",
      "    : undefined\r",
      "}\r",
      "```",
      "# Demo",
      "```vue",
      "<script setup lang=\"ts\">\r",
      "import { ref } from 'vue'\r",
      "import { watchTriggerable } from '@vueuse/core'\r",
      "\r",
      "const log = ref('')\r",
      "const source = ref(0)\r",
      "\r",
      "const { trigger, ignoreUpdates } = watchTriggerable(\r",
      "  source,\r",
      "  async (v, _, onCleanup) => {\r",
      "    let canceled = false\r",
      "    onCleanup(() => canceled = true)\r",
      "    await new Promise(resolve => setTimeout(resolve, 500))\r",
      "    if (canceled)\r",
      "      return\r",
      "\r",
      "    log.value += `The value is \"${v}\"\\n`\r",
      "  },\r",
      ")\r",
      "\r",
      "function clear() {\r",
      "  ignoreUpdates(() => {\r",
      "    source.value = 0\r",
      "    log.value = ''\r",
      "  })\r",
      "}\r",
      "function update() {\r",
      "  source.value++\r",
      "}\r",
      "</script>\r",
      "\r",
      "<template>\r",
      "  <div>Value: {{ source }}</div>\r",
      "  <button @click=\"update\">\r",
      "    Update\r",
      "  </button>\r",
      "  <button class=\"orange\" @click=\"trigger\">\r",
      "    Manual Trigger\r",
      "  </button>\r",
      "  <button @click=\"clear\">\r",
      "    Reset\r",
      "  </button>\r",
      "\r",
      "  <br>\r",
      "\r",
      "  <note>Log (500 ms delay)</note>\r",
      "\r",
      "  <pre>{{ log }}</pre>\r",
      "</template>\r",
      "```",
      ""
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue createHead - vueuse": {
    "prefix": "hvue createHead - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"createHead\",",
      "  \"package\": \"head\",",
      "  \"description\": \"create the head manager instance.\",",
      "  \"category\": \"@Head\",",
      "  \"external\": \"https://github.com/vueuse/head#api\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useHead - vueuse": {
    "prefix": "hvue useHead - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"useHead\",",
      "  \"package\": \"head\",",
      "  \"description\": \"update head meta tags reactively.\",",
      "  \"category\": \"@Head\",",
      "  \"external\": \"https://github.com/vueuse/head#api\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMotion - vueuse": {
    "prefix": "hvue useMotion - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"useMotion\",",
      "  \"package\": null,",
      "  \"description\": \"putting your components in motion.\",",
      "  \"category\": null,",
      "  \"external\": \"https://motion.vueuse.org/api/use-motion.html\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useSpring - vueuse": {
    "prefix": "hvue useSpring - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"useSpring\",",
      "  \"package\": null,",
      "  \"description\": \"spring animations.\",",
      "  \"category\": null,",
      "  \"external\": \"https://motion.vueuse.org/api/use-spring.html\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMotionProperties - vueuse": {
    "prefix": "hvue useMotionProperties - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"useMotionProperties\",",
      "  \"package\": null,",
      "  \"description\": \"access Motion Properties for a target element.\",",
      "  \"category\": null,",
      "  \"external\": \"https://motion.vueuse.org/api/use-motion-properties.html\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useMotionVariants - vueuse": {
    "prefix": "hvue useMotionVariants - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"useMotionVariants\",",
      "  \"package\": null,",
      "  \"description\": \"handle the Variants state and selection.\",",
      "  \"category\": null,",
      "  \"external\": \"https://motion.vueuse.org/api/use-motion-variants.html\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useElementStyle - vueuse": {
    "prefix": "hvue useElementStyle - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"useElementStyle\",",
      "  \"package\": null,",
      "  \"description\": \"sync a reactive object to a target element CSS styling\",",
      "  \"category\": null,",
      "  \"external\": \"https://motion.vueuse.org/api/use-element-style.html\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useElementTransform - vueuse": {
    "prefix": "hvue useElementTransform - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"useElementTransform\",",
      "  \"package\": null,",
      "  \"description\": \"sync a reactive object to a target element CSS transform.\",",
      "  \"category\": null,",
      "  \"external\": \"https://motion.vueuse.org/api/use-element-transform.html\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useSound - vueuse": {
    "prefix": "hvue useSound - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"useSound\",",
      "  \"package\": \"sound\",",
      "  \"description\": \"play sound effects reactively.\",",
      "  \"category\": \"@Sound\",",
      "  \"external\": \"https://github.com/vueuse/sound#examples\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue createSchemaOrg - vueuse": {
    "prefix": "hvue createSchemaOrg - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"createSchemaOrg\",",
      "  \"package\": \"schema-org\",",
      "  \"description\": \"create the schema.org manager instance.\",",
      "  \"category\": \"@SchemaOrg\",",
      "  \"external\": \"https://vue-schema-org.netlify.app/api/core/create-schema-org.html\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  },
  "hvue useSchemaOrg - vueuse": {
    "prefix": "hvue useSchemaOrg - vueuse",
    "type": "md",
    "isCode": false,
    "body": [
      "{",
      "  \"name\": \"useSchemaOrg\",",
      "  \"package\": \"schema-org\",",
      "  \"description\": \"update schema.org reactively.\",",
      "  \"category\": \"@SchemaOrg\",",
      "  \"external\": \"https://vue-schema-org.netlify.app/api/core/use-schema-org.html\"",
      "}"
    ],
    "description": "https://github.com/vueuse/vueuse"
  }
}